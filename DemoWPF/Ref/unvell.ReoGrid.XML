<?xml version="1.0"?>
<doc>
    <assembly>
        <name>unvell.ReoGrid</name>
    </assembly>
    <members>
        <member name="T:unvell.ReoGrid.Chart.AxisDataInfo">
            <summary>
            Axis data information for axis-based chart.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Chart.AxisDataInfo.Levels">
            <summary>
            Get or set the plot vertial levels.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Chart.AxisDataInfo.Scaler">
            <summary>
            Get or set axis scaler.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Chart.AxisDataInfo.Minimum">
            <summary>
            Get or set axis minimum value.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Chart.AxisDataInfo.Maximum">
            <summary>
            Get or set axis maximum value.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Chart.AxisDataInfo.AutoMinimum">
            <summary>
            Specifies that whether or not to decide the axis minimum value automatically by scanning data.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Chart.AxisDataInfo.AutoMaximum">
            <summary>
            Specifies that whether or not to decide the axis maximum value automatically by scanning data.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Chart.AxisDataInfo.LargeStride">
            <summary>
            Get or set the axis large stride value.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Chart.AxisDataInfo.SmallStride">
            <summary>
            Get or set the axis small stride value.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Chart.AxisTypes">
            <summary>
            Axis Types
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Chart.AxisTypes.Primary">
            <summary>
            Primary axis
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Chart.AxisTypes.Secondary">
            <summary>
            Secondary axis
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Chart.AxisOrientation">
            <summary>
            Axis Orientations
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Chart.AxisOrientation.Horizontal">
            <summary>
            Horizontal
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Chart.AxisOrientation.Vertical">
            <summary>
            Vertical
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Chart.AxisCategoryLabelView.OnPaint(unvell.ReoGrid.Rendering.DrawingContext)">
            <summary>
            Render axis information view.
            </summary>
            <param name="dc">Platform no-associated drawing context instance.</param>
        </member>
        <member name="M:unvell.ReoGrid.Chart.AxisSerialLabelView.OnPaint(unvell.ReoGrid.Rendering.DrawingContext)">
            <summary>
            Render data label view.
            </summary>
            <param name="dc">Platform no-associated drawing context instance.</param>
        </member>
        <member name="M:unvell.ReoGrid.Chart.AxisGuideLinePlotView.OnPaint(unvell.ReoGrid.Rendering.DrawingContext)">
            <summary>
            Render axis plot view.
            </summary>
            <param name="dc">Platform unassociated drawing context instance.</param>
        </member>
        <member name="T:unvell.ReoGrid.Chart.IChartDataSource`1">
            <summary>
            Represents the interface of data source used for chart.
            </summary>
            <typeparam name="T">Standard data serial classes.</typeparam>
        </member>
        <member name="P:unvell.ReoGrid.Chart.IChartDataSource`1.CategoryCount">
            <summary>
            Get number of categories.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Chart.IChartDataSource`1.GetCategoryName(System.Int32)">
            <summary>
            Get category name by specified index position.
            </summary>
            <param name="index">Zero-based number of category to get its name.</param>
            <returns>Specified category's name by index position.</returns>
        </member>
        <member name="T:unvell.ReoGrid.Chart.IChartDataSerial">
            <summary>
            Represents the interface of data serial used for chart.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Chart.IChartDataSerial.Label">
            <summary>
            Get the serial name.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Chart.WorksheetChartDataSource">
            <summary>
            Data source from given worksheet
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Chart.WorksheetChartDataSource.Worksheet">
            <summary>
            Get instance of worksheet
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Chart.WorksheetChartDataSource.RowTitleRange">
            <summary>
            Get or set the range to read row serial titles.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Chart.WorksheetChartDataSource.ColTitleRange">
            <summary>
            Get or set the range to read column serial titles.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Chart.WorksheetChartDataSource.#ctor(unvell.ReoGrid.Worksheet)">
            <summary>
            Create data source instance with specified worksheet instance
            </summary>
            <param name="worksheet">Instance of worksheet to read titles and data of plot serial.</param>
        </member>
        <member name="M:unvell.ReoGrid.Chart.WorksheetChartDataSource.#ctor(unvell.ReoGrid.Worksheet,System.String,System.String,unvell.ReoGrid.RowOrColumn)">
            <summary>
            Create data source instance with specified worksheet instance
            </summary>
            <param name="worksheet">Instance of worksheet to read titles and data of plot serial.</param>
            <param name="serialNamesRange">Names for serial data from this range.</param>
            <param name="serialsRange">Serial data from this range.</param>
            <param name="serialPerRowOrColumn">Add serials by this specified direction. Default is Row.</param>
        </member>
        <member name="M:unvell.ReoGrid.Chart.WorksheetChartDataSource.#ctor(unvell.ReoGrid.Worksheet,unvell.ReoGrid.RangePosition,unvell.ReoGrid.RangePosition,unvell.ReoGrid.RowOrColumn)">
            <summary>
            Create data source instance with specified worksheet instance and serial data range.
            </summary>
            <param name="worksheet">Instance of worksheet to read titles and data of plot serial.</param>
            <param name="serialNamesRange">Range to read labels of data serial.</param>
            <param name="serialsRange">Range to read serial data.</param>
            <param name="serialPerRowOrColumn">Add serials by this specified direction. Default is Row.</param>
        </member>
        <member name="M:unvell.ReoGrid.Chart.WorksheetChartDataSource.OnDataChanged">
            <summary>
            This method will be invoked when any data from the serial data range changed.
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.Chart.WorksheetChartDataSource.DataChanged">
            <summary>
            This event will be raised when data from the serial data range changed.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Chart.WorksheetChartDataSource.CategoryNameRange">
            <summary>
            Get or set the range that contains the category names.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Chart.WorksheetChartDataSource.GetCategoryName(System.Int32)">
            <summary>
            Return the title of specified column.
            </summary>
            <param name="index">Zero-based number of column.</param>
            <returns>Return the title that will be displayed on chart.</returns>
        </member>
        <member name="P:unvell.ReoGrid.Chart.WorksheetChartDataSource.SerialCount">
            <summary>
            Get number of data serials.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Chart.WorksheetChartDataSource.CategoryCount">
            <summary>
            Get number of categories.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Chart.WorksheetChartDataSource.Add(unvell.ReoGrid.Chart.WorksheetChartDataSerial)">
            <summary>
            Add serial data into data source.
            </summary>
            <param name="serial">Serial data source.</param>
        </member>
        <member name="M:unvell.ReoGrid.Chart.WorksheetChartDataSource.AddSerial(unvell.ReoGrid.Worksheet,unvell.ReoGrid.CellPosition,unvell.ReoGrid.RangePosition)">
            <summary>
            Add serial data into data source from a range, set the name as the label of serial.
            </summary>
            <param name="worksheet">Worksheet instance to read serial data.</param>
            <param name="name">Name for serial to be added.</param>
            <param name="serialRange">Range to read serial data from worksheet.</param>
            <returns>Instance of chart serial has been added.</returns>
        </member>
        <member name="P:unvell.ReoGrid.Chart.WorksheetChartDataSource.Serials">
            <summary>
            Get collection of data serials.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Chart.WorksheetChartDataSerialCollection">
            <summary>
            Represents collection of data serial.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Chart.WorksheetChartDataSerial">
            <summary>
            Represents implementation of chart data serial.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Chart.WorksheetChartDataSerial.Worksheet">
            <summary>
            Get instance of worksheet
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Chart.WorksheetChartDataSerial.DataRange">
            <summary>
            Determine the range to read data from worksheet
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Chart.WorksheetChartDataSerial.Finalize">
            <summary>
            Destroy the worksheet data serial and release all event handlers to data source.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Chart.WorksheetChartDataSerial.#ctor(unvell.ReoGrid.Chart.WorksheetChartDataSource,unvell.ReoGrid.Worksheet,unvell.ReoGrid.CellPosition,unvell.ReoGrid.RangePosition)">
            <param name="dataSource">Data source to read chart data from worksheet.</param>
            <param name="worksheet">Instance of worksheet that contains the data to be read.</param>
            <param name="labelAddress">The address to locate label of serial on worksheet.</param>
            <param name="dataRange">Serial data range to read serial data for chart from worksheet.</param>
        </member>
        <member name="M:unvell.ReoGrid.Chart.WorksheetChartDataSerial.#ctor(unvell.ReoGrid.Chart.WorksheetChartDataSource,unvell.ReoGrid.Worksheet,System.String,System.String)">
            <summary>
            Create data serial by specified worksheet instance and data range.
            </summary>
            <param name="dataSource">Data source to read chart data from worksheet.</param>
            <param name="worksheet">Instance of worksheet that contains the data to be read.</param>
            <param name="labelAddress">The address to locate label of serial on worksheet.</param>
            <param name="addressOrName">Serial data specified by address position or range's name.</param>
        </member>
        <member name="P:unvell.ReoGrid.Chart.WorksheetChartDataSerial.Label">
            <summary>
            Get label text of serial.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Chart.WorksheetChartDataSerial.Count">
            <summary>
            Get number of data items of current serial.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Chart.WorksheetChartDataSerial.Item(System.Int32)">
            <summary>
            Get data from serial by specified index position.
            </summary>
            <param name="index">Zero-based index position in serial to get data.</param>
            <returns>Data in double type to be get from specified index of serial.
            If index is out of range, or data in worksheet is null, then return null.
            </returns>
        </member>
        <member name="T:unvell.ReoGrid.Chart.IPlotView">
            <summary>
            Chart Plot View 
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Chart.ChartPlotView">
            <summary>
            Represents common chart plot view.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Chart.ChartPlotView.Chart">
            <summary>
            Get or set the owner chart to this plot view.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Chart.ChartPlotView.#ctor(unvell.ReoGrid.Chart.Chart)">
            <summary>
            Create common chart plot view object.
            </summary>
            <param name="chart">Owner chart instance.</param>
        </member>
        <member name="T:unvell.ReoGrid.Chart.Chart">
            <summary>
            Represents chart drawing component.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Chart.Chart.TitleView">
            <summary>
            Get or set the title string object.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Chart.Chart.Title">
            <summary>
            Get or set the title of chart.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Chart.Chart.#ctor">
            <summary>
            Create chart instance.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Chart.Chart.OnBoundsChanged(unvell.ReoGrid.Graphics.Rectangle)">
            <summary>
            Relayout this view.
            </summary>
            <param name="oldRect">Bounds rectangle before changed.</param>
        </member>
        <member name="M:unvell.ReoGrid.Chart.Chart.UpdateLayout">
            <summary>
            Update children view bounds.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Chart.Chart.GetTitleBounds">
            <summary>
            Get default title bounds.
            </summary>
            <returns>Rectangle of title bounds.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Chart.Chart.GetPlotViewBounds(unvell.ReoGrid.Graphics.Rectangle)">
            <summary>
            Get default body bounds.
            </summary>
            <returns>Rectangle of body bounds.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Chart.Chart.GetLegendBounds(unvell.ReoGrid.Graphics.Rectangle,unvell.ReoGrid.Chart.LegendType,unvell.ReoGrid.Chart.LegendPosition)">
            <summary>
            Get legend view bounds.
            </summary>
            <returns></returns>
        </member>
        <member name="P:unvell.ReoGrid.Chart.Chart.DataSource">
            <summary>
            Get or set chart data source.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Chart.Chart.OnDataChanged">
            <summary>
            This method will be invoked when data from data source is changed.
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.Chart.Chart.ChartDataChanged">
            <summary>
            This event will be invoked when chart data from data source is changed.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Chart.Chart.OnDataSourceChanged">
            <summary>
            This method will be invoked when chart data source is changed.
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.Chart.Chart.DataSourceChanged">
            <summary>
            This event will be invoked when chart data source is changed.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Chart.Chart.UpdatePlotData">
            <summary>
            Update chart when data source or data range has been changed.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Chart.Chart.PlotViewContainer">
            <summary>
            Get the chart plot view component.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Chart.Chart.AddPlotViewLayer(unvell.ReoGrid.Chart.IPlotView)">
            <summary>
            Add chart plot view object.
            </summary>
            <param name="view">Chart plot view object.</param>
        </member>
        <member name="P:unvell.ReoGrid.Chart.Chart.ShowLegend">
            <summary>
            Get or set whether or not to show legend view.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Chart.Chart.PrimaryLegend">
            <summary>
            Get or set the primary legend object.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Chart.Chart.CreateChartLegend(unvell.ReoGrid.Chart.LegendType)">
            <summary>
            Create chart legend.
            </summary>
            <returns>Instance of chart legend.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Chart.Chart.ResetDataSerialStyles">
            <summary>
            Reset data serial to row default styles.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Chart.Chart.DataSerialStyles">
            <summary>
            Get data serial styles.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Chart.Chart.OnMouseDown(unvell.ReoGrid.Graphics.Point,unvell.ReoGrid.Interaction.MouseButtons)">
            <summary>
            Handles the mouse down event.
            </summary>
            <param name="location">Relative location of mouse button press-down.</param>
            <param name="button">Determines that which mouse button is pressed down.</param>
            <returns>True if event has been handled; Otherwise false.</returns>
        </member>
        <member name="T:unvell.ReoGrid.Chart.AxisChart">
            <summary>
            Represents axis-based chart component. 
            This is an abstract class that should be implemented by other axis-based chart classes.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Chart.AxisChart.PrimaryAxisInfo">
            <summary>
            Get or set the primary axis information set.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Chart.AxisChart.SecondaryAxisInfo">
            <summary>
            Get or set the secondary axis information set.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Chart.AxisChart.HorizontalAxisInfoView">
            <summary>
            Get or set the primary axis view object.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Chart.AxisChart.VerticalAxisInfoView">
            <summary>
            Get or set the data label view object.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Chart.AxisChart.GuideLineBackgroundView">
            <summary>
            Get or set the grid line background view object.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Chart.AxisChart.ShowHorizontalGuideLines">
            <summary>
            Specifies that whether or not allow to display the horizontal guide lines.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Chart.AxisChart.ShowVerticalGuideLines">
            <summary>
            Specifies that whether or not allow to display the vertical guide lines.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Chart.AxisChart.#ctor">
            <summary>
            Create axis-based chart instance.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Chart.AxisChart.CreatePrimaryAxisCategoryLabelView(unvell.ReoGrid.Graphics.Rectangle)">
            <summary>
            Create default primary axis category label view.
            </summary>
            <param name="bodyBounds"></param>
            <returns></returns>
        </member>
        <member name="M:unvell.ReoGrid.Chart.AxisChart.GetDefaultVerticalAxisInfoViewBounds(unvell.ReoGrid.Graphics.Rectangle)">
            <summary>
            Return default vertical axis bounds.
            </summary>
            <param name="bodyBounds">Bounds of chart body.</param>
            <returns>Vertical axis bounds rectangle.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Chart.AxisChart.OnDataSourceChanged">
            <summary>
            This method will be invoked when data source of this chart is changed.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Chart.AxisChart.OnDataChanged">
            <summary>
            This method will be invoked when data from the data source of this chart is changed.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Chart.AxisChart.UpdatePlotData">
            <summary>
            Update chart data information.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Chart.AxisChart.UpdateAxisInfo(unvell.ReoGrid.Chart.AxisDataInfo,System.Double,System.Double)">
            <summary>
            Update specified axis information.
            </summary>
            <param name="ai">Axis information set.</param>
            <param name="minData">Minimum value scanned from data range.</param>
            <param name="maxData">Maximum value scanned from data range.</param>
        </member>
        <member name="M:unvell.ReoGrid.Chart.AxisChart.MeasureAxisRuler(unvell.ReoGrid.Chart.AxisDataInfo,System.Double)">
            <summary>
            Measure axis ruler information.
            </summary>
            <param name="info">Specified axis data information set.</param>
            <param name="data">Data to be measured.</param>
        </member>
        <member name="M:unvell.ReoGrid.Chart.AxisChart.AxisOriginToZero(System.Double,System.Double,System.Double)">
            <summary>
            Determines that whether or not allow to set axis minimum value to a non-zero position automatically.
            </summary>
            <param name="minData">Minimum data scanned from data source.</param>
            <param name="maxData">Maximum data scanned from data source.</param>
            <param name="range">Data range.</param>
            <returns>True to set axis minimum value; Otherwise false.</returns>
        </member>
        <member name="P:unvell.ReoGrid.Chart.AxisChart.ZeroWidth">
            <summary>
            Get the origin value of width related to this view object.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Chart.AxisChart.ZeroHeight">
            <summary>
            Get the origin value of height related to this view object.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Chart.AxisChart.ResetDrawPoints">
            <summary>
            Reset plot drawing points.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Chart.AxisChart.UpdateDrawPoints">
            <summary>
            Update plot drawing points.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Chart.AxisChart.OnBoundsChanged(unvell.ReoGrid.Graphics.Rectangle)">
            <summary>
            This method will be invoked when chart bounds changed.
            </summary>
            <param name="oldRect">Old bounds rectangle.</param>
        </member>
        <member name="M:unvell.ReoGrid.Chart.AxisChart.UpdateLayout">
            <summary>
            Update all children bounds.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Chart.ChartLegend">
            <summary>
            Represents chart legend view.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Chart.ChartLegend.Chart">
            <summary>
            Get the instance of owner chart.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Chart.ChartLegend.#ctor(unvell.ReoGrid.Chart.IChart)">
            <summary>
            Create chart legend view.
            </summary>
            <param name="chart">Instance of owner chart.</param>
        </member>
        <member name="P:unvell.ReoGrid.Chart.ChartLegend.LegendType">
            <summary>
            Get or set type of legend.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Chart.ChartLegend.LegendPosition">
            <summary>
            Get or set the display position of legend.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Chart.ChartLegend.GetSymbolSize(System.Int32)">
            <summary>
            Get default symbol size of chart legend.
            </summary>
            <param name="index">Index of serial in data source.</param>
            <returns>Symbol size of chart legend.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Chart.ChartLegend.GetLabelSize(System.Int32)">
            <summary>
            Measure serial label size.
            </summary>
            <param name="index">Index of serial in data source.</param>
            <returns>Measured size for serial label.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Chart.ChartLegend.GetPreferredSize">
            <summary>
            Get measured legend view size.
            </summary>
            <returns>Measured size of legend view.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Chart.ChartLegend.MeasureSize(unvell.ReoGrid.Graphics.Rectangle)">
            <summary>
            Layout all legned items.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Chart.ChartLegendItem">
            <summary>
            Represents chart legend item.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Chart.ChartLegendItem.OnPaintSymbol(unvell.ReoGrid.Rendering.DrawingContext)">
            <summary>
            Draw chart legend symbol.
            </summary>
            <param name="dc">Platform no-associated drawing context instance.</param>
        </member>
        <member name="M:unvell.ReoGrid.Chart.ChartLegendItem.OnPaintLabel(unvell.ReoGrid.Rendering.DrawingContext)">
            <summary>
            Draw chart legend label.
            </summary>
            <param name="dc">Platform no-associated drawing context instance.</param>
        </member>
        <member name="T:unvell.ReoGrid.Chart.LegendType">
            <summary>
            Legend type.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Chart.LegendType.PrimaryLegend">
            <summary>
            Primary legend.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Chart.LegendType.SecondaryLegend">
            <summary>
            Secondary legend.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Chart.LegendPosition">
            <summary>
            Legend position.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Chart.LegendPosition.Right">
            <summary>
            Right
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Chart.LegendPosition.Bottom">
            <summary>
            Bottom
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Chart.LegendPosition.Left">
            <summary>
            Left
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Chart.LegendPosition.Top">
            <summary>
            Top
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Chart.LineChart">
            <summary>
            Represents line chart component.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Chart.LineChart.LineChartPlotView">
            <summary>
            Get plot view object of line chart component.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Chart.LineChart.#ctor">
            <summary>
            Create line chart component instance.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Chart.LineChart.CreateChartLegend(unvell.ReoGrid.Chart.LegendType)">
            <summary>
            Creates and returns line chart legend instance.
            </summary>
            <returns>Instance of line chart legend.</returns>
        </member>
        <member name="T:unvell.ReoGrid.Chart.LineChartLegend">
            <summary>
            Represents line chart legend.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Chart.LineChartLegend.#ctor(unvell.ReoGrid.Chart.IChart)">
            <summary>
            Create line chart legend.
            </summary>
            <param name="chart">Parent chart component.</param>
        </member>
        <member name="M:unvell.ReoGrid.Chart.LineChartLegend.GetSymbolSize(System.Int32)">
            <summary>
            Get symbol size of chart legend.
            </summary>
            <param name="index">Index of serial in data source.</param>
            <returns>Symbol size of chart legend.</returns>
        </member>
        <member name="T:unvell.ReoGrid.Chart.LineChartPlotView">
            <summary>
            Represents plot view object of line chart component.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Chart.LineChartPlotView.#ctor(unvell.ReoGrid.Chart.AxisChart)">
            <summary>
            Create line chart plot view object.
            </summary>
            <param name="chart">Parent chart component instance.</param>
        </member>
        <member name="M:unvell.ReoGrid.Chart.LineChartPlotView.OnPaint(unvell.ReoGrid.Rendering.DrawingContext)">
            <summary>
            Render plot view of line chart component.
            </summary>
            <param name="dc">Platform no-associated drawing context.</param>
        </member>
        <member name="T:unvell.ReoGrid.Chart.DataPointStyles">
            <summary>
            Data point styles for line plot view.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Chart.DataPointStyles.None">
            <summary>
            None (Default style)
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Chart.DataPointStyles.Triangle">
            <summary>
            Triangle
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Chart.DataPointStyles.Square">
            <summary>
            Square
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Chart.DataPointStyles.EllipseOutline">
            <summary>
            Ellipse Outline
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Chart.DataPointStyles.EllipseFilled">
            <summary>
            Ellipse Filled
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Chart.IDataSerialStyle">
            <summary>
            Represents the interface of data serial style.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Chart.DataSerialStyleCollection">
            <summary>
            Represents a collection of data serial styles.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Chart.DataSerialStyleCollection.Item(System.Int32)">
            <summary>
            Get or set the seiral style for data specified by zero-based index.
            </summary>
            <param name="index">Zero-based index of data to get style.</param>
            <returns>Data serial style object of data.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Chart.ChartTitle.OnPaint(unvell.ReoGrid.Rendering.DrawingContext)">
            <summary>
            Render chart title view.
            </summary>
            <param name="dc">Platform no-associated drawing context instance.</param>
        </member>
        <member name="T:unvell.ReoGrid.Chart.IChart">
            <summary>
            Interface of chart component
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Chart.IChart.Title">
            <summary>
            Get or set the title of chart
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Chart.IChart.DataSource">
            <summary>
            Get or set the data source of chart
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Chart.IChart.DataSerialStyles">
            <summary>
            Determine the style of data serial
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Chart.ChartDrawingEventArgs">
            <summary>
            Event arguments for drawing context in Chart
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Chart.ChartDrawingEventArgs.Chart">
            <summary>
            Get the instance of current chart
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Main.SheetTabMouseEventArgs">
            <summary>
            Mouse event arguments for sheet tab control.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Main.SheetTabMouseEventArgs.MouseButtons">
            <summary>
            Mouse button flags. (Left, Right or Middle)
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Main.SheetTabMouseEventArgs.Location">
            <summary>
            Mouse location related to sheet tab control.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Main.SheetTabMouseEventArgs.Index">
            <summary>
            Number of tab specified by this index to be moved.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Main.SheetTabMouseEventArgs.Handled">
            <summary>
            Get or set whether the user-code handled this event. 
            Built-in operations will be cancelled if this property is set to true.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Main.SheetTabMovedEventArgs">
            <summary>
            Sheet moved event arguments.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Main.SheetTabMovedEventArgs.Index">
            <summary>
            Number of tab specified by this index to be moved.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Main.SheetTabMovedEventArgs.TargetIndex">
            <summary>
            Number of tab as position moved to.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Main.SheetTabBorderStyle">
            <summary>
            Represents the border style of tab item.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Main.SheetTabBorderStyle.RectShadow">
            <summary>
            Sharp Rectangle
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Main.SheetTabBorderStyle.SplitRouned">
            <summary>
            Separated Rounded Rectangle
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Main.SheetTabBorderStyle.NoBorder">
            <summary>
            No Borders (Windows 8 Style)
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Main.SheetTabControlPosition">
            <summary>
            Position of tab control will be located.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Main.SheetTabControlPosition.Top">
            <summary>
            Put at top to other controls.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Main.SheetTabControlPosition.Bottom">
            <summary>
            Put at bottom to other controls.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Main.ISheetTabControl">
            <summary>
            Representes the sheet tab control interface.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Main.ISheetTabControl.SelectedIndex">
            <summary>
            Get or set the current tab index.
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.Main.ISheetTabControl.TabMoved">
            <summary>
            Event raised when tab item is moved.
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.Main.ISheetTabControl.SelectedIndexChanged">
            <summary>
            Event raised when selected tab is changed.
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.Main.ISheetTabControl.SplitterMoving">
            <summary>
            Event raised when splitter is moved.
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.Main.ISheetTabControl.SheetListClick">
            <summary>
            Event raised when sheet list button is clicked.
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.Main.ISheetTabControl.NewSheetClick">
            <summary>
            Event raised when new sheet butotn is clicked.
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.Main.ISheetTabControl.TabMouseDown">
            <summary>
            Event raised when mouse is pressed down on tab items.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Main.ISheetTabControl.ScrollToItem(System.Int32)">
            <summary>
            Scroll view to show tab item by specified index.
            </summary>
            <param name="index">Number of item to scrolled.</param>
        </member>
        <member name="P:unvell.ReoGrid.Main.ISheetTabControl.ControlWidth">
            <summary>
            Get or set the width of sheet tab control
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Main.ISheetTabControl.AddTab(System.String)">
            <summary>
            Add tab.
            </summary>
            <param name="title">Title of tab.</param>
        </member>
        <member name="M:unvell.ReoGrid.Main.ISheetTabControl.InsertTab(System.Int32,System.String)">
            <summary>
            Insert tab
            </summary>
            <param name="index">Zero-based number of tab.</param>
            <param name="title">Title of tab.</param>
        </member>
        <member name="M:unvell.ReoGrid.Main.ISheetTabControl.UpdateTab(System.Int32,System.String)">
            <summary>
            Update tab title.
            </summary>
            <param name="index">Zero-based number of tab.</param>
            <param name="title">Title of tab.</param>
        </member>
        <member name="M:unvell.ReoGrid.Main.ISheetTabControl.RemoveTab(System.Int32)">
            <summary>
            Remove specified tab.
            </summary>
            <param name="index">Zero-based number of tab.</param>
        </member>
        <member name="M:unvell.ReoGrid.Main.ISheetTabControl.ClearTabs">
            <summary>
            Clear all tabs.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Main.ISheetTabControl.AllowDragToMove">
            <summary>
            Determine whether or not allow to move tab by dragging mouse.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Main.ISheetTabControl.NewButtonVisible">
            <summary>
            Determine whether or not to show new sheet button.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Core.ISheetAddress">
            <summary>
            Absolute address interface reference to a cell or range on spreadsheet
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Core.ISheetAddress.ToAddress">
            <summary>
            Convert into address identifier.
            </summary>
            <returns>Address identifier in string.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Core.ISheetAddress.ToRelativeAddress">
            <summary>
            Convert into relative address identifier.
            </summary>
            <returns>Address identifier in string.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Core.ISheetAddress.ToAbsoluteAddress">
            <summary>
            Convert into absolute address identifier.
            </summary>
            <returns>Address identifier in string.</returns>
        </member>
        <member name="T:unvell.ReoGrid.Core.IRowRange">
            <summary>
            Interface that represents a range of row on worksheet.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Core.IRowRange.Row">
            <summary>
            Get or set the number of row.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Core.IRowRange.Rows">
            <summary>
            Get or set the number of rows in this range.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Core.IRowRange.EndRow">
            <summary>
            Get the number of last row in this range
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Core.IColumnRange">
            <summary>
            Interface to represents a range of column on worksheet.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Core.IColumnRange.Col">
            <summary>
            Get or set the number of col.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Core.IColumnRange.Cols">
            <summary>
            Get or set the number of rows in this range.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Core.IColumnRange.EndCol">
            <summary>
            Get the number of last column in this range.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Core.IRange">
            <summary>
            Interface that represents a range location on worksheet. (Combine from IRowRange and IColumnRange)
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Core.ReoGridRenderHorAlign">
            <summary>
            Cell horizontal alignment for render. (cell-auto-format)
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:unvell.ReoGrid.Cell" -->
        <member name="P:unvell.ReoGrid.Cell.IsMergedCell">
            <summary>
            Check whether this cell is merged cell
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Cell.IsValidCell">
            <summary>
            Check whether or not this cell is an valid cell, only valid cells can be set data and styles.
            Cells merged by another cell will become invalid.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Cell.InsideMergedRange">
            <summary>
            Check whether or not this cell is inside a merged range
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Cell.TextBounds">
            <summary>
            text boundary for display
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Cell.RenderHorAlign">
            <summary>
            Horizontal alignement for display
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Cell.RenderTextColumnSpan">
            <summary>
            Column span if text larger than the cell it inside
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Cell.RenderColor">
            <summary>
            Get the render color of cell text. Render color is the final color that used to render the text on the worksheet.
            Whatever cell style with text color is specified, negative numbers may displayed as red.
            This property cannot be changed directly. 
            To change text color, set cell style with text color by call SetRangeStyles method, or change the Cell.Style.TextColor property.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Cell.worksheet">
            <summary>
            Instance of worksheet that the cell belongs to
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Cell.Worksheet">
            <summary>
            Get the worksheet that is the owner of this cell
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Cell.#ctor(unvell.ReoGrid.Worksheet)">
            <summary>
            Construct cell instance with specified owner grid instance.
            Cell instance managed by ReoGrid core, it cannot be created by user-code.
            </summary>
            <param name="worksheet">Owner grid control for this cell</param>
        </member>
        <member name="P:unvell.ReoGrid.Cell.Row">
            <summary>
            Get zero-based row index of this cell
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Cell.Column">
            <summary>
            Get zero-based column index of this cell
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Cell.Position">
            <summary>
            Get position of this cell.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Cell.PositionAsRange">
            <summary>
            Get position as a range position which contains the cell rowspan and colspan.
            This property is useful when the cell is a merged cell.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Cell.Address">
            <summary>
            Get address string of this cell
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Cell.GetColspan">
            <summary>
            Get number of colspan
            </summary>
            <returns></returns>
        </member>
        <member name="M:unvell.ReoGrid.Cell.GetRowspan">
            <summary>
            Get number of rowspan
            </summary>
            <returns></returns>
        </member>
        <member name="P:unvell.ReoGrid.Cell.DataFormat">
            <summary>
            Get or set the data format type
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Cell.DataFormatArgs">
            <summary>
            Get or set the argument of data format type
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Cell.InnerData">
            <summary>
            cell data
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Cell.Data">
            <summary>
            Get or set cell data
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Cell.GetData``1">
            <summary>
            Get and convert data into specified type
            </summary>
            <typeparam name="T">Type try to convert</typeparam>
            <returns>Converted data in specified type</returns>
        </member>
        <member name="P:unvell.ReoGrid.Cell.InnerFormula">
            <summary>
            cell formula
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Cell.FormulaStatus">
            <summary>
            Determine the status of formula calculation
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Cell.InnerDisplay">
            <summary>
            cell display text.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Cell.DisplayText">
            <summary>
            Get the text displayed in cell. Set <code>Data</code> property to change this text.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Cell.IsReadOnly">
            <summary>
            Determine whether or not allow to change data of this cell.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Cell.StartEdit">
            <summary>
            Start edit this cell.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Cell.EndEdit">
            <summary>
            Finish edit this cell.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Cell.ExpandRowHeight">
            <summary>
            Expand or shrink row height to fit the display text in this cell.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Cell.ExpandColumnWidth">
            <summary>
            Expand or shrink column width to fit the display text in this cell.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Cell.Formula">
            <summary>
            Get or set the cell formula
            </summary>
            <returns>Formula of cell in string</returns>
        </member>
        <member name="P:unvell.ReoGrid.Cell.HasFormula">
            <summary>
            Identify whether or not this cell contains the formula and the value has been evaluated
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Cell.Style">
            <summary>
            Get or set style object of cell.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Cell.IsVisible">
            <summary>
            Checks whether or not this cell is visible. (Cells on hidden rows or columns will become invisibility)
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Cell.IsHidden">
            <summary>
            Determines whether or not this cell is visible. (Cells on hidden rows or columns will become invisibility)
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Cell.Border">
            <summary>
            Get border property from cell.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Cell.Tag">
            <summary>
            Get or set the user data attaching to this cell.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Cell.Body">
            <summary>
            Get or set the cell body.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Cell.Clone">
            <summary>
            Clone this cell instance by copying its all of properties
            </summary>
            <returns>new cell instance copied from this cell</returns>
        </member>
        <member name="P:unvell.ReoGrid.Cell.TraceFormulaPrecedents">
            <summary>
            Show or hide trace formula percendents on spreadsheet.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Cell.TraceFormulaDependents">
            <summary>
            Show or hide trace formula dependents on spreadsheet.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Worksheet">
            <summary>
            ReoGrid worksheet object, manage the single spreadsheet data and styles.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.LoadCSV(System.String)">
            <summary>
            Load CSV file into worksheet.
            </summary>
            <param name="path">File contains CSV data.</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.LoadCSV(System.String,unvell.ReoGrid.RangePosition)">
            <summary>
            Load CSV file into worksheet.
            </summary>
            <param name="path">File contains CSV data.</param>
            <param name="targetRange">The range used to fill loaded CSV data.</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.LoadCSV(System.String,System.Text.Encoding)">
            <summary>
            Load CSV file into worksheet.
            </summary>
            <param name="path">Path to load CSV file.</param>
            <param name="encoding">Encoding used to read and decode plain-text from file.</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.LoadCSV(System.String,System.Text.Encoding,unvell.ReoGrid.RangePosition)">
            <summary>
            Load CSV file into worksheet.
            </summary>
            <param name="path">Path to load CSV file.</param>
            <param name="encoding">Encoding used to read and decode plain-text from file.</param>
            <param name="targetRange">The range used to fill loaded CSV data.</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.LoadCSV(System.IO.Stream)">
            <summary>
            Load CSV data from stream into worksheet.
            </summary>
            <param name="s">Input stream to read CSV data.</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.LoadCSV(System.IO.Stream,unvell.ReoGrid.RangePosition)">
            <summary>
            Load CSV data from stream into worksheet.
            </summary>
            <param name="s">Input stream to read CSV data.</param>
            <param name="targetRange">The range used to fill loaded CSV data.</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.LoadCSV(System.IO.Stream,System.Text.Encoding)">
            <summary>
            Load CSV data from stream into worksheet.
            </summary>
            <param name="s">Input stream to read CSV data.</param>
            <param name="encoding">Text encoding used to read and decode plain-text from stream.</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.LoadCSV(System.IO.Stream,System.Text.Encoding,unvell.ReoGrid.RangePosition)">
            <summary>
            Load CSV data from stream into worksheet.
            </summary>
            <param name="s">Input stream to read CSV data.</param>
            <param name="encoding">Text encoding used to read and decode plain-text from stream.</param>
            <param name="targetRange">The range used to fill loaded CSV data.</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.LoadCSV(System.IO.Stream,System.Text.Encoding,unvell.ReoGrid.RangePosition,System.Boolean,System.Int32)">
            <summary>
            Load CSV data from stream into worksheet.
            </summary>
            <param name="s">Input stream to read CSV data.</param>
            <param name="encoding">Text encoding used to read and decode plain-text from stream.</param>
            <param name="targetRange">The range used to fill loaded CSV data.</param>
            <param name="autoSpread">decide whether or not to append rows or columns automatically to fill csv data</param>
            <param name="bufferLines">decide how many lines int the buffer to read and fill csv data</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.ExportAsCSV(System.String,System.Int32,System.Text.Encoding)">
            <summary>
            Export spreadsheet as CSV format from specified number of rows.
            </summary>
            <param name="path">File path to write CSV format as stream.</param>
            <param name="startRow">Number of rows start to export data, 
            this property is useful to skip the headers on top of worksheet.</param>
            <param name="encoding">Text encoding during output text in CSV format.</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.ExportAsCSV(System.String,System.String,System.Text.Encoding)">
            <summary>
            Export spreadsheet as CSV format from specified range.
            </summary>
            <param name="path">File path to write CSV format as stream.</param>
            <param name="addressOrName">Range to be output from this worksheet, specified by address or name.</param>
            <param name="encoding">Text encoding during output text in CSV format.</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.ExportAsCSV(System.String,unvell.ReoGrid.RangePosition,System.Text.Encoding)">
            <summary>
            Export spreadsheet as CSV format from specified range.
            </summary>
            <param name="path">File path to write CSV format as stream.</param>
            <param name="range">Range to be output from this worksheet.</param>
            <param name="encoding">Text encoding during output text in CSV format.</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.ExportAsCSV(System.IO.Stream,System.Int32,System.Text.Encoding)">
            <summary>
            Export spreadsheet as CSV format from specified number of rows.
            </summary>
            <param name="s">Stream to write CSV format as stream.</param>
            <param name="startRow">Number of rows start to export data, 
            this property is useful to skip the headers on top of worksheet.</param>
            <param name="encoding">Text encoding during output text in CSV format</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.ExportAsCSV(System.IO.Stream,System.String,System.Text.Encoding)">
            <summary>
            Export spreadsheet as CSV format from specified range.
            </summary>
            <param name="s">Stream to write CSV format as stream.</param>
            <param name="addressOrName">Range to be output from this worksheet, specified by address or name.</param>
            <param name="encoding">Text encoding during output text in CSV format.</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.ExportAsCSV(System.IO.Stream,unvell.ReoGrid.RangePosition,System.Text.Encoding)">
            <summary>
            Export spreadsheet as CSV format from specified range.
            </summary>
            <param name="s">Stream to write CSV format as stream.</param>
            <param name="range">Range to be output from this worksheet.</param>
            <param name="encoding">Text encoding during output text in CSV format.</param>
        </member>
        <member name="P:unvell.ReoGrid.Worksheet.FloatingObjects">
            <summary>
            Access the collection of floating objects from worksheet.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.CreateColumnFilter(System.String,System.String,System.Int32,unvell.ReoGrid.Data.AutoColumnFilterUI)">
            <summary>
            Create column filter.
            </summary>
            <param name="startColumn">First column specified by an address to create filter.</param>
            <param name="endColumn">Last column specified by an address to the filter.</param>
            <param name="titleRows">Indicates that how many title rows exist at the top of spreadsheet,
            title rows will not be included in filter apply range.</param>
            <param name="columnFilterUI">Indicates whether allow to create graphics user interface (GUI), 
            by default the dropdown-button on the column and candidates dropdown-panel will be created.
            Set this argument as NoGUI to create filter without GUI.</param>
            <returns>Instance of column filter.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.CreateColumnFilter(System.Int32,System.Int32,unvell.ReoGrid.Data.AutoColumnFilterUI)">
            <summary>
            Create column filter.
            </summary>
            <param name="column">Column to create filter.</param>
            <param name="titleRows">indicates that how many title rows exist at the top of spreadsheet,
            title rows will not be included in filter apply range.</param>
            <param name="columnFilterUI">Indicates whether allow to create graphics user interface (GUI), 
            by default the dropdown-button on the column and candidates dropdown-panel will be created.
            Set this argument as NoGUI to create filter without GUI.</param>
            <returns>Instance of column filter.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.CreateColumnFilter(System.Int32,System.Int32,System.Int32,unvell.ReoGrid.Data.AutoColumnFilterUI)">
            <summary>
            Create column filter.
            </summary>
            <param name="startColumn">first column specified by a zero-based number of column to create filter</param>
            <param name="endColumn">last column specified by a zero-based number of column to create filter</param>
            <param name="titleRows">indicates that how many title rows exist at the top of spreadsheet,
            title rows will not be included in filter apply range.</param>
            <param name="columnFilterUI">Indicates whether or not to show GUI for filter, 
            by default the drop-down button displayed on column header and a candidates list popuped up when dropdown-panel opened.
            Set this argument as NoGUI to create filter without GUI.</param>
            <returns>Instance of column filter.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.CreateColumnFilter(unvell.ReoGrid.RangePosition,unvell.ReoGrid.Data.AutoColumnFilterUI)">
            <summary>
            Create automatic column filter and display on specified headers of worksheet.
            </summary>
            <param name="range">Range to filter data.</param>
            <param name="columnFilterUI">Indicates whether or not to show GUI for filter, 
            by default the drop-down button displayed on column header and a candidates list popuped up when dropdown-panel opened.
            Set this argument as NoGUI to create filter without GUI.</param>
            <returns>Instance of column filter.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.DoFilter(unvell.ReoGrid.RangePosition,System.Func{System.Int32,System.Boolean})">
            <summary>
            Do a filter on specified rows. Determines whether or not to show or hide a row.
            </summary>
            <param name="startRow">Number of row start to check.</param>
            <param name="rows">Number of rows to be checked.</param>
            <param name="filter">A callback filter function to check specified row from worksheet.</param>
        </member>
        <member name="E:unvell.ReoGrid.Worksheet.RowsFiltered">
            <summary>
            Event raised when rows filtered on this worksheet.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.SortColumn(System.String,unvell.ReoGrid.SortOrder,unvell.ReoGrid.CellElementFlag,System.Func{System.Int32,System.Int32,System.Object,System.Object,System.Int32})">
            <summary>
            Sort data on specified column.
            </summary>
            <param name="columnAddress">Base column specified by an address to sort data.</param>
            <param name="order">Order of data sort.</param>
            <param name="cellDataComparer">Custom cell data comparer, compares two cells and returns an integer. 
            Set this value to null to use default built-in comparer.</param>
            <returns>Data changed range</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.SortColumn(System.Int32,unvell.ReoGrid.SortOrder,unvell.ReoGrid.CellElementFlag,System.Func{System.Int32,System.Int32,System.Object,System.Object,System.Int32})">
            <summary>
            Sort data on specified column.
            </summary>
            <param name="columnIndex">Zero-based number of column to sort data.</param>
            <param name="order">Order of data sort.</param>
            <param name="cellDataComparer">custom cell data comparer, compares two cells and returns an integer. 
            Set this value to null to use default built-in comparer.</param>
            <returns>Data changed range</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.SortColumn(System.Int32,System.Int32,unvell.ReoGrid.SortOrder,unvell.ReoGrid.CellElementFlag,System.Func{System.Int32,System.Int32,System.Object,System.Object,System.Int32})">
            <summary>
            Sort data on specified column.
            </summary>
            <param name="columnIndex">Zero-based number of column to sort data</param>
            <param name="titleRows">Indicates that how many title rows exist at the top of worksheet, 
            Title rows will not be included in sort apply range.</param>
            <param name="order">Order of data sort.</param>
            <param name="cellDataComparer">Custom cell data comparer, compares two cells and returns an integer.  
            Set this value to null to use default built-in comparer.</param>
            <returns>Data changed range.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.SortColumn(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,unvell.ReoGrid.SortOrder,unvell.ReoGrid.CellElementFlag,System.Func{System.Int32,System.Int32,System.Object,System.Object,System.Int32})">
            <summary>
            Sort data on specified column.
            </summary>
            <param name="columnIndex">Zero-based number of column to sort data.</param>
            <param name="startRow">First number of row to allow sort data.</param>
            <param name="endRow">Last number of number of row to allow sort data.</param>
            <param name="startColumn">First number of column to allow sort data.</param>
            <param name="endColumn">Last number of column to allow sort data.</param>
            <param name="order">Order of data sort.</param>
            <param name="cellDataComparer">Custom cell data comparer, compares two cells and returns an integer. 
            Set this value to null to use default built-in comparer.</param>
            <returns>Data changed range.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.SortColumn(System.Int32,System.String,unvell.ReoGrid.SortOrder,unvell.ReoGrid.CellElementFlag,System.Func{System.Int32,System.Int32,System.Object,System.Object,System.Int32})">
            <summary>
            Sort data inside specified range.
            </summary>
            <param name="columnIndex">Data will be sorted based on this column.</param>
            <param name="applyRange">Affect range.</param>
            <param name="order">Order of data sort.</param>
            <param name="cellDataComparer"></param>
            <returns></returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.SortColumn(System.Int32,unvell.ReoGrid.RangePosition,unvell.ReoGrid.SortOrder,unvell.ReoGrid.CellElementFlag,System.Func{System.Int32,System.Int32,System.Object,System.Object,System.Int32})">
            <summary>
            Sort data on specified column.
            </summary>
            <param name="columnIndex">Zero-based number of column to sort data.</param>
            <param name="applyRange">Data only be changed in this range during sort.</param>
            <param name="order">Order of data sort.</param>
            <param name="cellDataComparer">Custom cell data comparer, compares two cells and returns an integer. 
            Set this value to null to use default built-in comparer.</param>
            <returns>Data changed range.</returns>
        </member>
        <member name="E:unvell.ReoGrid.Worksheet.RowsSorted">
            <summary>
            Event raised when rows sorted on this worksheet.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Worksheet.FocusHighlightRange">
            <summary>
            Get or set the focus highlight range
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Worksheet.HighlightRanges">
            <summary>
            Collection of highlighted ranges
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.StartCreateHighlightRange">
            <summary>
            Start pick and create a highlight range on spreadsheet.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.CreateHighlightRange(System.String)">
            <summary>
            Create highlight range from specified range position.
            </summary>
            <param name="address">Address or name to locate the range on worksheet.</param>
            <returns>Instance of highlight range created on the worksheet.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.CreateHighlightRange(System.String,unvell.ReoGrid.Graphics.SolidColor)">
            <summary>
            Create highlight range at specified position
            </summary>
            <param name="addressOrName">Address or name to locate a range on worksheet</param>
            <param name="color">Color of the hihglight range displayed on worksheet</param>
            <returns>Instace of highlight range created in this worksheet</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.CreateHighlightRange(unvell.ReoGrid.RangePosition,unvell.ReoGrid.Graphics.SolidColor)">
            <summary>
            Create highlight range at specified position
            </summary>
            <param name="range">Range on worksheet to be highlight</param>
            <param name="color">Color of the hihglight range displayed on worksheet</param>
            <returns>Instace of highlight range created in this worksheet</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.AddHighlightRange(System.String)">
            <summary>
            Crearte and display a highlighted range at specified position on worksheet
            </summary>
            <param name="address">Address or name to locate a range on worksheet</param>
            <returns>Instance of highlight range on worksheet</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.AddHighlightRange(unvell.ReoGrid.RangePosition)">
            <summary>
            Crearte and display a highlighted range at specified position on worksheet
            </summary>
            <param name="range">Position to add highlighted range</param>
            <returns>Instance of highlight range on worksheet</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.RemoveHighlightRange(System.String)">
            <summary>
            Remove a highlighted range from specified address
            </summary>
            <param name="address">address to remove highlighted range</param>
            <returns>true if range removed successfully</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.RemoveHighlightRange(unvell.ReoGrid.RangePosition)">
            <summary>
            Remove a highlighted range from specified position
            </summary>
            <param name="range">position to remove highlighted range</param>
            <returns>true if range removed successfully</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.RemoveAllHighlightRanges">
            <summary>
            Remove all highlighted ranges from current spreadsheet
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.HasHighlightRange(unvell.ReoGrid.RangePosition)">
            <summary>
            Check whether a range specified by position is added into current spreadsheet
            </summary>
            <param name="range">range to be checked</param>
            <returns>true if specified range is alreay added</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.TimerRun">
            <summary>
            Threading to update frames of focus highlighted range
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Worksheet.HighlightRangeCollection">
            <summary>
            Collection of highlighted range
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.MergeRange(System.String)">
            <summary>
            Merge a range by specified address or name
            </summary>
            <param name="addressOrName">address or name to locate a range, if a name of range is specified, 
            the name must be defined by DefineNamedRange first.</param>
            <exception cref="T:unvell.ReoGrid.NamedRangeNotFoundException">throw when the specified name of range cannot be found.</exception>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.MergeRange(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Merge specified range into single cell
            </summary>
            <param name="row">number of start row</param>
            <param name="col">number of start column</param>
            <param name="rows">number of rows to be merged</param>
            <param name="cols">number of columns to be merged</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.MergeRange(unvell.ReoGrid.RangePosition)">
            <summary>
            Merge specified range into single cell
            </summary>
            <exception cref="T:unvell.ReoGrid.RangeTooSmallException">thrown when specified range has only one cell.</exception>
            <exception cref="T:unvell.ReoGrid.RangeIntersectionException">thrown when specified range intersectes with another one. </exception>
            <param name="range">Range to be merged</param>
            <seealso cref="M:unvell.ReoGrid.Worksheet.UnmergeRange(System.Int32,System.Int32,System.Int32,System.Int32)"/>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.UnmergeRange(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Unmerge specified range.
            </summary>
            <param name="row">Number of row of range to be unmerged.</param>
            <param name="col">Number of column of range to be unmerged.</param>
            <param name="rows">Number of rows in the range to be unmerged.</param>
            <param name="cols">Number of columns in the range to be unmerged.</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.UnmergeRange(unvell.ReoGrid.RangePosition)">
            <summary>
            Unmerge all cells contained in the specified range.
            </summary>
            <seealso cref="M:unvell.ReoGrid.Worksheet.MergeRange(System.String)"/>
            <param name="range">Range to be checked and all cells in this range will be unmerged.</param>
        </member>
        <member name="E:unvell.ReoGrid.Worksheet.RangeMerged">
            <summary>
            Event raised when range merged
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.Worksheet.RangeUnmerged">
            <summary>
            Event raised when range unmerged
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.CheckIntersectedMergingRange(unvell.ReoGrid.RangePosition)">
            <summary>
            Check are there any merged range exist in specified range
            </summary>
            <param name="range">range to be checked</param>
            <returns>the intersected range with specified range</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.HasIntersectedMergingRange(unvell.ReoGrid.RangePosition)">
            <summary>
            Check are there any merged range exist in specified range
            </summary>
            <param name="range">range to be checked</param>
            <returns>true if specified range can be merged</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.CheckMergedRange(unvell.ReoGrid.RangePosition)">
            <summary>
            Check whether a  range intersects with others merged range, return the most outside range which contains all these intersected range.
            </summary>
            <param name="range">Range to be checked.</param>
            <returns>Most outside range that contains all intersected range.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.RangeIsMergedCell(unvell.ReoGrid.RangePosition)">
            <summary>
            Check whether or not specified range contains only one cell, merged cell is treated as one cell.
            </summary>
            <param name="range">Range to be checked</param>
            <returns>True if the range contains only one cell or one merged cell; otherwise return false.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.AddNamedRange(unvell.ReoGrid.NamedRange)">
            <summary>
            Add a named range into current spreadsheet.
            </summary>
            <param name="namedRange">Named range to be added.</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.DefineNamedRange(System.String,System.String)">
            <summary>
            Define named range from an address.
            </summary>
            <param name="name">Name to identify a range in spreadsheet.</param>
            <param name="address">Address reference to a range.</param>
            <returns>Instance of named range added into spreadsheet</returns>
            <exception cref="T:unvell.ReoGrid.InvalidAddressException">throw if specified address or name is illegal</exception>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.DefineNamedRange(System.String,System.String,unvell.ReoGrid.NamedRangeScope)">
            <summary>
            Define named range from an address.
            </summary>
            <param name="name">Name to identify a range in spreadsheet</param>
            <param name="address">Address reference to a range</param>
            <param name="scope">The valid scope of this named range</param>
            <returns>Instance of named range added into spreadsheet</returns>
            <exception cref="T:unvell.ReoGrid.InvalidAddressException">throw if specified address or name is illegal</exception>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.DefineNamedRange(System.String,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Define named range to specify region
            </summary>
            <param name="name">name to be defined to the range</param>
            <param name="row">number of row start to the range</param>
            <param name="col">number of column start to the range</param>
            <param name="rows">number of rows contained in the range</param>
            <param name="cols">number of columns contained in the range</param>
            <returns>Instance of named range</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.DefineNamedRange(System.String,System.Int32,System.Int32,System.Int32,System.Int32,unvell.ReoGrid.NamedRangeScope)">
            <summary>
            Define named range to specify region
            </summary>
            <param name="name">name to be defined to the range</param>
            <param name="row">number of row start to the range</param>
            <param name="col">number of column start to the range</param>
            <param name="rows">number of rows contained in the range</param>
            <param name="cols">number of columns contained in the range</param>
            <param name="scope">The valid scope of this named range</param>
            <returns>Instance of named range</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.DefineNamedRange(System.String,unvell.ReoGrid.RangePosition,unvell.ReoGrid.NamedRangeScope)">
            <summary>
            Define named range registered into spreadsheet
            </summary>
            <param name="name">Name to identify a range in spreadsheet</param>
            <param name="range">Range to be added into spreadsheet</param>
            <param name="scope">The valid scope of this named range</param>
            <returns>Instance of named range added into spreadsheet</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.GetNamedRange(System.String)">
            <summary>
            Get named range which registered in current sheet
            </summary>
            <param name="name">string to name a range</param>
            <returns>referenced range of specified name</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.TryGetNamedRange(System.String,unvell.ReoGrid.NamedRange@)">
            <summary>
            Try get a named range by specified name
            </summary>
            <param name="name">name for range to be get</param>
            <param name="namedRange">output argument, range assoicated with specified name will be returned</param>
            <returns>true if specified name exists and the instance of range has been returned from spreadsheet, otherwise false</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.TryGetRangeByAddressOrName(System.String,unvell.ReoGrid.RangePosition@)">
            <summary>
            Try get range by specified address or range name.
            </summary>
            <param name="addressOrName">Address or range name used to find range on worksheet.</param>
            <param name="range">Range that was found by specified address or name on worksheet.</param>
            <returns>True if range was found; Otherwise return false.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.GetAllNamedRanges">
            <summary>
            Get all named range that has been registered in current spreadsheet
            </summary>
            <returns>list of name for all named ranges registered in this</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.GetNameByRange(System.String)">
            <summary>
            Find name by specified address of range
            </summary>
            <param name="address">an address used to locate the range</param>
            <returns>name to target range, and null if not found</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.GetNameByRange(unvell.ReoGrid.RangePosition)">
            <summary>
            Find name for a named range by its location
            </summary>
            <param name="range">a range location used to search the name</param>
            <returns>name as string for the range, return null if no range was found</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.RemoveNamedRange(System.String)">
            <summary>
            Remove named range from current worksheet
            </summary>
            <param name="name">Name of range</param>
            <returns>true if the range was found and removed by specified name</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.UndefineNamedRange(System.String)">
            <summary>
            Undefine named range from this worksheet
            </summary>
            <param name="name">Name of range</param>
            <returns>true if the range was found and removed by specified name</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.RenameNamedRange(System.String,System.String)">
            <summary>
            Rename a named range to another name
            </summary>
            <param name="oldName">Old name used to find range to be renamed</param>
            <param name="newName">New name to set to the range</param>
            <returns>true if range could be found by old name, and renamed to new name successfully</returns>
        </member>
        <member name="P:unvell.ReoGrid.Worksheet.NamedRanges">
            <summary>
            Get collection of named range.
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.Worksheet.NamedRangeDefined">
            <summary>
            Event raised when named range is defined
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.Worksheet.NamedRangeUndefined">
            <summary>
            Event raised when named range is undefined
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.SuspendUIUpdates">
            <summary>
            Suspend worksheet UI updates.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.ResumeUIUpdates">
            <summary>
            Resume worksheet UI updates.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Worksheet.IsUIUpdatesSuspending">
            <summary>
            Check whether UI updates is suspending.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Worksheet.ViewportController">
            <summary>
            Get or set viewport controller for worksheet.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.RequestInvalidate">
            <summary>
            Request to repaint entire worksheet.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.InvalidateSheet">
            <summary>
            Force to repaint the canvas region of control
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Worksheet.ViewMode">
            <summary>
            Get or set view mode of current worksheet (Reserved)
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.StartEdit">
            <summary>
            Start to edit selected cell
            </summary>
            <returns>True if the editing operation has been started</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.StartEdit(System.String)">
            <summary>
            Start to edit selected cell
            </summary>
            <returns>True if the editing operation has been started</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.StartEdit(unvell.ReoGrid.CellPosition)">
            <summary>
            Start to edit specified cell
            </summary>
            <param name="pos">Position of specified cell</param>
            <returns>True if the editing operation has been started</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.StartEdit(unvell.ReoGrid.CellPosition,System.String)">
            <summary>
            Start to edit specified cell
            </summary>
            <param name="pos">Position of specified cell</param>
            <param name="newText">A text will be displayed in the edit field initially.</param>
            <returns>True if the editing operation has been started</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.StartEdit(System.Int32,System.Int32)">
            <summary>
            Start to edit specified cell
            </summary>
            <param name="row">Index of row of specified cell</param>
            <param name="col">Index of column of specified cell</param>
            <returns>True if the editing operation has been started</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.StartEdit(System.Int32,System.Int32,System.String)">
            <summary>
            Start to edit specified cell.
            </summary>
            <param name="row">Index of row of specified cell.</param>
            <param name="col">Index of column of specified cell.</param>
            <param name="newText">A text displayed in the text field to be edited.</param>
            <returns>True if worksheet entered edit-mode successfully; Otherwise return false.</returns>
        </member>
        <member name="P:unvell.ReoGrid.Worksheet.IsEditing">
            <summary>
            Check whether any cell current in edit mode
            </summary>
            <returns>true if any cell is editing</returns>
        </member>
        <member name="P:unvell.ReoGrid.Worksheet.EditingCell">
            <summary>
            Get instance of current editing cell.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.GetEditingCell">
            <summary>
            Get position of cell that currently is in edit mode
            </summary>
            <returns>position of cell which is editing</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.EndEdit(unvell.ReoGrid.EndEditReason)">
            <summary>
            Force end current editing operation with the specified reason.
            </summary>
            <param name="reason">Ending Reason of editing operation</param>
            <returns>True if currently in editing mode, and operation has been
            finished successfully.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.EndEdit(System.Object)">
            <summary>
            Force end current editing operation.
            Uses specified data instead of the data of user edited.
            </summary>
            <param name="data">New data to be set to the edited cell</param>
            <returns>True if currently in editing mode, and operation has been
            finished successfully.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.EndEdit(System.Object,unvell.ReoGrid.EndEditReason)">
            <summary>
            Force end current editing operation with the specified reason.
            Uses specified data instead of the data of user edited.
            </summary>
            <param name="data">New data to be set to the edited cell</param>
            <param name="reason">Ending Reason of editing operation</param>
            <returns>True if currently in editing mode, and operation has been
            finished successfully.</returns>
        </member>
        <member name="E:unvell.ReoGrid.Worksheet.BeforeCellEdit">
            <summary>
            Event raised before cell changed to edit mode
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.Worksheet.AfterCellEdit">
            <summary>
            Event raised after cell changed to edit mode
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.Worksheet.CellEditTextChanging">
            <summary>
            Event raised after input text changing
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.Worksheet.CellEditCharInputed">
            <summary>
            Event raised after any characters is input
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Worksheet.CellEditText">
            <summary>
            Get or set the current text in edit textbox of cell
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.Reset">
            <summary>
            Reset control to default status.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.Reset(System.Int32,System.Int32)">
            <summary>
            Reset control and initialize to specified size
            </summary>
            <param name="rows">number of rows to be set after resting</param>
            <param name="cols">number of columns to be set after reseting</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.GetRangePhysicsBounds(unvell.ReoGrid.RangePosition)">
            <summary>
            Get physics rectangle bounds from specified range position.
            Be careful that this is different from the rectangle bounds displayed on screen,
            the actual bound positions displayed on screen are transformed and scaled 
            in order to scroll, zoom and freeze into different viewports.
            </summary>
            <param name="range">The range position to get bounds</param>
            <returns>Rectangle bounds from specified range position</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.GetCellPhysicsPosition(System.Int32,System.Int32)">
            <summary>
            Get physics position from specified cell position.
            Be careful that this is different from the rectangle bounds displayed on screen,
            the actual bound positions displayed on the screen are transformed and scaled 
            in order to scroll, zoom and freeze into different viewports.
            </summary>
            <param name="row">Zero-based index of row</param>
            <param name="col">Zero-based index of column</param>
            <returns>Point position of specified cell position in pixel.</returns>
        </member>
        <member name="F:unvell.ReoGrid.Worksheet.focusReturnColumn">
            <summary>
            The column focus pos goes when enter key pressed.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Worksheet.FocusPos">
            <summary>
            Get or set current focused cell position.
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.Worksheet.FocusPosChanged">
            <summary>
            Raise when focus cell is changed
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Worksheet.FocusPosStyle">
            <summary>
            Get or set focus position display style
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.Worksheet.FocusPosStyleChanged">
            <summary>
            Focus position style changed.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Worksheet.HoverPos">
            <summary>
            Cell when mouse moving and hover on
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.Worksheet.HoverPosChanged">
            <summary>
            Raise when hover cell is changed
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Worksheet.SelectionRange">
            <summary>
            Current selection range of entire grid. If SelectionMode is None, the value of this property will be Empty.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Worksheet.SelectionMode">
            <summary>
            Get or set selection mode for worksheet.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Worksheet.SelectionStyle">
            <summary>
            Get or set the selection style for worksheet.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Worksheet.SelectionForwardDirection">
            <summary>
            Get or set focus cell moving direction.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.FixRangeSelection(unvell.ReoGrid.RangePosition)">
            <summary>
            Select specified range.
            </summary>
            <param name="range">Specified range to be selected</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.SelectRange(System.String)">
            <summary>
            Select speicifed range on spreadsheet
            </summary>
            <param name="address">address or name of specified range to be selected</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.SelectRange(unvell.ReoGrid.CellPosition,unvell.ReoGrid.CellPosition)">
            <summary>
            Select speicifed range on spreadsheet
            </summary>
            <param name="pos1">Start position of specified range</param>
            <param name="pos2">End position of specified range</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.SelectRange(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Select specified range
            </summary>
            <param name="row">number of row</param>
            <param name="col">number of col</param>
            <param name="rows">number of rows to be selected</param>
            <param name="cols">number of columns to be selected</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.SelectRange(unvell.ReoGrid.RangePosition)">
            <summary>
            Select speicifed range on spreadsheet
            </summary>
            <param name="range">range to be selected</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.SelectAll">
            <summary>
            Select entire sheet
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.SelectColumns(System.Int32,System.Int32)">
            <summary>
            Select entire rows of columns form specified column
            </summary>
            <param name="col">number of column start to be selected</param>
            <param name="columns">numbers of column to be selected</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.SelectRows(System.Int32,System.Int32)">
            <summary>
            Select entire column of rows from specified row
            </summary>
            <param name="row">number of row start to be selected</param>
            <param name="rows">numbers of row to be selected</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.MoveFocusRight(System.Boolean)">
            <summary>
            Move focus position rightward.
            </summary>
            <param name="autoReturn">Determines whether or not move to next column if reached end row.</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.MoveFocusDown(System.Boolean)">
            <summary>
            Move focus position downward.
            </summary>
            <param name="autoReturn">Determines whether or not move to next row if reached end column.</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.MoveSelectionForward">
            <summary>
            Move forward selection
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.MoveSelectionBackward">
            <summary>
            Move backward selection
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.MoveSelectionUp(System.Boolean)">
            <summary>
            Upward to move focus selection
            </summary>
            <param name="appendSelect">Decide whether or not perform an appending select (same as Shift key press down)</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.MoveSelectionDown(System.Boolean)">
            <summary>
            Downward to move focus selection
            </summary>
            <param name="appendSelect">Decide whether or not perform an appending select (same as Shift key press down)</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.MoveSelectionLeft(System.Boolean)">
            <summary>
            Leftward to move focus selection
            </summary>
            <param name="appendSelect">Decide whether or not perform an appending select (same as Shift key press down)</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.MoveSelectionRight(System.Boolean)">
            <summary>
            Rightward to move focus selection
            </summary>
            <param name="appendSelect">Decide whether or not perform an appending select (same as Shift key press down)</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.MoveSelectionHome(unvell.ReoGrid.RowOrColumn,System.Boolean)">
            <summary>
            Move selection to first cell of row or column which is specified by <code>rowOrColumn</code>
            </summary>
            <param name="rowOrColumn">specifies that move selection to first cell of row or column</param>
            <param name="appendSelect">Decide whether or not perform an appending select (same as Shift key press down)</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.MoveSelectionEnd(unvell.ReoGrid.RowOrColumn,System.Boolean)">
            <summary>
            Move selection to last cell of row or column which is specified by <code>rowOrColumn</code>
            </summary>
            <param name="rowOrColumn">specifies that move selection to the cell of row or column</param>
            <param name="appendSelect">Determines that whether or not to expand the current selection.</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.MoveSelectionPageDown(System.Boolean)">
            <summary>
            Move selection to cell in next page vertically.
            </summary>
            <param name="appendSelect">When this value is true, the selection will be expanded to the cell in next page rather than moving it.</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.MoveSelectionPageUp(System.Boolean)">
            <summary>
            Move selection to cell in previous page vertically.
            </summary>
            <param name="appendSelect">When this value is true, the selection will be expanded to the cell in previous page rather than moving it.</param>
        </member>
        <member name="E:unvell.ReoGrid.Worksheet.BeforeSelectionRangeChange">
            <summary>
            Event raised before selection range changing
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.Worksheet.SelectionRangeChanged">
            <summary>
            Event raised on focus-selection-range changed
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.Worksheet.SelectionRangeChanging">
            <summary>
            Event raised on focus-selection-range is changing by mouse move
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.Worksheet.SelectionModeChanged">
            <summary>
            Event raised on Selection-Mode change
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.Worksheet.SelectionStyleChanged">
            <summary>
            Event raised on Selection-Style change
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.Worksheet.SelectionForwardDirectionChanged">
            <summary>
            Event raised on SelectionForwardDirection change
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.Worksheet.SelectionMovedForward">
            <summary>
            Event raised when focus-selection move to next position
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.Worksheet.SelectionMovedBackward">
            <summary>
            Event raised when focus-selection move to previous position
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.Clone(System.String)">
            <summary>
            Clone this worksheet, create a new instance.
            </summary>
            <returns>New instance cloned from current worksheet.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.SetRangeBorders(System.String,unvell.ReoGrid.BorderPositions,unvell.ReoGrid.RangeBorderStyle)">
            <summary>
            Set borders to specified range
            </summary>
            <param name="addressOrName">range specified by address</param>
            <param name="pos">positions relative to the specified range to set borders</param>
            <param name="style">border style information</param>
            <exception cref="T:unvell.ReoGrid.InvalidAddressException">throw if specified address or name is illegal</exception>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.SetRangeBorders(System.Int32,System.Int32,System.Int32,System.Int32,unvell.ReoGrid.BorderPositions,unvell.ReoGrid.RangeBorderStyle)">
            <summary>
            Set borders to specified range
            </summary>
            <param name="row">number of start row</param>
            <param name="col">number of start column</param>
            <param name="rows">number of rows</param>
            <param name="cols">number of columns</param>
            <param name="pos">position around specified range to be set border</param>
            <param name="style">style of border to be set</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.SetRangeBorders(unvell.ReoGrid.RangePosition,unvell.ReoGrid.BorderPositions,unvell.ReoGrid.RangeBorderStyle)">
            <summary>
            Set border styles to specified range. Or set an empty border style to remove styles from specified range.
            </summary>
            <param name="range">Specified range to be set</param>
            <param name="pos">Style of which position in range should be setted</param>
            <see cref="T:unvell.ReoGrid.BorderPositions"/>
            <param name="style">The style of border to be set</param>
            <see cref="T:unvell.ReoGrid.RangeBorderStyle"/>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.RemoveRangeBorders(unvell.ReoGrid.RangePosition,unvell.ReoGrid.BorderPositions)">
            <summary>
            Remove border style from specified range.
            </summary>
            <param name="range">Range to be removed</param>
            <param name="pos">Style of which position in range should be removed</param>
        </member>
        <member name="E:unvell.ReoGrid.Worksheet.BorderAdded">
            <summary>
            Event fired when any border styles be setted.
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.Worksheet.BorderRemoved">
            <summary>
            Event fired when any border styles be removed.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.GetRangeBorder(unvell.ReoGrid.RangePosition,unvell.ReoGrid.BorderPositions,System.Boolean)">
            <summary>
            Get borders information from specified range identified by address or name
            </summary>
            <param name="range">An valid address or name to locate the range on worksheet</param>
            <param name="pos">The positions to be get from worksheet. To get only all outside around the range,
            use BorderPositions.Outside; to get all borders, use BorderPositions.All.</param>
            <param name="onlyCellsOwn">True to get the borders only owned by its cell, </param>
            <returns>Border information object</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.GetRangeBorders(System.Int32,System.Int32,System.Int32,System.Int32,unvell.ReoGrid.BorderPositions,System.Boolean)">
            <summary>
            Get borders information from specified range identified by address or name.
            </summary>
            <param name="row">Number of row of the range to get borders.</param>
            <param name="col">Number of column of the range to get borders.</param>
            <param name="rows">Number of rows of the range to get borders.</param>
            <param name="cols">Number of columns of the range to get borders.</param>
            <param name="pos">Specifies where to get the borders around the range or cell. For example, 
            pass <code>BorderPositions.Outside</code> to get outside borders around specified address; 
            pass <code>BorderPositions.All</code> to get all borders from the range.</param>
            <param name="onlyCellsOwn">True to get the borders only owned by the range or cell.</param>
            <returns>Borders information object.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.GetRangeBorders(System.String,unvell.ReoGrid.BorderPositions,System.Boolean)">
            <summary>
            Get borders information from specified range identified by address or name
            </summary>
            <param name="addressOrName">An valid address or name to locate the range on worksheet</param>
            <param name="pos">Specifies where to get the borders around the range or cell. For example, 
            pass <code>BorderPositions.Outside</code> to get outside borders around specified address; 
            pass <code>BorderPositions.All</code> to get all borders from the range.</param>
            <param name="onlyCellsOwn">True to get the borders only owned by the range or cell.</param>
            <returns>Borders information object.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.GetRangeBorders(unvell.ReoGrid.RangePosition,unvell.ReoGrid.BorderPositions,System.Boolean)">
            <summary>
            Get borders info from specified range.
            </summary>
            <param name="range">Range to get borders.</param>
            <param name="pos">Target position of range to get borders.</param>
            <param name="onlyCellsOwn">Indicates whether or not to get only the borders that belong to the cells in given range.</param>
            <returns>Borders info retrieved from specified range.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.IterateBorders(unvell.ReoGrid.RowOrColumn,unvell.ReoGrid.RangePosition,System.Func{System.Int32,System.Int32,System.Int32,unvell.ReoGrid.RangeBorderStyle,System.Boolean})">
            <summary>
            Iterate over all borders in specified range.
            </summary>
            <param name="scanDirections">Specifies that borders iterated on which direction, horizontal borders, 
            vertical borders or both horizontal and vertical borders.</param>
            <param name="range">The range to iterate over all border from.</param>
            <param name="iterator">Callback anonymous function that is used to iterate each returned border from range.</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.SetCellData(System.String,System.Object)">
            <summary>
            Set data of cell at specified position on worksheet.
            </summary>
            <param name="addressOrName">Address or name to locate the cell.</param>
            <param name="data">Data to be set.</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.SetCellData(unvell.ReoGrid.CellPosition,System.Object)">
            <summary>
            Set data of cell at specified position on worksheet.
            </summary>
            <param name="pos">Position of cell to set data.</param>
            <param name="data">Data of cell to be set.</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.SetCellData(System.Int32,System.Int32,System.Object)">
            <summary>
            Set data of cell at specified position on worksheet.
            </summary>
            <param name="row">Index of row of specified cell.</param>
            <param name="col">Index of column of specified cell.</param>
            <param name="data">Data of cell.</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.SetSingleCellData(unvell.ReoGrid.Cell,System.Object)">
            <summary>
            Set data of cell at specified position on worksheet.
            </summary>
            <param name="cell">Instance of cell.</param>
            <param name="data">Data to be set.</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.UpdateCellData(unvell.ReoGrid.Cell,System.Object,System.Collections.Generic.Stack{System.Collections.Generic.List{unvell.ReoGrid.Cell}})">
            <summary>
            Update data for cell without doing any format and formula evalution.
            </summary>
            <param name="cell">cell to be updated</param>
            <param name="data">data to be updated</param>
            <param name="dirtyCellStack">A stack to save cells that is marked as dirty cell, the dirty cell will be updated delay</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.SetCellBody(System.Int32,System.Int32,unvell.ReoGrid.CellTypes.ICellBody)">
            <summary>
            Set body of cell at specified position of grid
            </summary>
            <param name="row">number of row</param>
            <param name="col">number of column</param>
            <param name="body">body to be set</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.SetCellBody(unvell.ReoGrid.Cell,unvell.ReoGrid.CellTypes.ICellBody)">
            <summary>
            Set body of cell into specified row
            </summary>
            <param name="cell">cell to be set</param>
            <param name="body">body to be set</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.RemoveCellBody(unvell.ReoGrid.CellPosition)">
            <summary>
            Remove cell body from specified cell
            </summary>
            <param name="pos">position of specified cell</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.RemoveCellBody(System.Int32,System.Int32)">
            <summary>
            Remove cell body from specified cell
            </summary>
            <param name="row">number of row</param>
            <param name="col">number of column</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.GetCellData(System.String)">
            <summary>
            Get cell data from specified address or name
            </summary>
            <param name="addressOrName">address or name to locate a cell</param>
            <returns>data from cell</returns>
            <exception cref="T:unvell.ReoGrid.InvalidAddressException">throw if specified address or name is invalid</exception>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.GetCellData(unvell.ReoGrid.CellPosition)">
            <summary>
            Get data from specified cell
            </summary>
            <param name="pos">Position of cell to get data</param>
            <returns>Data of cell</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.GetCellData(System.Int32,System.Int32)">
            <summary>
            Get data from specified cell
            </summary>
            <param name="row">zero-based number of row</param>
            <param name="col">zero-based number of column</param>
            <returns>data of cell</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.GetCellData``1(System.String)">
            <summary>
            Get data from specified cell
            </summary>
            <param name="addressOrName">address or name to locate the cell</param>
            <returns>data of cell</returns>
            <exception cref="T:unvell.ReoGrid.InvalidAddressException">throw if specified address or name is invalid</exception>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.GetCellData``1(unvell.ReoGrid.CellPosition)">
            <summary>
            Get data from specified cell
            </summary>
            <param name="pos">position to locate the cell</param>
            <returns>data of cell</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.GetCellData``1(System.Int32,System.Int32)">
            <summary>
            Get data in specified type from a cell
            </summary>
            <typeparam name="T">type of data will be converted into</typeparam>
            <param name="row">number of row to locate a cell</param>
            <param name="col">number of column to locate a cell</param>
            <returns></returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.TryGetNumberData(System.Int32,System.Int32,System.Double@)">
            <summary>
            Try get number data from cell at specified position. If the data is string, 
            this method will try to convert the string into number value.
            </summary>
            <param name="row">Number of row of the cell to get data.</param>
            <param name="col">Number of column of the cell to get data.</param>
            <param name="val">Number data returned and converted from cell.</param>
            <returns>True if data can be get and converted; Otherwise return false.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.GetCellText(System.String)">
            <summary>
            Get cell display text by specified address
            </summary>
            <param name="address">address to locate a cell</param>
            <returns>display text in string returned from specified cell</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.GetCellText(unvell.ReoGrid.CellPosition)">
            <summary>
            Get formatted cell text from spcified position
            </summary>
            <param name="pos">position to be get</param>
            <returns>formatted cell's text</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.GetCellText(System.Int32,System.Int32)">
            <summary>
            Get formatted cell text from specified position
            </summary>
            <param name="row">Row of position</param>
            <param name="col">Col of position</param>
            <returns>Text of cell</returns>
        </member>
        <member name="F:unvell.ReoGrid.Worksheet.suspendDataChangedEvent">
            <summary>
            Determine whether or not to suspend all data changing event. Suspend this event when 
            update lot of data into spreadsheet will help to speed up the data updating process.
            Note: make sure this flag can be restored for event invoke.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.SuspendDataChangedEvents">
            <summary>
            Suspend all data changing events, from both cell and range.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.ResumeDataChangedEvents">
            <summary>
            Resume all data changing events.
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.Worksheet.CellDataChanged">
            <summary>
            Event raised when any data has been changed
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.StringifyRange(unvell.ReoGrid.RangePosition)">
            <summary>
            Convert all data from specified range to a tabbed string.
            </summary>
            <param name="range">The range to be converted.</param>
            <returns>Tabbed string contains all data converted from specified range.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.PasteFromString(unvell.ReoGrid.CellPosition,System.String)">
            <summary>
            Paste data from tabbed string into worksheet.
            </summary>
            <param name="startPos">Start position to fill data.</param>
            <param name="str">Tabbed string to be pasted.</param>
            <returns>Range position that indicates the actually filled range.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.Copy">
            <summary>
            Copy data and put into Clipboard.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.Paste">
            <summary>
            Copy data from Clipboard and put on grid.
            
            Currently ReoGrid supports the following types of source from the clipboard.
             - Data from another ReoGrid instance
             - Plain/Unicode Text from any Windows Applications
             - Tabbed Plain/Unicode Data from Excel or similar applications
            
            When data copied from another ReoGrid instance, and the destination range 
            is bigger than the source, ReoGrid will try to repeat putting data to fill 
            the destination range entirely.
            
            Todo: Copy border and cell style from Excel.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.Cut">
            <summary>
            Copy any remove anything from selected range into Clipboard.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.CanCopy">
            <summary>
            Determine whether the selected range can be copied.
            </summary>
            <returns>True if the selected range can be copied.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.CanCut">
            <summary>
            Determine whether the selected range can be cutted.
            </summary>
            <returns>True if the selected range can be cutted.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.CanPaste">
            <summary>
            Determine whether the data contained in Clipboard can be pasted into grid control.
            </summary>
            <returns>True if the data contained in Clipboard can be pasted</returns>
        </member>
        <member name="E:unvell.ReoGrid.Worksheet.BeforePaste">
            <summary>
            Before a range will be pasted from Clipboard
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.Worksheet.AfterPaste">
            <summary>
            When a range has been pasted into grid
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.Worksheet.OnPasteError">
            <summary>
            When an error happened during perform paste
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.Worksheet.BeforeCopy">
            <summary>
            Before a range to be copied into Clipboard
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.Worksheet.AfterCopy">
            <summary>
            When a range has been copied into Clipboard
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.Worksheet.BeforeCut">
            <summary>
            Before a range to be moved into Clipboard
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.Worksheet.AfterCut">
            <summary>
            After a range to be moved into Clipboard
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.SetRangeDataFormat(System.String,unvell.ReoGrid.DataFormat.CellDataFormatFlag,System.Object)">
            <summary>
            Set data format for specified range.
            </summary>
            <param name="addressOrName">Address or name to locate the cell and range on spreadsheet to be set.</param>
            <param name="format">Flag specifies that which format will be used.</param>
            <param name="dataFormatArgs">Argument to specify the details for different format.</param>
            <exception cref="T:unvell.ReoGrid.InvalidAddressException">Throw if specified address or name is illegal.</exception>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.SetRangeDataFormat(System.Int32,System.Int32,System.Int32,System.Int32,unvell.ReoGrid.DataFormat.CellDataFormatFlag,System.Object)">
            <summary>
            Set data format for specified range.
            </summary>
            <param name="row">Number of row to locate the range.</param>
            <param name="col">Number of column to locate the range.</param>
            <param name="rows">Number of rows contained in the range.</param>
            <param name="cols">Number of columns contained in the range.</param>
            <param name="format">Flag specifies that which format will be used.</param>
            <param name="dataFormatArgs">Argument to specify the details for different format.</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.SetRangeDataFormat(unvell.ReoGrid.RangePosition,unvell.ReoGrid.DataFormat.CellDataFormatFlag,System.Object)">
            <summary>
            Set data format for specified range.
            </summary>
            <param name="range">Range to be set.</param>
            <param name="format">Flag specifies that which format will be used.</param>
            <param name="dataFormatArgs">Argument to specify the details for different format.</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.DeleteRangeDataFormat(unvell.ReoGrid.RangePosition)">
            <summary>
            Delete data format settings from specified range
            </summary>
            <param name="range">Range to be remove formats</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.SetCellFormula(System.String,System.String)">
            <summary>
            Set formula into cell, calculate the value of formula and update referenced cells.
            </summary>
            <param name="addressOrName">Address or name to locate range on worksheet</param>
            <param name="formula">Formula to be set. Equal sign is not required.</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.SetCellFormula(System.Int32,System.Int32,System.String)">
            <summary>
            Set formula into cell, calculate the value of formula and update referenced cells.
            </summary>
            <param name="row">Number of row of cell</param>
            <param name="col">Number of column of cell</param>
            <param name="formula">Formula to be set. Equal sign is not required.</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.SetCellFormula(unvell.ReoGrid.CellPosition,System.String)">
            <summary>
            Set formula into cell, calculate the value of formula and update referenced cells.
            </summary>
            <param name="pos">position of cell</param>
            <param name="formula">Formula to be set. Equal sign is not required.</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.DeleteCellFormula(System.String)">
            <summary>
            Delete formula from specified cell.
            </summary>
            <param name="addressOrName">Address or name used to locate cell on worksheet.</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.DeleteCellFormula(unvell.ReoGrid.CellPosition)">
            <summary>
            Delete formula from specified cell.
            </summary>
            <param name="pos">Position to locate the cell on worksheet.</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.DeleteCellFormula(System.Int32,System.Int32)">
            <summary>
            Delete formula from specified cell.
            </summary>
            <param name="row">Number of row of the cell to be deleted.</param>
            <param name="col">Number of column of the cell to be deleted.</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.DeleteCellFormula(unvell.ReoGrid.Cell)">
            <summary>
            Delete formula from specified.
            </summary>
            <param name="cell">Instance of cell to be deleted.</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.RecalcCell(System.String)">
            <summary>
            Recalculate specified cell formula.
            </summary>
            <param name="pos">Address on worksheet to locate the cell.</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.RecalcCell(unvell.ReoGrid.CellPosition)">
            <summary>
            Recalculate specified cell formula.
            </summary>
            <param name="pos">Position of cell to be recalculated.</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.RecalcCell(System.Int32,System.Int32)">
            <summary>
            Recalculate specified cell formula.
            </summary>
            <param name="row">Index of row of cell.</param>
            <param name="col">Index of column of cell.</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.RecalcCell(unvell.ReoGrid.Cell,System.Collections.Generic.Stack{System.Collections.Generic.List{unvell.ReoGrid.Cell}})">
            <summary>
            Recalculate and get the value of formula stored in the specified cell.
            </summary>
            <param name="cell">Instance of cell to be recalculated.</param>
            <param name="dirtyCellStack">Dirty cell stack.</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.SuspendFormulaReferenceUpdates">
            <summary>
            Suspend to update formula referenced cells.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.ResumeFormulaReferenceUpdates">
            <summary>
            Resume to update formula referenced cells.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.GetCellFormulaReferenceRanges(System.String)">
            <summary>
            Get a list of referenced ranges from formula of specified cell
            </summary>
            <param name="address">address of cell to find its reference list</param>
            <returns>a list of referenced cell</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.GetCellFormulaReferenceRanges(unvell.ReoGrid.CellPosition)">
            <summary>
            Get a list of referenced ranges from formula of specified cell
            </summary>
            <param name="pos">position of cell to find its reference list</param>
            <returns>a list of referenced cell</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.GetCellFormulaReferenceRanges(unvell.ReoGrid.Cell)">
            <summary>
            Get a list of referenced ranges from formula of specified cell
            </summary>
            <param name="cell">cell to find its reference list</param>
            <returns>a list of referenced cell</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.GetCellFormula(System.String)">
            <summary>
            Get formula from cell specified by an address or registered name
            </summary>
            <param name="addressOrName">address or name used to locate a cell</param>
            <returns>formula as string returned from cell</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.GetCellFormula(unvell.ReoGrid.CellPosition)">
            <summary>
            Get formula from cell specified by position
            </summary>
            <param name="pos">position to locate the cell to be get</param>
            <returns>formula as string returned from specified cell</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.TraceCellPrecedents(System.String)">
            <summary>
            Show cell formula precedent trace lines on worksheet
            </summary>
            <param name="address">address to trace the cell</param>
            <returns>true if trace is successful</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.TraceCellPrecedents(unvell.ReoGrid.CellPosition)">
            <summary>
            Show cell formula precendent trace lines on worksheet
            </summary>
            <param name="pos">position to trace the cell</param>
            <returns>true if trace is successful</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.RemoveCellTracePrecedents(System.String)">
            <summary>
            Remove cell trace precedents from specified address
            </summary>
            <param name="address">address to remove trace precedents</param>
            <returns></returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.RemoveCellTracePrecedents(unvell.ReoGrid.CellPosition)">
            <summary>
            Remove cell formula precedent trace lines from worksheet
            </summary>
            <param name="pos">position to locate the cell remove trace lines</param>
            <returns>true if trace lines has been removed successfully</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.RemoveCellTracePrecedents(unvell.ReoGrid.Cell)">
            <summary>
            Remove cell formula precedent trace lines from worksheet
            </summary>
            <param name="cell">cell to be checked and removed</param>
            <returns>true if trace lines has been removed successfully</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.TraceCellDependents(System.String)">
            <summary>
            Start trace dependents to specified address
            </summary>
            <param name="address">target address to trace dependents</param>
            <returns>true if trace arrow added</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.TraceCellDependents(unvell.ReoGrid.CellPosition)">
            <summary>
            Start trace dependents to specified position
            </summary>
            <param name="pos">target position to trace dependents</param>
            <returns>true if trace arrow added</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.TraceCellDependents(unvell.ReoGrid.Cell)">
            <summary>
            Start trace dependents to specified cell
            </summary>
            <param name="cell">target cell to trace dependents</param>
            <returns>true if trace arrow added</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.RemoveCellTraceDependents(System.String)">
            <summary>
            Remove all trace dependent arrows from specified address
            </summary>
            <param name="address">address to remove cell dependents</param>
            <returns></returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.RemoveCellTraceDependents(unvell.ReoGrid.CellPosition)">
            <summary>
            Remove all trace dependent arrows from specified position
            </summary>
            <param name="pos">position to remove cell dependents</param>
            <returns></returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.RemoveCellTraceDependents(unvell.ReoGrid.Cell)">
            <summary>
            Remove all trace dependent arrows from specified cell
            </summary>
            <param name="cell">cell to remove trace dependents</param>
            <returns></returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.AddTraceLine(unvell.ReoGrid.Cell,unvell.ReoGrid.Cell)">
            <summary>
            Add trace arrow between specified two cells
            </summary>
            <param name="fromCell">Trace arrow begin from this cell</param>
            <param name="toCell">Trace arrow end to this cell</param>
            <returns>true if </returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.RemoveTraceLine(unvell.ReoGrid.Cell,unvell.ReoGrid.Cell)">
            <summary>
            Remove trace arrow between specified two cells
            </summary>
            <param name="fromCell">Trace arrow begin from this cell</param>
            <param name="toCell">Trace arrow end to this cell</param>
            <returns></returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.RemoveCellAllTraceArrows(System.String)">
            <summary>
            Remove all trace arrows from specified address
            </summary>
            <param name="address">Address of position to locate a cell</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.RemoveCellAllTraceArrows(unvell.ReoGrid.CellPosition)">
            <summary>
            Remove all trace arrows from specified position
            </summary>
            <param name="pos">Position to locate a cell</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.RemoveCellAllTraceArrows(unvell.ReoGrid.Cell)">
            <summary>
            Remove all trace arrows from specified cell
            </summary>
            <param name="cell">cell instance to remove trace arrows</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.RemoveRangeAllTraceArrows(System.String)">
            <summary>
            Remove all trace arrows from specified range of address
            </summary>
            <param name="address">address to locate a range</param>
            <returns>true if address is valid</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.RemoveRangeAllTraceArrows(unvell.ReoGrid.RangePosition)">
            <summary>
            Remove all trace arrows from specified range
            </summary>
            <param name="range"></param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.IsCellInTracePrecedents(unvell.ReoGrid.CellPosition)">
            <summary>
            Check whether specified cell currently in trace precedents
            </summary>
            <param name="pos">a position to locate cell</param>
            <returns>true if cell in trace precedents</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.IsCellInTraceDependents(unvell.ReoGrid.CellPosition)">
            <summary>
            Check whether specified cell currently in trace dependents
            </summary>
            <param name="pos">a position to locate cell</param>
            <returns>true if cell in trace dependents</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.GetAllTraceDependentCells">
            <summary>
            Retrieve all cells which in trace precedents or dependents
            </summary>
            <returns>list of cells</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.Recalculate">
            <summary>
            Recalculate entire worksheet.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Worksheet.RowHeaderWidth">
            <summary>
            Get or set width of row header in pixel.
            
            Set to -1 to restore system default width;
            Set to 0 to hide the panel of row header;
            Set to other value to decide the width of row header in pixel;
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.SetColumnsWidth(System.Int32,System.Int32,System.UInt16)">
            <summary>
            Set width of specified columns
            </summary>
            <param name="col">Start column index to set</param>
            <param name="count">Number of columns to set</param>
            <param name="width">Width value of column</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.SetRowsHeight(System.Int32,System.Int32,System.UInt16)">
            <summary>
            Set height of specified rows
            </summary>
            <param name="row">Start row index to set</param>
            <param name="count">Number of rows to set</param>
            <param name="height">Height value of row</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.GetColumnWidth(System.Int32)">
            <summary>
            Get width from specified column. (in pixel)
            </summary>
            <param name="col">Column index to get.</param>
            <returns>Width in pixel of specified column.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.GetRowHeight(System.Int32)">
            <summary>
            Get height from specified row
            </summary>
            <param name="row">Row index to get</param>
            <returns>Height value of specified row</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.DisableAutoRowHeight(System.Int32)">
            <summary>
            Disable auto-row-height adjust on specified row
            </summary>
            <param name="row">row to be disable auto-row-height</param>
            <returns></returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.EnableAutoRowHeight(System.Int32)">
            <summary>
            Disable auto-row-height adjust on specified row
            </summary>
            <param name="row">row to be disable auto-row-height</param>
            <returns></returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.IsAutoRowHeight(System.Int32)">
            <summary>
            Disable auto-row-height adjust on specified row
            </summary>
            <param name="row">row to be disable auto-row-height</param>
            <returns></returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.AutoFitRowHeight(System.Int32,System.Boolean)">
            <summary>
            Make height of specified row header to fit the cells on that row automatically.
            </summary>
            <param name="row">Zero-based number of row to be adjusted.</param>
            <param name="byAction">Specify that whether or not this operation should 
            be done by performing action, that will be able to revoke this behavior.</param>
            <returns>Return true if operation actually done; Return false if nothing 
            happened. (cells are default height)</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.AutoFitColumnWidth(System.Int32,System.Boolean)">
            <summary>
            Make width of specified column header to fit the cells on that column automatically.
            </summary>
            <param name="col">Zero-based number of column to be adjusted</param>
            <param name="byAction">Specify that whether or not this operation should 
            be done by performing action, that will be able to revoke this behavior.</param>
            <returns>Return true if operation actually done; Return false if nothing 
            need to do (cells are default width).</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.AppendCols(System.Int32)">
            <summary>
            Append specified columns at right of grid
            </summary>
            <param name="count">number of columns</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.AppendRows(System.Int32)">
            <summary>
            Append specified rows at bottom of grid
            </summary>
            <param name="count">number of rows</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.Resize(System.Int32,System.Int32)">
            <summary>
            Resize grid to specified number of rows and cols.
            </summary>
            <param name="rows">Number of rows to be resized.</param>
            <param name="cols">Number of columns to be resized.</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.SetCols(System.Int32)">
            <summary>
            Set number of columns (up to 32768)
            </summary>
            <param name="colCount">Number of columns</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.SetRows(System.Int32)">
            <summary>
            Set number of rows (up to 1048576)
            </summary>
            <param name="rowCount">Number of rows</param>
        </member>
        <member name="P:unvell.ReoGrid.Worksheet.Rows">
            <summary>
            Get or set number of rows of current worksheet
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Worksheet.Columns">
            <summary>
            Get or set number of columns of current worksheet
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.InsertRows(System.Int32,System.Int32)">
            <summary>
            Insert rows before specified row index
            </summary>
            <param name="row">index of row</param>
            <param name="count">number of rows</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.InsertColumns(System.Int32,System.Int32)">
            <summary>
            Insert rows before specified row index
            </summary>
            <param name="col">zero-based number of column start to insert columns</param>
            <param name="count">number of columns to be inserted</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.DeleteRows(System.Int32,System.Int32)">
            <summary>
            Delete rows from speicifed number of row
            </summary>
            <param name="row">number of row start to be deleted</param>
            <param name="count">number of rows to be deleted</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.DeleteColumns(System.Int32,System.Int32)">
            <summary>
            Delete columns from specified number of column
            </summary>
            <param name="col">number of column start to be deleted</param>
            <param name="count">number of columns to be deleted</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.HideRows(System.Int32,System.Int32)">
            <summary>
            Hide specified rows.
            </summary>
            <seealso cref="M:unvell.ReoGrid.Worksheet.ShowRows(System.Int32,System.Int32)"/>
            <param name="row">Index of row start to hide.</param>
            <param name="count">Number of rows to be hidden.</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.ShowRows(System.Int32,System.Int32)">
            <summary>
            Show specified rows.
            </summary>
            <seealso cref="M:unvell.ReoGrid.Worksheet.HideRows(System.Int32,System.Int32)"/>
            <param name="row">Number of row start to show.</param>
            <param name="count">Number of rows to show.</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.HideColumns(System.Int32,System.Int32)">
            <summary>
            Hide specified columns.
            </summary>
            <seealso cref="M:unvell.ReoGrid.Worksheet.ShowColumns(System.Int32,System.Int32)"/>
            <param name="col">index of start column to hide</param>
            <param name="count">number of columns to be hidden</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.ShowColumns(System.Int32,System.Int32)">
            <summary>
            Show specified columns.
            </summary>
            <seealso cref="M:unvell.ReoGrid.Worksheet.HideColumns(System.Int32,System.Int32)"/>
            <param name="col">Number of column start to show.</param>
            <param name="count">Number of columns to show.</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.IsRowVisible(System.Int32)">
            <summary>
            Check whether or not a specified row is visible.
            </summary>
            <seealso cref="M:unvell.ReoGrid.Worksheet.IsColumnVisible(System.Int32)"/>
            <param name="row">Zero-based row index to check.</param>
            <returns>True if the specified row on worksheet is visible; otherwise return false.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.IsColumnVisible(System.Int32)">
            <summary>
            Check whether or not a specified column is visible.
            </summary>
            <seealso cref="M:unvell.ReoGrid.Worksheet.IsRowVisible(System.Int32)"/>
            <param name="col">Zero-based row index to check.</param>
            <returns>True if the specified column on worksheet is visible; otherwise return false.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.IsHiddenRow(System.Int32)">
            <summary>
            Check whether an entire row is hidden
            </summary>
            <param name="row">number of row to be checked</param>
            <returns>true if the entire row is hidden, otherwise return false</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.IsHiddenColumn(System.Int32)">
            <summary>
            Check whether an entire column is hidden
            </summary>
            <param name="col">number of column to be checked</param>
            <returns>true if the entire column is hidden, otherwise return false</returns>
        </member>
        <member name="P:unvell.ReoGrid.Worksheet.ColumnCount">
            <summary>
            Get or set number of columns for current worksheet (must at least one column left)
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Worksheet.RowCount">
            <summary>
            Get or set number of rows for current worksheet (must at least one row left)
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.RetrieveRowHeader(System.Int32)">
            <summary>
            Get instance of row header from specified number of row
            (internal method, no boundary check)
            </summary>
            <param name="index">number of row to be get</param>
            <returns>instance of row header</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.RetrieveColumnHeader(System.Int32)">
            <summary>
            Get the instance of column header from specified number of column
            (internal method, no boundary check)
            </summary>
            <param name="index">number of column to be get</param>
            <returns>instance of column header</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.GetRowHeader(System.Int32)">
            <summary>
            Get instance of row header from specified number of row.
            </summary>
            <param name="index">number of row to be get.</param>
            <returns>instance of row header.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.GetColumnHeader(System.Int32)">
            <summary>
            Get the instance of column header from specified number of column.
            </summary>
            <param name="index">Number of column to be get.</param>
            <returns>Instance of column header.</returns>
        </member>
        <member name="P:unvell.ReoGrid.Worksheet.RowHeaders">
            <summary>
            Get the collection of row header.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Worksheet.ColumnHeaders">
            <summary>
            Get the collection of column header.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Worksheet.RowHeaderCollection">
            <summary>
            Row header collection
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Worksheet.RowHeaderCollection.Item(System.Int32)">
            <summary>
            Get row header by zero-based index of number of row
            </summary>
            <param name="index">Zero-based number of row</param>
            <returns>Row header instance</returns>
        </member>
        <member name="T:unvell.ReoGrid.Worksheet.ColumnHeaderCollection">
            <summary>
            Column header collection
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Worksheet.ColumnHeaderCollection.Item(System.Int32)">
            <summary>
            Get column header by zero-based index of number of column
            </summary>
            <param name="index">Zero-based number of column</param>
            <returns>Column header instance</returns>
        </member>
        <member name="P:unvell.ReoGrid.Worksheet.ColumnHeaderCollection.Item(System.String)">
            <summary>
            Get column header by address code (e.g. A, B, Z)
            </summary>
            <param name="address">Address code to get column header</param>
            <returns>Column header instance</returns>
        </member>
        <member name="E:unvell.ReoGrid.Worksheet.RowsInserted">
            <summary>
            Event raised on row inserted at given index of row.
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.Worksheet.RowsDeleted">
            <summary>
            Event raised on row deleted at given index of row.
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.Worksheet.ColumnsInserted">
            <summary>
            Event raised on column inserted at given index of column.
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.Worksheet.ColumnsDeleted">
            <summary>
            Event raised on column deleted at given index of column.
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.Worksheet.RowsHeightChanged">
            <summary>
            Event raised when row's height changed.
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.Worksheet.ColumnsWidthChanged">
            <summary>
            Event raised when column's width changed.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Worksheet.RowOutlines">
            <summary>
            Get row outline collection.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Worksheet.ColumnOutlines">
            <summary>
            Get column outline collection.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.GetOutlines(unvell.ReoGrid.RowOrColumn)">
            <summary>
            Retrieve the attached outlines from spreadsheet.
            </summary>
            <param name="flag">Row or column to be retrieved.</param>
            <returns>Retrieved collection of outline.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.IterateOutlines(unvell.ReoGrid.RowOrColumn,System.Func{unvell.ReoGrid.Outline.OutlineGroup{unvell.ReoGrid.Outline.ReoGridOutline},unvell.ReoGrid.Outline.ReoGridOutline,System.Boolean})">
            <summary>
            Iterate over all attached outlines.
            </summary>
            <param name="flag">Spcifiy that row or column to be iterated.</param>
            <param name="iterator">Iterator to handle all outlines.</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.GroupColumns(System.Int32,System.Int32)">
            <summary>
            Group columns from specified number of columns.
            </summary>
            <param name="col">number of columns to start group.</param>
            <param name="count">numbers of column to be grouped.</param>
            <returns>an outline instance including the information of grouped columns.</returns>
            <exception cref="T:unvell.ReoGrid.OutlineOutOfRangeException">if specified number of rows out of maximum row in this worksheet.</exception>
            <exception cref="T:unvell.ReoGrid.OutlineTooMuchException">If there is more than 9 outlines existed this exception will be thrown.</exception>
            <exception cref="T:unvell.ReoGrid.OutlineAlreadyDefinedException">If there is a same outline with specified number and count has been already added.</exception>
            <exception cref="T:unvell.ReoGrid.OutlineIntersectedException">If specified outline intersects with another one which has been already added.</exception>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.GroupRows(System.Int32,System.Int32)">
            <summary>
            Group rows from specified number of rows.
            </summary>
            <param name="row">number of rows to start group.</param>
            <param name="count">numbers of row to be grouped.</param>
            <returns>an outline instance including the information of grouped rows.</returns>
            <exception cref="T:unvell.ReoGrid.OutlineOutOfRangeException">if specified number of rows out of maximum row in this worksheet</exception>
            <exception cref="T:unvell.ReoGrid.OutlineTooMuchException">If there is more than 9 outlines existed this exception will be thrown.</exception>
            <exception cref="T:unvell.ReoGrid.OutlineAlreadyDefinedException">If there is a same outline with specified number and count has been already added.</exception>
            <exception cref="T:unvell.ReoGrid.OutlineIntersectedException">If specified outline intersects with another one which has been already added.</exception>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.AddOutline(unvell.ReoGrid.RowOrColumn,System.Int32,System.Int32)">
            <summary>
            Add outline (Group rows) from specified start position.
            </summary>
            <param name="flag">what direction used to add outline. (specifying Row or Column)</param>
            <param name="start">Start position of outline.</param>
            <param name="count">Total count of outline.</param>
            <returns>An outline instance including the information of grouped rows or columns.</returns>
            <exception cref="T:unvell.ReoGrid.OutlineOutOfRangeException">If specified number of rows out of maximum row on this worksheet.</exception>
            <exception cref="T:unvell.ReoGrid.OutlineTooMuchException">If there is more than 9 outlines existed this exception will be thrown.</exception>
            <exception cref="T:unvell.ReoGrid.OutlineAlreadyDefinedException">If there is a same outline with specified number and count has been already added.</exception>
            <exception cref="T:unvell.ReoGrid.OutlineIntersectedException">If specified outline intersects with another one which has been already added.</exception>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.GetOutline(unvell.ReoGrid.RowOrColumn,System.Int32,System.Int32)">
            <summary>
            Get an instance of outline by specified position.
            </summary>
            <param name="flag">Determine that outline in row or column direction to be get.</param>
            <param name="start">Zero-based start position of the outline.</param>
            <param name="count">Number of rows or columns contained in the outline.</param>
            <returns>Instance of outline if found with specified position.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.CollapseOutline(unvell.ReoGrid.RowOrColumn,System.Int32,System.Int32)">
            <summary>
            Collapse specified outline.
            </summary>
            <param name="flag">Determine that outline in row or column direction to be get.</param>
            <param name="start">Zero-based start position of the outline.</param>
            <param name="count">Number of rows or columns contained in the outline.</param>
            <returns>Instance if specified outline was found and collapsed.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.ExpandOutline(unvell.ReoGrid.RowOrColumn,System.Int32,System.Int32)">
            <summary>
            Expand specified outline.
            </summary>
            <param name="flag">Determine that outline in row or column direction to be get.</param>
            <param name="start">Zero-based start position of the outline.</param>
            <param name="count">Number of rows or columns contained in the outline.</param>
            <returns>Instance if specified outline was found and expanded.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.RemoveOutline(unvell.ReoGrid.RowOrColumn,System.Int32,System.Int32)">
            <summary>
            Remove outline from specified position by number of rows or columns.
            </summary>
            <param name="flag">Which row and column to be removed.</param>
            <param name="start">Zero-based start position of the outline.</param>
            <param name="count">Number of rows or columns contained in the outline.</param>
            <returns>Instance of outline has been removed; Return null if no outlines found 
            from specified position and count information.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.RemoveOutline(unvell.ReoGrid.Outline.IReoGridOutline)">
            <summary>
            Remove specfieid outline from collection of outlines of control.
            </summary>
            <param name="outline">The instance of outline will be removed.</param>
            <returns>True if outline has been found by specified position and count,
            and has been removed successfully; otherwise return false.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.UngroupRows(System.Int32,System.Int32)">
            <summary>
            Ungroup specified rows. (Remove outline from specified rows)
            </summary>
            <param name="row">number of row to ungroup.</param>
            <param name="count">number of rows to ungroup.</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.UngroupColumns(System.Int32,System.Int32)">
            <summary>
            Ungroup specified columns. (Remove outline from specified columns)
            </summary>
            <param name="col">number of column to ungroup.</param>
            <param name="count">number of columns to ungroup.</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.UngroupAllRows">
            <summary>
            Ungroup all rows. (Remove all row outlines from spreadsheet)
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.UngroupAllColumns">
            <summary>
            Ungroup all columns. (Remove all column outlines from spreadsheet)
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.ClearOutlines(unvell.ReoGrid.RowOrColumn)">
            <summary>
            Clear all outlines and close the outline panel.
            </summary>
            <param name="flag">Specifies to process row or column outline of row and column to be clear.</param>
        </member>
        <member name="E:unvell.ReoGrid.Worksheet.OutlineAdded">
            <summary>
            Event raised when an outline has been added onto spreadsheet
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.Worksheet.OutlineRemoved">
            <summary>
            Event raised when an outline has been removed from spreadsheet
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.Worksheet.BeforeOutlineCollapse">
            <summary>
            Event is raised before an outline collapse
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.Worksheet.AfterOutlineCollapse">
            <summary>
            Event is raised after an outline collapse
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.Worksheet.BeforeOutlineExpand">
            <summary>
            Event is raised before an outline expanding
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.Worksheet.AfterOutlineExpand">
            <summary>
            Event is raised after an outline expanding
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.GetPartialGrid(System.String)">
            <summary>
            Copy a part of worksheet from specified range that identified by address or name.
            </summary>
            <param name="addressOrName">The address or name to locate a range position on worksheet.</param>
            <returns>A part of worksheet that is copied from original worksheet.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.GetPartialGrid(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Copy a part of worksheet from specified range that identified by address value.
            </summary>
            <param name="row">Number of start row.</param>
            <param name="col">Number of start col.</param>
            <param name="rows">Number of rows to be copied.</param>
            <param name="cols">Number of columns to be copied.</param>
            <returns>A part of worksheet that is copied from original worksheet.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.GetPartialGrid(unvell.ReoGrid.RangePosition)">
            <summary>
            Copy a part of worksheet from specified range.
            </summary>
            <param name="range">The range to be copied.</param>
            <returns>A part of worksheet that is copied from original worksheet.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.SetPartialGrid(System.String,unvell.ReoGrid.PartialGrid)">
            <summary>
            Copy a part of worksheet into current worksheet.
            </summary>
            <param name="addressOrName">The target range position specified by address or name.</param>
            <param name="data">A part of worksheet to be copied.</param>
            <returns>The range position that is the range filled actually.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.SetPartialGrid(unvell.ReoGrid.RangePosition,unvell.ReoGrid.PartialGrid)">
            <summary>
            Copy from a separated grid into current grid.
            </summary>
            <param name="data">Partial grid to be copied.</param>
            <param name="toRange">Range to be copied.</param>
            <returns>Range has been copied</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.SetPartialGridRepeatly(unvell.ReoGrid.RangePosition,unvell.ReoGrid.PartialGrid)">
            <summary>
            Repeat to copy from a separated grid to fit specified range
            </summary>
            <param name="grid">Partial grid to be copied</param>
            <param name="range">Range to be copied</param>
            <returns></returns>
        </member>
        <member name="P:unvell.ReoGrid.Worksheet.PrintSettings">
            <summary>
            Ger or set ReoGrid spreadsheet print settings.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Worksheet.PrintableRange">
            <summary>
            Get or set printable range
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Worksheet.RowPageBreaks">
            <summary>
            Get collection of row page-break indexes
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Worksheet.RowPageBreakIndexCollection">
            <summary>
            Collection of row page-break indexes
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.RowPageBreakIndexCollection.GetEnumerator">
            <summary>
            Get enumerator of row page break indexes
            </summary>
            <returns></returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.RowPageBreakIndexCollection.Add(System.Int32)">
            <summary>
            Insert a new index
            </summary>
            <param name="rowIndex">row index to be inserted</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.RowPageBreakIndexCollection.Clear">
            <summary>
            Clear all row break indexes
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.RowPageBreakIndexCollection.Contains(System.Int32)">
            <summary>
            Check whether or not the specified index is contained in current collection
            </summary>
            <param name="index">index to be checked</param>
            <returns></returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.RowPageBreakIndexCollection.CopyTo(System.Int32[],System.Int32)">
            <summary>
            Copy elements to another array
            </summary>
            <param name="array">Array to put elements</param>
            <param name="arrayIndex">Start index to copy</param>
        </member>
        <member name="P:unvell.ReoGrid.Worksheet.RowPageBreakIndexCollection.Count">
            <summary>
            Get the number of elements
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Worksheet.RowPageBreakIndexCollection.IsReadOnly">
            <summary>
            Check whether or not this collection is read-only
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.RowPageBreakIndexCollection.Remove(System.Int32)">
            <summary>
            Remove element by specified index
            </summary>
            <param name="rowIndex">Number of element to be removed</param>
            <returns>True if element was found and removed successfully</returns>
        </member>
        <member name="P:unvell.ReoGrid.Worksheet.RowPageBreakIndexCollection.Item(System.Int32)">
            <summary>
            Get or set page-break by zero-based index
            </summary>
            <param name="index">Index to get page-break index</param>
            <returns></returns>
        </member>
        <member name="P:unvell.ReoGrid.Worksheet.ColumnPageBreaks">
            <summary>
            Get collection of column page break indexes
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Worksheet.ColumnPageBreakIndexCollection">
            <summary>
            Collection of column page break indexes
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.ColumnPageBreakIndexCollection.GetEnumerator">
            <summary>
            Get the enumerator of current collection
            </summary>
            <returns>enumerator of current collection</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.ColumnPageBreakIndexCollection.Add(System.Int32)">
            <summary>
            Add a column page break
            </summary>
            <param name="columnIndex">number of column to be added as page break</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.ColumnPageBreakIndexCollection.Clear">
            <summary>
            Clear all column page breaks
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.ColumnPageBreakIndexCollection.Contains(System.Int32)">
            <summary>
            Check whether or not a column page break has already added
            </summary>
            <param name="index">number of column index to be checked</param>
            <returns>true if the page break has been added, otherwise return false</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.ColumnPageBreakIndexCollection.CopyTo(System.Int32[],System.Int32)">
            <summary>
            Copy all column page breaks into another array
            </summary>
            <param name="array">array to be save the page breaks</param>
            <param name="arrayIndex">number of index to start copy the array</param>
        </member>
        <member name="P:unvell.ReoGrid.Worksheet.ColumnPageBreakIndexCollection.Count">
            <summary>
            Get the column page break count
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Worksheet.ColumnPageBreakIndexCollection.IsReadOnly">
            <summary>
            Check whether or not current column page break is read-only
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.ColumnPageBreakIndexCollection.Remove(System.Int32)">
            <summary>
            Remove a column page break from spreadsheet
            </summary>
            <param name="columnIndex">number of column index to be removed</param>
            <returns></returns>
        </member>
        <member name="P:unvell.ReoGrid.Worksheet.ColumnPageBreakIndexCollection.Item(System.Int32)">
            <summary>
            Get or set the column page break
            </summary>
            <param name="index">number of column index to be added or removed</param>
            <returns>number of column index returned from current spreadsheet</returns>
        </member>
        <member name="E:unvell.ReoGrid.Worksheet.PrintableRangeChanged">
            <summary>
            Event raised when printable range is changed
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.ResetAllPageBreaks">
            <summary>
            Reset all page breaks
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.AutoSplitPage">
            <summary>
            Split spreadsheet into multiple pages automatically according to given paper size.
            </summary>
            <remarks>
            This method itself works very fast, but will be slower if a remote printer is specified 
            as target printer. Fetching paper size from a remote printer will spend more than 100ms. 
            (depending on the network environment)
            </remarks>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.AutoSetMaximumScaleForPages">
            <summary>
            Adjust the page scale to fit every page print range automatically
            in order to make page cells can be printed out properly.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.CreatePrintSession">
            <summary>
            Create print session to print this worksheet.
            </summary>
            <returns>Print session created from this worksheet.</returns>
            <exception cref="T:unvell.ReoGrid.NoPrintableContentException">Exception will be thrown if nothing found to be printed.</exception>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.IteratePrintPages(System.Func{unvell.ReoGrid.RangePosition,System.Boolean})">
            <summary>
            Iterate over all page break ranges
            </summary>
            <param name="iterator">delegate function to iterate over each pages</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.IteratePrintPages(unvell.ReoGrid.Print.PrintPageOrder,System.Func{unvell.ReoGrid.RangePosition,System.Boolean})">
            <summary>
            Iterate over all page break ranges
            </summary>
            <param name="pageOrder">order for iterating pages (down then over, over then down)</param>
            <param name="iterator">delegate function to iterate over each pages</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.ChangeColumnPageBreak(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Change (Move) a column page break index from specified position to a new position.
            </summary>
            <param name="oldIndex">Zero-based number of column to find the page break that will be moved.</param>
            <param name="newIndex">Zero-based number of column to put column page break.</param>
            <param name="refreshPageBreaks">Indicates whether or not to resplit all pages after changing. (Default is true)</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.ChangeRowPageBreak(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Move a specified row page break index from specified position to a new position.
            </summary>
            <param name="oldIndex">Zero-based number of row to find the page break that will be moved.</param>
            <param name="newIndex">Zero-based number of row to put row page break.</param>
            <param name="refreshPageBreaks">Indicates whether or not to resplit all pages after changing. (Default is true)</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.InsertColumnPageBreak(System.Int32,System.Boolean)">
            <summary>
            Insert row page break before specified column
            </summary>
            <param name="columnIndex">zero-based number of row to insert page break</param>
            <param name="refreshPageBreaks">indicates that whether allow to update others page 
            break and adjust the page scale automatically. (default is true)</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.InsertRowPageBreak(System.Int32,System.Boolean)">
            <summary>
            Insert row page break before specified row
            </summary>
            <param name="rowIndex">zero-based number of row to insert page break</param>
            <param name="refreshPageBreaks">indicates that whether allow to update others page 
            break and adjust the page scale automatically. (default is true)</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.RemoveColumnPageBreak(System.Int32)">
            <summary>
            Remove column page break from specified number of column
            </summary>
            <param name="columnIndex">zero-based number of column to remove specified page break</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.RemoveRowPageBreak(System.Int32)">
            <summary>
            Remove row page break from specified number of row
            </summary>
            <param name="rowIndex">zero-based number of row to remove specified page break</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.ClearColumnPageBreaks">
            <summary>
            Clear all column page breaks
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.ClearRowPageBreaks">
            <summary>
            Clear all row page breaks
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.ClearAllPageBreaks">
            <summary>
            Clear all page breaks
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Worksheet.PrintPageCounts">
            <summary>
            Get number of printable pages
            </summary>
            <returns>Number of pages</returns>
        </member>
        <member name="P:unvell.ReoGrid.Worksheet.Ranges">
            <summary>
            Virtual collection range of spreadsheet
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Worksheet.ReoGridRangeCollection">
            <summary>
            Virtual collection range of spreadsheet
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Worksheet.ReoGridRangeCollection.Item(System.String)">
            <summary>
            Retrieve logical range by specified address
            </summary>
            <param name="address">address to locate a range</param>
            <returns>range position information</returns>
        </member>
        <member name="P:unvell.ReoGrid.Worksheet.ReoGridRangeCollection.Item(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Retrieve logical range by specified address
            </summary>
            <param name="row">zero-based number of row of range</param>
            <param name="col">zero-based number of column of range</param>
            <param name="rows">number of rows contained in range</param>
            <param name="cols">number of columns contained in range</param>
            <returns>range position information</returns>
        </member>
        <member name="P:unvell.ReoGrid.Worksheet.ReoGridRangeCollection.Item(unvell.ReoGrid.CellPosition,unvell.ReoGrid.CellPosition)">
            <summary>
            Retrieve logical range by specified start cell position and end cell position
            </summary>
            <param name="startPos">start cell position of range</param>
            <param name="endPos">end cell position of range</param>
            <returns>range position information</returns>
        </member>
        <member name="P:unvell.ReoGrid.Worksheet.ReoGridRangeCollection.Item(unvell.ReoGrid.RangePosition)">
            <summary>
            Retrieve logical range by specified range position
            </summary>
            <param name="range">The range position to be get</param>
            <returns>Instance of referenced range to worksheet</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.GetRangeData(unvell.ReoGrid.RangePosition)">
            <summary>
            Get data array from specified range
            </summary>
            <param name="range">Range to get data array</param>
            <returns>Data array of range</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.DeleteRangeData(System.String)">
            <summary>
            Remove all cell's data from specified range.
            </summary>
            <param name="addressOrName">Address or name to locate range on worksheet.</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.DeleteRangeData(unvell.ReoGrid.RangePosition)">
            <summary>
            Remove all cell's data from specified range.
            </summary>
            <param name="range">Range to remove data array.</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.DeleteRangeData(unvell.ReoGrid.RangePosition,System.Boolean)">
            <summary>
            Remove all cell's data from specified range.
            </summary>
            <param name="range">Range to remove data array</param>
            <param name="checkReadonly">if this flag is set to true, the value from 
            readonly cells will not be deleted</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.SetRangeData(System.String,System.Object)">
            <summary>
            Set cell's data to fill specified range.
            </summary>
            <param name="addressOrName">Address or name to locate range on worksheet.</param>
            <param name="data">Data to be set.</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.SetRangeData(System.Int32,System.Int32,System.Int32,System.Int32,System.Object)">
            <summary>
            Set cell's data to fill specified range.
            </summary>
            <param name="row">Zero-based number of row.</param>
            <param name="col">Zero-based number of column.</param>
            <param name="rows">Number of rows in the range.</param>
            <param name="cols">Number of columns in the range.</param>
            <param name="data">Data to be set.</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.SetRangeData(unvell.ReoGrid.RangePosition,System.Object)">
            <summary>
            Set cell's data to fill specified range.
            </summary>
            <param name="range">Range position on worksheet to set the data.</param>
            <param name="data">Data to be set.</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.SetRangeData(unvell.ReoGrid.RangePosition,System.Object,System.Boolean)">
            <summary>
            Set data into specified range.
            </summary>
            <param name="range">Range to set data.</param>
            <param name="data">Data to be set into the range.</param>
            <param name="checkReadonly">Ignore to update read-only cells if this flag is true; 
            Set this flag as fasle to update all cells in specified range. (Default is true)</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.SetRangeData(unvell.ReoGrid.RangePosition,System.Data.DataTable)">
            <summary>
            Set range data copied from data table.
            </summary>
            <param name="range">Range to fill the data read from data table</param>
            <param name="table">Read data from this data table</param>
        </member>
        <member name="E:unvell.ReoGrid.Worksheet.RangeDataChanged">
            <summary>
            Event raised when entire data from a range is changed
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.FixPos(unvell.ReoGrid.CellPosition)">
            <summary>
            Check the boundary of cell position and return a safe position.
            </summary>
            <param name="pos">The cell position to check.</param>
            <returns>Safe cell position.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.FixRange(unvell.ReoGrid.RangePosition)">
            <summary>
            Check the boundary of range position and return normalized range from this worksheet.
            </summary>
            <param name="range">The range position to be checked.</param>
            <returns>Normalized range position from this worksheet.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.CheckRangeReadonly(unvell.ReoGrid.RangePosition)">
            <summary>
            Check whether or not the specified range contains any read-only cells.
            </summary>
            <remarks>
            This method ingores worksheet Readonly setting. If worksheet contains Readonly setting, 
            cells including cells data from this worksheet should not be changed. 
            To check the worksheet Readonly setting, use:
            <code>
            bool hasReadonly = worksheet.HasSettings(WorksheetSettings.Edit_Readonly);
            </code>
            </remarks>
            <param name="range">Range position to be checked.</param>
            <returns>True if the range contains read-only cells; Otherwise return false.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.ScrollToCell(System.String)">
            <summary>
            Scroll view to make the specified cell visible.
            </summary>
            <param name="address">address to locate the specified cell</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.ScrollToCell(unvell.ReoGrid.CellPosition)">
            <summary>
            Scroll view to make the specified cell visible.
            </summary>
            <param name="pos">index position to locate specified cell</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.ScrollToCell(unvell.ReoGrid.Cell)">
            <summary>
            Scroll view to make the specified cell visible.
            </summary>
            <param name="cell">cell instance to be displayed</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.ScrollToCell(System.Int32,System.Int32)">
            <summary>
            Scroll to specified cell position
            </summary>
            <param name="row">Number of row</param>
            <param name="col">Number of column</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.ScrollToRange(System.String)">
            <summary>
            Scroll view to make the specified range visible.
            </summary>
            <param name="addressOrName">address or name to locate a range</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.ScrollToRange(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Scroll view to make the specified cell visible.
            </summary>
            <param name="row">number of row</param>
            <param name="col">number of column</param>
            <param name="rows">number of rows in the range</param>
            <param name="cols">number of columns in the range</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.ScrollToRange(unvell.ReoGrid.RangePosition)">
            <summary>
            Scroll view to make the specified cell visible.
            </summary>
            <param name="range">range index to locate a range on spreadsheet</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.ScrollToRange(unvell.ReoGrid.RangePosition,unvell.ReoGrid.CellPosition)">
            <summary>
            Scroll to specified range based on a position to the range
            </summary>
            <param name="range">Range to be displayed</param>
            <param name="basePos">Base point to scroll views</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.MoveRange(System.String,System.String)">
            <summary>
            Move cells from specified range to another range.
            </summary>
            <param name="fromRangeAddress"></param>
            <param name="toRangeAddress"></param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.MoveRange(unvell.ReoGrid.RangePosition,unvell.ReoGrid.RangePosition)">
            <summary>
            Move cells from specified range to another range.
            </summary>
            <param name="fromRange">Cells moved from this range.</param>
            <param name="toRange">Cells moved to this range.</param>
            <exception cref="T:unvell.ReoGrid.CellDataReadonlyException">Throw when current worksheet is read-only.</exception>
            <exception cref="T:unvell.ReoGrid.RangeIntersectionException">Range to be moved or copied to that contains a part of another merged cell.</exception>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.MoveRange(unvell.ReoGrid.RangePosition,unvell.ReoGrid.RangePosition,unvell.ReoGrid.PartialGridCopyFlag)">
            <summary>
            Move cells from specified range to another range.
            </summary>
            <param name="fromRange">Cells moved from this range.</param>
            <param name="toRange">Cells moved to this range.</param>
            <param name="flags">Select the types of content to be moved or copied.</param>
            <exception cref="T:unvell.ReoGrid.CellDataReadonlyException">Throw when current worksheet is read-only.</exception>
            <exception cref="T:unvell.ReoGrid.RangeIntersectionException">Range to be moved or copied to that contains a part of another merged cell.</exception>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.CopyRange(System.String,System.String)">
            <summary>
            Copy content from specified range to another range.
            </summary>
            <param name="fromRangeAddress">Address to locate the range to read data.</param>
            <param name="toRangeAddress">Address to put copied data.</param>
            <exception cref="T:unvell.ReoGrid.CellDataReadonlyException">Throw when current worksheet is read-only.</exception>
            <exception cref="T:unvell.ReoGrid.RangeIntersectionException">Range to be moved or copied contains a part of another merged cell.</exception>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.CopyRange(unvell.ReoGrid.RangePosition,unvell.ReoGrid.RangePosition)">
            <summary>
            Copy content from specified range to another range.
            </summary>
            <remarks>
            The range copied from cannot be a part of another range, <para>fromRange</para> contains a part of 
            another range will cause RangeIntersectionException.
            </remarks>
            <param name="fromRange">The range to be copied from.</param>
            <param name="toRange">Target range that is used to put copied content.</param>
            <exception cref="T:unvell.ReoGrid.CellDataReadonlyException">Throw when current worksheet is read-only.</exception>
            <exception cref="T:unvell.ReoGrid.RangeIntersectionException">Range to be moved or copied contains a part of another merged cell.</exception>
            <exception cref="T:unvell.ReoGrid.RangeContainsReadonlyCellsException">Thrown when specified target range contains any read-only cell that cannot be overwritten.</exception>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.CopyRange(unvell.ReoGrid.RangePosition,unvell.ReoGrid.RangePosition,unvell.ReoGrid.PartialGridCopyFlag)">
            <summary>
            Copy content from specified range to another range.
            </summary>
            <remarks>
            The range copied from cannot be a part of another range, <para>fromRange</para> contains a part of 
            another range will cause RangeIntersectionException.
            </remarks>
            <param name="fromRange">The range to be copied from.</param>
            <param name="toRange">Target position that is used to put copied content.</param>
            <param name="flags">Content flags that specifiy the types of content to be copied. (Value of this flag can be data, borders, styles and etc.)</param>
            <exception cref="T:unvell.ReoGrid.CellDataReadonlyException">Throw when current worksheet is read-only.</exception>
            <exception cref="T:unvell.ReoGrid.RangeIntersectionException">Range to be moved or copied to that contains a part of another merged cell.</exception>
            <exception cref="T:unvell.ReoGrid.RangeContainsReadonlyCellsException">Thrown when specified target range contains any read-only cell that cannot be overwritten.</exception>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.CopyRange(unvell.ReoGrid.RangePosition,unvell.ReoGrid.RangePosition,unvell.ReoGrid.PartialGridCopyFlag,System.Boolean)">
            <summary>
            Copy content from specified range to another range.
            </summary>
            <remarks>
            The range copied from cannot be a part of another range, <para>fromRange</para> contains a part of 
            another range will cause <code>RangeIntersectionException</code>.
            Operation will be cancelled if <para>fromRange</para> is same as <para>toRange</para>
            </remarks>
            <param name="fromRange">Range to be copied from.</param>
            <param name="toRange">Target position that is used to put copied content.</param>
            <param name="flags">Content flags that specifiy the types of content to be copied. (Value of this flag can be data, borders, styles and etc.)</param>
            <param name="moveRange">Determines that whether or not to remove content from original range. Set true to move range; set false to copy range.</param>
            <exception cref="T:unvell.ReoGrid.CellDataReadonlyException">Throw when current worksheet is read-only.</exception>
            <exception cref="T:unvell.ReoGrid.RangeIntersectionException">Range to be moved or copied contains a part of another merged cell.</exception>
            <exception cref="T:unvell.ReoGrid.RangeContainsReadonlyCellsException">Thrown when specified target range contains any read-only cell that cannot be overwritten.</exception>
        </member>
        <member name="E:unvell.ReoGrid.Worksheet.BeforeRangeMove">
            <summary>
            Event raised before move a range.
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.Worksheet.BeforeRangeCopy">
            <summary>
            Event raised before copy a range.
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.Worksheet.AfterRangeMove">
            <summary>
            Event raised after move a range.
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.Worksheet.AfterRangeCopy">
            <summary>
            Event rasied after copy a range.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.ClearRangeContent(System.String,unvell.ReoGrid.CellElementFlag)">
            <summary>
            Clear content inside specified range.
            </summary>
            <param name="addressOrName">Address or name to locate the range.</param>
            <param name="flags">Elements in cell specified by this flag to be removed.</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.ClearRangeContent(unvell.ReoGrid.RangePosition,unvell.ReoGrid.CellElementFlag,System.Boolean)">
            <summary>
            Clear content inside specified range.
            </summary>
            <param name="range">The range to be clear.</param>
            <param name="flags">Elements in cell specified by this flag to be removed.</param>
            <param name="checkReadonly">True to ignore read-only cells; False to delete content from read-only cells.</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.Load(System.String)">
            <summary>
            Load grid from specified file.
            </summary>
            <param name="file">Path of file to load grid.</param>
            <exception cref="T:unvell.ReoGrid.ReoGridLoadException">Exception will be thrown if any errors happened during loading process.</exception>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.Load(System.String,System.Text.Encoding)">
            <summary>
            Load worksheet from specified input stream.
            </summary>
            <param name="file">Path of specified file to load worksheet.</param>
            <param name="encoding">Encoding used to decode plain-text if need.</param>
            <exception cref="T:unvell.ReoGrid.ReoGridLoadException">Exception will be thrown if any errors happen during loading.</exception>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.LoadRGF(System.String)">
            <summary>
            Load worksheet from specified input stream.
            </summary>
            <param name="path">Path of file to load worksheet.</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.LoadRGF(System.IO.Stream)">
            <summary>
            Load worksheet from specified input stream.
            </summary>
            <param name="s">Input stream to read worksheet.</param>
            <returns>True if spreadsheet is loaded successfully.</returns>
            <exception cref="T:unvell.ReoGrid.ReoGridLoadException">Exception will be thrown if any errors happen during loading.</exception>
        </member>
        <member name="E:unvell.ReoGrid.Worksheet.FileLoaded">
            <summary>
            Event raised when grid loaded from file.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.Save(System.String)">
            <summary>
            Save current worksheet into file.
            </summary>
            <param name="path">File path to save worksheet.</param>
            <returns>True if saving is successful; Otherwise return false.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.Save(System.String,unvell.ReoGrid.IO.FileFormat)">
            <summary>
            Save current worksheet into file.
            </summary>
            <param name="path">File path to save worksheet.</param>
            <param name="format">File format used to save worksheet. (Default is _Auto)</param>
            <returns>True if saving is successful; Otherwise return false.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.Save(System.IO.Stream,unvell.ReoGrid.IO.FileFormat)">
            <summary>
            Save current worksheet into file.
            </summary>
            <param name="stream">Stream to output worksheet.</param>
            <param name="format">File format used to save worksheet.</param>
            <returns>True if saving is successful; otherwise return false.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.SaveRGF(System.String)">
            <summary>
            Save worksheet into specified file.
            </summary>
            <param name="path">Path of file to save worksheet.</param>
            <returns>True if grid saved successfully.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.SaveRGF(System.IO.Stream)">
            <summary>
            Save worksheet as RGF format into specified output stream.
            </summary>
            <param name="s">Stream to save current worksheet.</param>
            <returns>True if worksheet is saved successfully.</returns>
            <remarks>
            Exceptions thrown if any errors happen during saving.
            </remarks>
        </member>
        <member name="E:unvell.ReoGrid.Worksheet.FileSaved">
            <summary>
            Event raised when worksheet saved into a file.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.SetRangeStyles(System.String,unvell.ReoGrid.WorksheetRangeStyle)">
            <summary>
            Set styles to each cells inside specified range
            </summary>
            <param name="addressOrName">address or name to locate the cell or range on spreadsheet</param>
            <param name="style">styles to be set</param>
            <exception cref="T:unvell.ReoGrid.InvalidAddressException">throw if specified address or name is illegal</exception>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.SetRangeStyles(System.Int32,System.Int32,System.Int32,System.Int32,unvell.ReoGrid.WorksheetRangeStyle)">
            <summary>
            Set styles to each cells inside specified range
            </summary>
            <param name="row">number of row of specified range</param>
            <param name="col">number of col of specified range</param>
            <param name="rows">number of rows inside specified range</param>
            <param name="cols">number of columns inside specified range</param>
            <param name="style">styles to be set</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.SetRangeStyles(unvell.ReoGrid.RangePosition,unvell.ReoGrid.WorksheetRangeStyle)">
            <summary>
            Set styles to each cells inside specified range
            </summary>
            <param name="range">specified range to the styles</param>
            <param name="style">styles to be set</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.SetCellStyleOwn(System.Int32,System.Int32,unvell.ReoGrid.WorksheetRangeStyle)">
            <summary>
            Set style to cell specified by row and col index
            </summary>
            <param name="row">index to row</param>
            <param name="col">index to col</param>
            <param name="style">style will be copied</param>
        </member>
        <member name="E:unvell.ReoGrid.Worksheet.RangeStyleChanged">
            <summary>
            Event raised on style of range changed
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.RemoveRangeStyles(System.String,unvell.ReoGrid.PlainStyleFlag)">
            <summary>
            Remove specified styles from a range specified by address or name
            </summary>
            <param name="addressOrName">Address or name to locate range from spreadsheet</param>
            <param name="flags">Styles specified by this flags to be removed</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.RemoveRangeStyles(unvell.ReoGrid.RangePosition,unvell.ReoGrid.PlainStyleFlag)">
            <summary>
            Remove specified styles from a specified range
            </summary>
            <param name="range">Range to be remove styles</param>
            <param name="flags">Styles specified by this flags to be removed</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.GetRangeStyles(unvell.ReoGrid.RangePosition)">
            <summary>
            Get style of specified range.
            </summary>
            <param name="range">The range to get style.</param>
            <returns>Style info of specified range.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.GetCellStyles(System.String)">
            <summary>
            Get style from cell by specified position.
            </summary>
            <param name="address">Address to locate a cell to get its style.</param>
            <returns>Style set of cell retrieved from specified position.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.GetCellStyles(unvell.ReoGrid.CellPosition)">
            <summary>
            Get style of single cell.
            </summary>
            <param name="pos">Position of cell to get.</param>
            <returns>Style of cell in the specified position.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.GetCellStyles(System.Int32,System.Int32)">
            <summary>
            Get style of specified cell without creating its instance.
            </summary>
            <param name="row">Index of row of specified cell.</param>
            <param name="col">Index of column of specified cell.</param>
            <returns>Style of cell from specified position.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.GetCellStyleItem(System.Int32,System.Int32,unvell.ReoGrid.PlainStyleFlag)">
            <summary>
            Get single style item from specified cell
            </summary>
            <param name="row">Zero-based number of row</param>
            <param name="col">Zero-based number of column</param>
            <param name="flag">Specified style item to be get</param>
            <returns>Style item value</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.UpdateCellTextBounds(unvell.ReoGrid.Cell)">
            <summary>
            Update Cell Text Bounds for View/Edit mode
            </summary>
            <param name="cell"></param>
            <param name="updateRowHeight"></param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.UpdateCellTextBounds(unvell.ReoGrid.Rendering.IRenderer,unvell.ReoGrid.Cell,unvell.ReoGrid.Rendering.DrawMode,System.Double,unvell.ReoGrid.Core.UpdateFontReason)">
            <summary>
            Update cell text bounds. 
            need to call this method when content of cell is changed, contains styles like align, font, etc.
            
            if cell's display property is null, this method does nothing.
            </summary>
            <param name="ig">The graphics device used to calculate bounds. Null to use default graphic device.</param>
            <param name="cell">The target cell will be updated.</param>
            <param name="drawMode">Draw mode</param>
            <param name="scaleFactor">Scale factor of current worksheet</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.StepRangeFont(unvell.ReoGrid.RangePosition,System.Func{System.Single,System.Single})">
            <summary>
            Make the text of cells in specified range larger or smaller.
            </summary>
            <param name="range">The spcified range.</param>
            <param name="stepHandler">Iterator callback to handle how to make text larger or smaller.</param>
        </member>
        <member name="F:unvell.ReoGrid.Worksheet.InitDefaultColumnWidth">
            <summary>
            Default width of column
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Worksheet.InitDefaultRowHeight">
            <summary>
            Default height of row
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Worksheet.DefaultCols">
            <summary>
            Default number of columns
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Worksheet.DefaultRows">
            <summary>
            Default number of rows
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Worksheet.OutlineButtonSize">
            <summary>
            Default button size of outlinetextColor buttons
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Worksheet.DefaultStyle">
            <summary>
            Default root style of entire range of grid control
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Worksheet.Workbook">
            <summary>
            Instance of workbook of this worksheet
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Worksheet.Name">
            <summary>
            Get or set the name of worksheet
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.Worksheet.NameChanged">
            <summary>
            Event raised when name of worksheet is changed
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.#ctor(unvell.ReoGrid.Workbook,System.String)">
            <summary>
            Create ReoGrid worksheet instance
            </summary>
            <param name="workbook">ReoGrid workbook instance</param>
            <param name="name">Name for this worksheet</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.#ctor(unvell.ReoGrid.Workbook,System.String,System.Int32,System.Int32)">
            <summary>
            </summary>
            <param name="workbook">ReoGrid workbook instance</param>
            <param name="name">Name for this worksheet</param>
            <param name="rows">Initial number of rows</param>
            <param name="cols">Initial number of columns</param>
        </member>
        <member name="P:unvell.ReoGrid.Worksheet.FreezeArea">
            <summary>
            Get current frozen areas. Use method <code>FreezeToCells</code> to change this property.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Worksheet.FreezePos">
            <summary>
            Get current frozen position. Use method <code>FreezeToCells</code> to change this property.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.FreezeToCell(unvell.ReoGrid.CellPosition)">
            <summary>
            Freezes worksheet at specified cell position.
            </summary>
            <param name="pos">Position to freeze worksheet.</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.FreezeToCell(System.String)">
            <summary>
            Freezes worksheet at specified address position.
            </summary>
            <param name="address">Cell position described in address string to freeze worksheet.</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.FreezeToCell(unvell.ReoGrid.CellPosition,unvell.ReoGrid.FreezeArea)">
            <summary>
            Freezes worksheet at specified cell position and specifies the freeze areas.
            </summary>
            <param name="pos">Cell position to freeze worksheet.</param>
            <param name="area">Specifies the frozen panes.</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.FreezeToCell(System.Int32,System.Int32)">
            <summary>
            Freezes worksheet at specified cell position.
            </summary>
            <param name="row">Zero-based number of row to freeze worksheet.</param>
            <param name="col">Zero-based number of column to freeze worksheet.</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.FreezeToCell(System.Int32,System.Int32,unvell.ReoGrid.FreezeArea)">
            <summary>
            Freezes worksheet at specified cell position and specifies the freeze areas.
            </summary>
            <param name="row">Zero-based number of row to freeze worksheet.</param>
            <param name="col">Zero-based number of column to freeze worksheet.</param>
            <param name="area">Specifies the frozen panes.</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.Unfreeze">
            <summary>
            Unfreeze current worksheet.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.CanFreeze">
            <summary>
            Check whether or not current worksheet can be frozen.
            </summary>
            <returns>True if current worksheet can be frozen; Otherwise return false.</returns>
        </member>
        <member name="P:unvell.ReoGrid.Worksheet.IsFrozen">
            <summary>
            Return whether or not current worksheet has frozen rows or columns.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.GetFreezePos">
            <summary>
            Get current frozen position.
            </summary>
            <returns>The cell position indicates where to freeze current worksheet.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.GetFreezePosition">
            <summary>
            Get current frozen and activated areas.
            </summary>
            <returns>Returns activated area position from current worksheet; return <code>None</code> if worksheet is not frozen.</returns>
        </member>
        <member name="E:unvell.ReoGrid.Worksheet.CellsFrozen">
            <summary>
            Event raised when worksheet is frozen.
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.Worksheet.CellsUnfrozen">
            <summary>
            Event raised when worksheet is unfreezed.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Worksheet.ScaleFactor">
            <summary>
            Get or set worksheet scale factor.
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.Worksheet.Scaled">
            <summary>
            Event raised when worksheet is scaled.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.SetScale(System.Double)">
            <summary>
            Set scale factor to zoom in/out current worksheet.
            </summary>
            <param name="factor">Scale factor to be applied.</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.ZoomIn">
            <summary>
            Zoom in current worksheet.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.ZoomOut">
            <summary>
            Zoom out current worksheet.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.ZoomReset">
            <summary>
            Set scale factor to 1.0. (Reset worksheet to original scale)
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Worksheet.Item(unvell.ReoGrid.CellPosition)">
            <summary>
            Access cells data from worksheet at specified position.
            </summary>
            <param name="pos">Position on worksheet to be access.</param>
            <returns>Cells data from worksheet at specified position.</returns>
        </member>
        <member name="P:unvell.ReoGrid.Worksheet.Item(System.Int32,System.Int32)">
            <summary>
            Access cells data on worksheet at specified position.
            </summary>
            <param name="row">Number of row of the cell to be accessed.</param>
            <param name="col">Number of column of the cell to be accessed.</param>
            <returns>Cells Data from worksheet at specified position.</returns>
        </member>
        <member name="P:unvell.ReoGrid.Worksheet.Item(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Get or set data in specified range.
            </summary>
            <param name="row">Number of start row.</param>
            <param name="col">Number of start column.</param>
            <param name="rows">Number of rows.</param>
            <param name="cols">Number of columns.</param>
            <returns></returns>
        </member>
        <member name="P:unvell.ReoGrid.Worksheet.Item(unvell.ReoGrid.RangePosition)">
            <summary>
            Get or set data from specified range.
            </summary>
            <param name="range">Range to be get or set.</param>
            <returns>Data copied from grid.</returns>
        </member>
        <member name="P:unvell.ReoGrid.Worksheet.Item(System.String)">
            <summary>
            Access cells data from worksheet at specified position or range.
            </summary>
            <example>A1 or A1:C3</example>
            <param name="addressOrName">Position specified in address code or name. (e.g. A1, A1:C3, $B$5, mydata)</param>
            <returns>Cells data returned from worksheet at specified position.</returns>
            <exception cref="T:unvell.ReoGrid.InvalidAddressException">Throw this exception if specified address or name is invalid.</exception>
        </member>
        <member name="P:unvell.ReoGrid.Worksheet.Item(unvell.ReoGrid.Cell)">
            <summary>
            Access cells data by using a cell instance.
            </summary>
            <param name="cell">Cell instance to set data.</param>
            <returns>Data returned from specifed cell instance.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.CreateAndGetCell(System.String)">
            <summary>
            Get cell from specified address. 
            If cell instance does not exist, create and return a new cell instance.
            </summary>
            <remarks>Use <code>GetCell</code> to get cell without creating new instance.</remarks>
            <param name="address">Address to create and get cell instance.</param>
            <returns>Cell instance at specified address.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.CreateAndGetCell(unvell.ReoGrid.CellPosition)">
            <summary>
            Get cell from specified cell position.
            If cell instance does not exist, create and return a new cell instance.
            </summary>
            <remarks>Use <code>GetCell</code> to get cell without creating new instance.</remarks>
            <param name="pos">Position to create and get cell instance</param>
            <returns>Cell instance at specified position.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.CreateAndGetCell(System.Int32,System.Int32)">
            <summary>
            Get cell from specified cell position.
            If cell instance does not exist, create and return a new cell instance.
            </summary>
            <remarks>Use <code>GetCell</code> to get cell without creating new instance.</remarks>
            <param name="row">Zero-based number of row to create and return cell instance.</param>
            <param name="col">Zero-based number of column to create and return cell instance.</param>
            <returns>Cell instance at specified position.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.CreateCell(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Create cell instance at specified position.
            </summary>
            <param name="row">Zero-based number of row to create and return cell instance.</param>
            <param name="col">Zero-based number ofcolumn to create and return cell instance.</param>
            <param name="updateStyle">Determines whether or not to initial the cell's style</param>
            <returns>Created cell instance at specified position.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.GetCell(System.String)">
            <summary>
            Retrieve cell instance from specified address or defined name.
            </summary>
            <param name="addressOrName">Address or name to find the cell instance.</param>
            <returns>Instance of cell retrieved from specified address or defined name, 
            return null if cell instance does not exist.</returns>
            <remarks>Use <code>CreateAndGetCell</code> to create and get cell instance.</remarks>
            <exception cref="T:unvell.ReoGrid.InvalidAddressException">Throws if specified address or name is invalid.</exception>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.GetCell(unvell.ReoGrid.CellPosition)">
            <summary>
            Retrieve cell from specified position.
            </summary>
            <param name="pos">Position to locate cell.</param>
            <returns>Null if cell instance not found at specified position.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.GetCell(System.Int32,System.Int32)">
            <summary>
            Retrieve cell at specified number of row and number of column.
            </summary>
            <param name="row">Zero-based number of row.</param>
            <param name="col">Zero-based number of column.</param>
            <returns>Null if cell instance not found at specified position.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.GetMergedCellOfRange(System.String)">
            <summary>
            Return the merged first cell inside range.
            </summary>
            <param name="address">Position in range.</param>
            <returns>First left-top cell of the range which cell belongs to.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.GetMergedCellOfRange(unvell.ReoGrid.CellPosition)">
            <summary>
            Return the merged first cell inside range.
            </summary>
            <param name="pos">Position in range.</param>
            <returns>First left-top cell of the range which cell belongs to.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.GetMergedCellOfRange(System.Int32,System.Int32)">
            <summary>
            Return the first cell inside merged range.
            </summary>
            <param name="row">Row of position in range.</param>
            <param name="col">Column of position in range.</param>
            <returns></returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.GetMergedCellOfRange(unvell.ReoGrid.Cell)">
            <summary>
            Return the first cell inside merged range.
            </summary>
            <param name="cell">Cell instance in range.</param>
            <returns>Cell instance of merged range.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.GetRangeIfMergedCell(unvell.ReoGrid.CellPosition)">
            <summary>
            Return the range if the cell specified by position is a merged cell
            </summary>
            <param name="pos">Cell of this position to be checked</param>
            <returns>Range of merged cell returned from this method</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.IsMergedCell(System.String)">
            <summary>
            Check whether the cell specified by an address is merged cell
            </summary>
            <param name="address">address to be checked</param>
            <returns>true if the cell is merged cell</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.IsMergedCell(unvell.ReoGrid.CellPosition)">
            <summary>
            Check whether the cell at specified position is a merged cell
            </summary>
            <param name="pos">position to be checked</param>
            <returns>true if the cell is merged cell</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.IsMergedCell(unvell.ReoGrid.RangePosition)">
            <summary>
            Check whether specified range does just contains one merged cell
            </summary>
            <param name="range">specified range to be checked</param>
            <returns>true if range contains only one merged cell</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.IsMergedCell(System.Int32,System.Int32)">
            <summary>
            Check whether a cell is merged cell
            </summary>
            <param name="row">number of row to be checked</param>
            <param name="col">number of column to be checked</param>
            <returns>true if the cell is merged cell</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.IsValidCell(System.String)">
            <summary>
            Check whether the specified cell is valid (Not merged by others cell)
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.IsValidCell(unvell.ReoGrid.CellPosition)">
            <summary>
            Check whether the specified cell is valid (Not merged by others cell)
            </summary>
            <param name="pos">Position to be checked</param>
            <returns>true if specified position is a valid cell</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.IsValidCell(System.Int32,System.Int32)">
            <summary>
            Check whether the specified cell is valid. (Not merged by others cell)
            </summary>
            <param name="row">Position of row to be checked.</param>
            <param name="col">Position of column to be checked.</param>
            <returns>true if specified position is valid cell.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.IsCellVisible(unvell.ReoGrid.Cell)">
            <summary>
            Check whether or not the specified cell is visible.
            </summary>
            <param name="cell">Cell instance to be checked.</param>
            <returns>True if the cell is visible; otherwise return false.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.IsCellVisible(unvell.ReoGrid.CellPosition)">
            <summary>
            Check whether or not the specified cell is visible.
            </summary>
            <param name="pos">Position to locate the cell on worksheet.</param>
            <returns>True if the cell is visible; otherwise return false.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.IsCellVisible(System.Int32,System.Int32)">
            <summary>
            Check whether or not the specified cell is visible.
            </summary>
            <param name="row">Zero-based number of row used to locate the cell.</param>
            <param name="col">Zero-based number of column used to locate the cell.</param>
            <returns>True if the cell is visible; otherwise return false.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.IsHiddenCell(unvell.ReoGrid.Cell)">
            <summary>
            Check whether a cell is on hidden row or column.
            </summary>
            <param name="cell">Instance of cell to be checked.</param>
            <returns>True if the cell is on hidden row or column.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.IsHiddenCell(unvell.ReoGrid.CellPosition)">
            <summary>
            Check whether a cell is on hidden row or column.
            </summary>
            <param name="pos">Position of cell to be checked.</param>
            <returns>True if the cell is on hidden row or column.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.IsHiddenCell(System.Int32,System.Int32)">
            <summary>
            Check whether a cell is on hidden row or column.
            </summary>
            <param name="row">Number of row to be checked.</param>
            <param name="col">Number of column to be checked.</param>
            <returns>True if the cell is on hidden row or column.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.IterateCells(System.String,System.Func{System.Int32,System.Int32,unvell.ReoGrid.Cell,System.Boolean})">
            <summary>
            Iterate over all cells in specified range. Invalid cells (merged by others cell) will be skipped.
            </summary>
            <param name="addressOrName">address or name to locate the range</param>
            <param name="iterator">callback iterator to check through all cells</param>
            <remarks>anytime return <code>false</code> to abort iteration.</remarks>
            <exception cref="T:unvell.ReoGrid.InvalidAddressException">throw if specified address or name is invalid</exception>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.IterateCells(System.String,System.Boolean,System.Func{System.Int32,System.Int32,unvell.ReoGrid.Cell,System.Boolean})">
            <summary>
            Iterate over all valid cells inside specified range. Invalid cells (merged by others cell) will be skipped.
            </summary>
            <param name="addressOrName">Address or name to locate the range on worksheet.</param>
            <param name="skipEmptyCells">Determines whether or not to skip empty cells. (Default is true)</param>
            <param name="iterator">Callback iterator to check all cells in specified range.</param>
            <remarks>Anytime return <code>false</code> to abort iteration.</remarks>
            <exception cref="T:unvell.ReoGrid.InvalidAddressException">throw if specified address or name is invalid</exception>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.IterateCells(unvell.ReoGrid.RangePosition,System.Func{System.Int32,System.Int32,unvell.ReoGrid.Cell,System.Boolean})">
            <summary>
            Iterate over all valid cells inside specified range. Invalid cells (merged by others cell) will be skipped.
            </summary>
            <param name="range">Specified range to iterate cells</param>
            <param name="iterator">callback iterator to check through all cells</param>
            <remarks>Anytime return <code>false</code> to abort iteration.</remarks>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.IterateCells(unvell.ReoGrid.RangePosition,System.Boolean,System.Func{System.Int32,System.Int32,unvell.ReoGrid.Cell,System.Boolean})">
            <summary>
            Iterate over all valid cells inside specified range. Invalid cells (merged by others cell) will be skipped.
            </summary>
            <param name="range">Specified range to iterate cells</param>
            <param name="skipEmptyCells">Determines whether or not to skip empty cells. (Default is true)</param>
            <param name="iterator">callback iterator to check through all cells</param>
            <remarks>anytime return <code>false</code> to abort iteration.</remarks>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.IterateCells(System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean,System.Func{System.Int32,System.Int32,unvell.ReoGrid.Cell,System.Boolean})">
            <summary>
            Iterate over all valid cells inside specified range. Invalid cells (merged by others cell) will be skipped.
            </summary>
            <param name="row">Number of row of the range to be iterated.</param>
            <param name="col">Number of column of the range to be iterated.</param>
            <param name="rows">Number of rows of the range to be iterated.</param>
            <param name="cols">Number of columns of the range to be iterated.</param>
            <param name="skipEmptyCells">Determines whether or not to skip empty cells.</param>
            <param name="iterator">Callback iterator to check over all cells in specified range.</param>
            <remarks>Anytime return false in iterator to abort iteration.</remarks>
        </member>
        <member name="P:unvell.ReoGrid.Worksheet.UsedRange">
            <summary>
            Get used range of this worksheet.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Worksheet.MaxContentRow">
            <summary>
            Get maximum content number of row.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Worksheet.MaxContentCol">
            <summary>
            Get maximum content number of column.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Worksheet.Cells">
            <summary>
            Get collection of cells from spreadsheet.
            
            (Careful: this method will create cell instance even there is no data and styles used in the cell,
            create many empty cell instances will spend a lot of memory. To get cell's data or style without
            creating instance use the <code>GetCellData</code> or <code>GetRangeStyle</code> API instead.)
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Worksheet.CellCollection">
            <summary>
            Collection of cell returned from range or worksheet instance.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Worksheet.CellCollection.Item(System.String)">
            <summary>
            Get cell instance by speicified reference from an address or name.
            </summary>
            <param name="addressOrName">Reference from an address or name.</param>
            <returns>Instance for cell.</returns>
        </member>
        <member name="P:unvell.ReoGrid.Worksheet.CellCollection.Item(System.Int32,System.Int32)">
            <summary>
            Get cell instance by specified number of row and column
            </summary>
            <param name="row">number of row to get cell instance</param>
            <param name="col">number of column to get cell instance</param>
            <returns>instance for cell</returns>
        </member>
        <member name="P:unvell.ReoGrid.Worksheet.CellCollection.Item(unvell.ReoGrid.CellPosition)">
            <summary>
            Get cell instance by specified position
            </summary>
            <param name="pos">position to get cell instance</param>
            <returns>instance for cell</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.CellCollection.GetEnumerator">
            <summary>
            Get enumerator
            </summary>
            <returns></returns>
        </member>
        <member name="P:unvell.ReoGrid.Worksheet.IgnoreMouseDoubleClick">
            <summary>
            When a cell body has procesed any mousedown event,
            this flag is used to notify the Control to ignore the double click event
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.Worksheet.CellMouseEnter">
            <summary>
            Event raised when mouse pointer moved into any cells
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.Worksheet.CellMouseLeave">
            <summary>
            Event rasied when mouse pointer moved out from any cells
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.Worksheet.CellMouseMove">
            <summary>
            Event raised when mouse moving over all cells
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.Worksheet.CellMouseDown">
            <summary>
            Event raised after mouse button pressed down on spreadsheet
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.Worksheet.CellMouseUp">
            <summary>
            Event raised after mouse button released up on spreadsheet
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Worksheet.FocusVisual">
            <summary>
            Get current focused visual object.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Worksheet.DropKeyUpAfterEndEdit">
            <summary>
            Sometimes when in editing mode, the Escape key used to cancel editing,
            The keyUp event of Escape to cancel editing should be ignored to pass to cell body.
            When this flag is true, the KeyUp event notify to the cell body will be ignored once.
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.Worksheet.BeforeCellKeyDown">
            <summary>
            Event raised before key pressed down on spreadsheet
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.Worksheet.AfterCellKeyDown">
            <summary>
            Event raised after key pressed down on spreadsheet
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.Worksheet.CellKeyUp">
            <summary>
            Event raised after key released up on spreadsheet
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.StartPickRangeAndCopyStyle">
            <summary>
            Start to pick a range and copy the style from selected range.
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.Worksheet.Resetted">
            <summary>
            Event raised when control resetted
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.EnableSettings(unvell.ReoGrid.WorksheetSettings)">
            <summary>
            Enable control settings
            </summary>
            <param name="settings">Setting flags to be set</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.DisableSettings(unvell.ReoGrid.WorksheetSettings)">
            <summary>
            Disable control settings
            </summary>
            <param name="settings">Settings to be removed</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.SetSettings(unvell.ReoGrid.WorksheetSettings,System.Boolean)">
            <summary>
            Set control settings
            </summary>
            <param name="settings">Setting flags to be set</param>
            <param name="value">value of setting to be set</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.HasSettings(unvell.ReoGrid.WorksheetSettings)">
            <summary>
            Determine whether specified settings have been set.
            </summary>
            <param name="setting">Setting flags to be checked.</param>
            <returns>True if all settings has setted.</returns>
        </member>
        <member name="E:unvell.ReoGrid.Worksheet.SettingsChanged">
            <summary>
            Event raisd when worksheet settings is changed.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Worksheet.IndentSize">
            <summary>
            Get or set cell's text indent size.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.ExportAsHTML(System.IO.Stream)">
            <summary>
            Export spreadsheet as html into specified stream
            </summary>
            <param name="s">Stream is used to write html content</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.ExportAsHTML(System.IO.Stream,System.String,System.Boolean)">
            <summary>
            Export spreadsheet as html into specified stream
            </summary>
            <param name="s">Stream is used to write html content</param>
            <param name="pageTitle">A string will be printed out to the html as page title</param>
            <param name="exportHeader">true to export the html headers, false to export content only inside table tag.</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.ToString">
            <summary>
            Convert to friendly string.
            </summary>
            <returns>Friendly string.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.Dispose">
            <summary>
            Dispose worksheet, release all attached resources.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.RaiseScriptEvent(System.String)">
            <summary>
            Call script's function. The function must be method of workbook object.
            </summary>
            <param name="eventName">Function name of workbook object in script.</param>
        </member>
        <member name="M:unvell.ReoGrid.Worksheet.RaiseScriptEvent(System.String,unvell.ReoScript.ObjectValue)">
            <summary>
            Call script's function. The function must be method of workbook object.
            </summary>
            <param name="eventName">Function name of workbook object in script.</param>
            <param name="eventArg">Function argument.</param>
        </member>
        <member name="T:unvell.ReoGrid.SortOrder">
            <summary>
            Sort order.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.SortOrder.Ascending">
            <summary>
            Ascending
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.SortOrder.Descending">
            <summary>
            Descending
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.HighlightRange">
            <summary>
            Highlight range reference to spreadsheet
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.HighlightRange.HighlightColor">
            <summary>
            Highlight color to display range on spreadsheet
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.HighlightRange.Hover">
            <summary>
            Decide whether this range is hover.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.CellPosition">
            <summary>
            Represents a cell position on worksheet.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.CellPosition.Row">
            <summary>
            Zero-based number of row to locate the cell on worksheet.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.CellPosition.Col">
            <summary>
            Zero-based number of column to locate the cell on worksheet.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.CellPosition.RowProperty">
            <summary>
            Determines the property (Absolute or Relative) for row position.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.CellPosition.ColumnProperty">
            <summary>
            Determines the property (Absolute or Relative) for column position.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.CellPosition.#ctor(System.Int32,System.Int32)">
            <summary>
            Create position with specified number of row and number of column.
            </summary>
            <param name="row">Zero-based number of row.</param>
            <param name="col">Zero-based number of column.</param>
        </member>
        <member name="M:unvell.ReoGrid.CellPosition.#ctor(System.String)">
            <summary>
            Create instance with alphabet code of position. (e.g. new CellPosition("A10"))
            </summary>
            <param name="address">an address string to locate the cell in spreadsheet. (e.g. 'A10')</param>
            <exception cref="T:System.ArgumentException">if address is not in correct format.</exception>
            <example>var pos = new CellPosition("A10");</example>
        </member>
        <member name="M:unvell.ReoGrid.CellPosition.ToString">
            <summary>
            Convert position to address string.
            </summary>
            <returns>String of this position.</returns>
        </member>
        <member name="M:unvell.ReoGrid.CellPosition.ToAddress">
            <summary>
            Convert position into relative address string. (format: A1)
            </summary>
            <returns>Related address in string.</returns>
            <seealso cref="M:unvell.ReoGrid.CellPosition.ToAbsoluteAddress"/>
        </member>
        <member name="M:unvell.ReoGrid.CellPosition.ToAbsoluteAddress">
            <summary>
            Convert position into absolute address string. (format: $A$1)
            </summary>
            <returns>Absolute address in string</returns>
            <seealso cref="M:unvell.ReoGrid.CellPosition.ToAddress"/>
        </member>
        <member name="M:unvell.ReoGrid.CellPosition.IsValidAddress(System.String)">
            <summary>
            Check whether or not the specified string is valid address descriptor.
            </summary>
            <param name="address">address descriptor as string to be checked.</param>
            <returns>true if specified address is valid, otherwise returning false.</returns>
        </member>
        <member name="M:unvell.ReoGrid.CellPosition.Equals(System.Object)">
            <summary>
            Compare this position to another object
            </summary>
            <param name="obj">object to be compared</param>
            <returns>true if this position is same as the specified object, otherwise false</returns>
        </member>
        <member name="M:unvell.ReoGrid.CellPosition.Equals(System.Int32,System.Int32)">
            <summary>
            Compare this position to specified number of row and number of column
            </summary>
            <param name="row">number of row to be compared</param>
            <param name="col">number of column to be compared</param>
            <returns>true if position is same to specified number of row and number of column</returns>
        </member>
        <member name="M:unvell.ReoGrid.CellPosition.Equals(System.String)">
            <summary>
            Compare position to specified address descriptor 
            </summary>
            <param name="address">address descriptor to be compared</param>
            <returns>true if position is same as the specified address descriptor, otherwise false if not</returns>
        </member>
        <member name="M:unvell.ReoGrid.CellPosition.op_Equality(unvell.ReoGrid.CellPosition,unvell.ReoGrid.CellPosition)">
            <summary>
            Compare this position to another position, return true if two positions are same.
            </summary>
            <param name="r1">this position to be compared</param>
            <param name="r2">another position to be compared</param>
            <returns>true if two positions are same, otherwise false if not</returns>
        </member>
        <member name="M:unvell.ReoGrid.CellPosition.op_Inequality(unvell.ReoGrid.CellPosition,unvell.ReoGrid.CellPosition)">
            <summary>
            Compare this position to another position, return true if two positions are different.
            </summary>
            <param name="r1">this position to be compared</param>
            <param name="r2">another position to be compared</param>
            <returns>true if two positions are different, otherwise false if not</returns>
        </member>
        <member name="M:unvell.ReoGrid.CellPosition.Equals(unvell.ReoGrid.CellPosition,unvell.ReoGrid.CellPosition)">
            <summary>
            Compare two position.
            </summary>
            <param name="pos1">first position to be compared.</param>
            <param name="pos2">second position to be compared.</param>
            <returns>true if two positions are same, otherwise false if two positions are different.</returns>
        </member>
        <member name="M:unvell.ReoGrid.CellPosition.Equals(unvell.ReoGrid.CellPosition,System.Int32,System.Int32)">
            <summary>
            Compare a position to specified number of row and number of column.
            </summary>
            <param name="pos">position to be compared.</param>
            <param name="row">number of row of another position to be compared.</param>
            <param name="col">number of column of another position to be compared.</param>
            <returns>true if the position is same as specified number of row and number of column.</returns>
        </member>
        <member name="M:unvell.ReoGrid.CellPosition.GetHashCode">
            <summary>
            Get hash code of this position.
            </summary>
            <returns>generated hash code</returns>
        </member>
        <member name="M:unvell.ReoGrid.CellPosition.Offset(unvell.ReoGrid.CellPosition)">
            <summary>
            Offset by specified another position.
            </summary>
            <param name="pos">Position indicates that how many rows and columns to offset.</param>
            <returns>Position after offset.</returns>
        </member>
        <member name="M:unvell.ReoGrid.CellPosition.Offset(System.Int32,System.Int32)">
            <summary>
            Offset by specified rows and columns.
            </summary>
            <param name="rows">Number of rows to offset.</param>
            <param name="cols">Number of columns to offset.</param>
            <returns>Position after offset.</returns>
        </member>
        <member name="M:unvell.ReoGrid.CellPosition.op_Addition(unvell.ReoGrid.CellPosition,unvell.ReoGrid.CellPosition)">
            <summary>
            Offset pos1 by number of rows and columns that is specified in pos2. (Same as method Offset)
            </summary>
            <param name="pos1">Position to be offset.</param>
            <param name="pos2">Position indicates that how many rows and columns to offset.</param>
            <returns>Position after offset.</returns>
        </member>
        <member name="M:unvell.ReoGrid.CellPosition.op_Subtraction(unvell.ReoGrid.CellPosition,unvell.ReoGrid.CellPosition)">
            <summary>
            Offset pos1 by number of rows and columns that is specified in pos2. (Same as method Offset)
            </summary>
            <param name="pos1">Position to be offset.</param>
            <param name="pos2">Position indicates that how many rows and columns to offset.</param>
            <returns>Position after offset.</returns>
        </member>
        <member name="T:unvell.ReoGrid.ReoGridPos">
            <summary>
            Zero-based two-dimensional coordinates on spreadsheet.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReoGridPos.Row">
            <summary>
            Zero-based number of row to locate the cell on worksheet
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReoGridPos.Col">
            <summary>
            Zero-based number of column to locate the cell on worksheet
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridPos.#ctor(System.Int32,System.Int32)">
            <summary>
            Create position with specified number of row and number of column
            </summary>
            <param name="row">zero-based number of row</param>
            <param name="col">zero-based number of column</param>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridPos.#ctor(System.String)">
            <summary>
            Create instance with alphabet code of position (e.g. new ReoGridPos("A10"))
            </summary>
            <param name="address">an address string to locate the cell in spreadsheet (like 'A10')</param>
            <exception cref="T:System.ArgumentException">if address is not in correct format</exception>
            <example>var pos = new ReoGridPos("A10");</example>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridPos.ToString">
            <summary>
            Convert position to address string.
            </summary>
            <returns>String of this position.</returns>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridPos.ToAddress">
            <summary>
            Convert position into related address string. (format: A1)
            </summary>
            <returns>Related address in string.</returns>
            <seealso cref="M:unvell.ReoGrid.ReoGridPos.ToAbsoluteAddress"/>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridPos.ToAbsoluteAddress">
            <summary>
            Convert position into absolute address string. (format: $A$1)
            </summary>
            <returns>Absolute address in string</returns>
            <seealso cref="M:unvell.ReoGrid.ReoGridPos.ToAddress"/>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridPos.IsValidAddress(System.String)">
            <summary>
            Check whether or not the specified string is valid address descriptor.
            </summary>
            <param name="address">address descriptor as string to be checked.</param>
            <returns>true if specified address is valid, otherwise returning false.</returns>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridPos.Equals(System.Object)">
            <summary>
            Compare this position to another object
            </summary>
            <param name="obj">object to be compared</param>
            <returns>true if this position is same as the specified object, otherwise false</returns>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridPos.Equals(System.Int32,System.Int32)">
            <summary>
            Compare this position to specified number of row and number of column
            </summary>
            <param name="row">number of row to be compared</param>
            <param name="col">number of column to be compared</param>
            <returns>true if position is same to specified number of row and number of column</returns>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridPos.Equals(System.String)">
            <summary>
            Compare position to specified address descriptor 
            </summary>
            <param name="address">address descriptor to be compared</param>
            <returns>true if position is same as the specified address descriptor, otherwise false if not</returns>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridPos.op_Equality(unvell.ReoGrid.ReoGridPos,unvell.ReoGrid.ReoGridPos)">
            <summary>
            Compare this position to another position, return true if two positions are same.
            </summary>
            <param name="r1">this position to be compared</param>
            <param name="r2">another position to be compared</param>
            <returns>true if two positions are same, otherwise false if not</returns>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridPos.op_Inequality(unvell.ReoGrid.ReoGridPos,unvell.ReoGrid.ReoGridPos)">
            <summary>
            Compare this position to another position, return true if two positions are different.
            </summary>
            <param name="r1">this position to be compared</param>
            <param name="r2">another position to be compared</param>
            <returns>true if two positions are different, otherwise false if not</returns>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridPos.Equals(unvell.ReoGrid.ReoGridPos,unvell.ReoGrid.ReoGridPos)">
            <summary>
            Compare two position.
            </summary>
            <param name="pos1">first position to be compared.</param>
            <param name="pos2">second position to be compared.</param>
            <returns>true if two positions are same, otherwise false if two positions are different.</returns>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridPos.Equals(unvell.ReoGrid.ReoGridPos,System.Int32,System.Int32)">
            <summary>
            Compare a position to specified number of row and number of column.
            </summary>
            <param name="pos">position to be compared.</param>
            <param name="row">number of row of another position to be compared.</param>
            <param name="col">number of column of another position to be compared.</param>
            <returns>true if the position is same as specified number of row and number of column.</returns>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridPos.GetHashCode">
            <summary>
            Get hash code of this position.
            </summary>
            <returns>generated hash code</returns>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridPos.Offset(unvell.ReoGrid.ReoGridPos)">
            <summary>
            Offset by specified another position.
            </summary>
            <param name="pos">Position indicates that how many rows and columns to offset.</param>
            <returns>Position after offset.</returns>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridPos.Offset(System.Int32,System.Int32)">
            <summary>
            Offset by specified rows and columns.
            </summary>
            <param name="rows">Number of rows to offset.</param>
            <param name="cols">Number of columns to offset.</param>
            <returns>Position after offset.</returns>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridPos.op_Addition(unvell.ReoGrid.ReoGridPos,unvell.ReoGrid.ReoGridPos)">
            <summary>
            Offset pos1 by number of rows and columns that is specified in pos2. (Same as method Offset)
            </summary>
            <param name="pos1">Position to be offset.</param>
            <param name="pos2">Position indicates that how many rows and columns to offset.</param>
            <returns>Position after offset.</returns>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridPos.op_Subtraction(unvell.ReoGrid.ReoGridPos,unvell.ReoGrid.ReoGridPos)">
            <summary>
            Offset pos1 by number of rows and columns that is specified in pos2. (Same as method Offset)
            </summary>
            <param name="pos1">Position to be offset.</param>
            <param name="pos2">Position indicates that how many rows and columns to offset.</param>
            <returns>Position after offset.</returns>
        </member>
        <member name="T:unvell.ReoGrid.RangePosition">
            <summary>
            Define a range on spreadsheet
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.RangePosition.Row">
            <summary>
            The start row of range
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.RangePosition.Col">
            <summary>
            The start column of range
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.RangePosition.Rows">
            <summary>
            Rows of range. (minimum is 1)
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.RangePosition.Cols">
            <summary>
            Columns of range. (minimum is 1)
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.RangePosition.EndRow">
            <summary>
            Then end row of range
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.RangePosition.EndCol">
            <summary>
            The end column of range
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.RangePosition.StartPos">
            <summary>
            The start location of range.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.RangePosition.EndPos">
            <summary>
            The end location of range.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.RangePosition.StartRowProperty">
            <summary>
            Get or set the property of start row.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.RangePosition.StartColumnProperty">
            <summary>
            Get or set the property of start column.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.RangePosition.EndRowProperty">
            <summary>
            Get or set the property of end row.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.RangePosition.EndColumnProperty">
            <summary>
            Get or set the property of end column.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.RangePosition.#ctor(unvell.ReoGrid.CellPosition,unvell.ReoGrid.CellPosition)">
            <summary>
            Create range position by specify the top left and bottom right cell position.
            </summary>
            <param name="startPos">Top left cell position to create range position.</param>
            <param name="endPos">Bottom right cell position to create range position.</param>
            <exception cref="T:System.ArgumentException">Throw when specified address is invalid.</exception>
        </member>
        <member name="M:unvell.ReoGrid.RangePosition.#ctor(unvell.ReoGrid.CellPosition)">
            <summary>
            Create range position which contains single cell position.
            </summary>
            <param name="singlePos">Cell position used to create range position.</param>
        </member>
        <member name="M:unvell.ReoGrid.RangePosition.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Create range position by specified start position and size.
            </summary>
            <param name="row">Zero-based number of row to start create range position.</param>
            <param name="col">Zero-based number of column to start create range position.</param>
            <param name="rows">Number of rows inside the range to be created. (At least one row required)</param>
            <param name="cols">Number of columns inside the range to be created. (At least one column required)</param>
        </member>
        <member name="M:unvell.ReoGrid.RangePosition.#ctor(System.String,System.String)">
            <summary>
            Create range position by specified two cell addresses. (Top left and bottom right) 
            </summary>
            <param name="startCell">Address at top left of range.</param>
            <param name="endCell">Address at bottom right of range.</param>
        </member>
        <member name="M:unvell.ReoGrid.RangePosition.#ctor(System.String)">
            <summary>
            Create range position by specified single cell address. (Range contains only one cell or one merged cell)
            </summary>
            <param name="address">Address to locate the cell contained in the range.</param>
            <exception cref="T:System.ArgumentException">Throw when specified address is invalid.</exception>
        </member>
        <member name="M:unvell.ReoGrid.RangePosition.Equals(System.Object)">
            <summary>
            Check for whether or not specified object is same as this range.
            </summary>
            <param name="obj">target range to be checked.</param>
            <returns>true if two ranges are same, otherwise return false.</returns>
        </member>
        <member name="M:unvell.ReoGrid.RangePosition.op_Equality(unvell.ReoGrid.RangePosition,unvell.ReoGrid.RangePosition)">
            <summary>
            Compare whether or not specified two ranges are same.
            </summary>
            <param name="r1">first range to be compared.</param>
            <param name="r2">second range to be compared.</param>
            <returns>true if two ranges are same, false if ranges are not same.</returns>
        </member>
        <member name="M:unvell.ReoGrid.RangePosition.op_Inequality(unvell.ReoGrid.RangePosition,unvell.ReoGrid.RangePosition)">
            <summary>
            Compare whether or not specified two ranges are same.
            </summary>
            <param name="r1">first range to be compared.</param>
            <param name="r2">second range to be compared.</param>
            <returns>true if two ranges are not same, false if ranges are same.</returns>
        </member>
        <member name="M:unvell.ReoGrid.RangePosition.GetHashCode">
            <summary>
            Calculate hash code for this range.
            </summary>
            <returns>hash code calculated for this range.</returns>
        </member>
        <member name="M:unvell.ReoGrid.RangePosition.Contains(unvell.ReoGrid.CellPosition)">
            <summary>
            Check whether the position is contained by this range.
            </summary>
            <param name="pos">Position to be checked.</param>
            <returns>true if the position is contained by this range.</returns>
        </member>
        <member name="M:unvell.ReoGrid.RangePosition.Contains(System.Int32,System.Int32)">
            <summary>
            Check whether the position specified by row and col is contained by this range.
            </summary>
            <param name="row">row of position.</param>
            <param name="col">col of position.</param>
            <returns>true if position is contained by this range.</returns>
        </member>
        <member name="M:unvell.ReoGrid.RangePosition.Contains(unvell.ReoGrid.RangePosition)">
            <summary>
            Copmpare another range and check whether or not the range is contained by this range.
            </summary>
            <param name="range">Another range to be checked.</param>
            <returns>True if the specified range is contained by this range; otherwise false.</returns>
        </member>
        <member name="M:unvell.ReoGrid.RangePosition.ContainsRow(System.Int32)">
            <summary>
            Check whether the spcified row is contained by this range.
            </summary>
            <param name="row">zero-based index of row to be checked.</param>
            <returns>true if specified row is contained by this range; otherwise false.</returns>
        </member>
        <member name="M:unvell.ReoGrid.RangePosition.ContainsColumn(System.Int32)">
            <summary>
            Check whether the specified column is contained by this range.
            </summary>
            <param name="col">zero-based index of column to be checked.</param>
            <returns>true if specified column is contained by this range; otherwise false.</returns>
        </member>
        <member name="M:unvell.ReoGrid.RangePosition.IntersectWith(unvell.ReoGrid.RangePosition)">
            <summary>
            Check whether or not specified range is intersected with current range.
            </summary>
            <param name="range">another range to be checked.</param>
            <returns>true if specified range is intersected with current range; otherwise false.</returns>
        </member>
        <member name="F:unvell.ReoGrid.RangePosition.Empty">
            <summary>
            Empty range constant define.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.RangePosition.EntireRange">
            <summary>
            Entire range constant define.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.RangePosition.IsEmpty">
            <summary>
            Return whether or not current range is empty. (Both Rows and Columns is zero)
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.RangePosition.IsEntire">
            <summary>
            Check whether or not this range contains whole rows and columns.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.RangePosition.ToString">
            <summary>
            Convert range to address string.
            </summary>
            <returns>Address string of range.</returns>
        </member>
        <member name="M:unvell.ReoGrid.RangePosition.ToRelativeAddress">
            <summary>
            Convert range into address string A1:B1 style.
            </summary>
            <returns>Address string converted from range position.</returns>
        </member>
        <member name="M:unvell.ReoGrid.RangePosition.ToAbsoluteAddress">
            <summary>
            Convert into absolute address.
            </summary>
            <returns>absolute address identifier.</returns>
        </member>
        <member name="M:unvell.ReoGrid.RangePosition.ToStringSpans">
            <summary>
            Convert range into string in span style. (4R x 3C)
            </summary>
            <returns>converted string of span style.</returns>
        </member>
        <member name="M:unvell.ReoGrid.RangePosition.Offset(System.Int32,System.Int32)">
            <summary>
            Offset range by specified number of rows and cols.
            </summary>
            <param name="rows">rows to be offseted.</param>
            <param name="cols">cols to be offseted.</param>
        </member>
        <member name="M:unvell.ReoGrid.RangePosition.IsValidAddress(System.String)">
            <summary>
            Check whether the string is a valid address in current spreadsheet.
            </summary>
            <param name="address">address to be checked.</param>
            <returns>true if address is valid.</returns>
        </member>
        <member name="P:unvell.ReoGrid.RangePosition.IsSingleCell">
            <summary>
            Identify whether this range only contains one single cell.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.RangePosition.FromCellPosition(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Create range position instance from specified four coordinates. 
            This method finds and uses the minimum and maximum row and column automatically.
            </summary>
            <param name="startRow">Number of row.</param>
            <param name="startColumn">Number of column.</param>
            <param name="endRow">Number of end row.</param>
            <param name="endColumn">Number of end column.</param>
            <returns>Range created from two cell positions.</returns>
        </member>
        <member name="M:unvell.ReoGrid.RangePosition.Union(unvell.ReoGrid.RangePosition,unvell.ReoGrid.RangePosition)">
            <summary>
            Return a range position that is the minimum range contains two specified ranges.
            </summary>
            <param name="range1">The first range position.</param>
            <param name="range2">The secondary range position.</param>
            <returns>A range that contains the two specified ranges.</returns>
        </member>
        <member name="M:unvell.ReoGrid.RangePosition.SetRows(System.Int32)">
            <summary>
            Set number of rows.
            </summary>
            <param name="rows">Number of rows.</param>
        </member>
        <member name="M:unvell.ReoGrid.RangePosition.SetCols(System.Int32)">
            <summary>
            Set number of columns.
            </summary>
            <param name="cols">Number of columns.</param>
        </member>
        <member name="T:unvell.ReoGrid.ReoGridRange">
            <summary>
            Define a range on spreadsheet
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReoGridRange.Row">
            <summary>
            The start row of range
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReoGridRange.Col">
            <summary>
            The start column of range
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReoGridRange.Rows">
            <summary>
            Rows of range. (At least 1 row)
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReoGridRange.Cols">
            <summary>
            Columns of range. (At least 1 column)
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReoGridRange.EndRow">
            <summary>
            Then end row of range
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReoGridRange.EndCol">
            <summary>
            The end column of range
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReoGridRange.StartPos">
            <summary>
            The start location of range.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReoGridRange.EndPos">
            <summary>
            The end location of range.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReoGridRange.StartRowProperty">
            <summary>
            Get or set the property of start row.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReoGridRange.StartColumnProperty">
            <summary>
            Get or set the property of start column.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReoGridRange.EndRowProperty">
            <summary>
            Get or set the property of end row.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReoGridRange.EndColumnProperty">
            <summary>
            Get or set the property of end column.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridRange.#ctor(unvell.ReoGrid.CellPosition,unvell.ReoGrid.CellPosition)">
            <summary>
            Create range position by specify the top left and bottom right cell position.
            </summary>
            <param name="startPos">Top left cell position to create range position.</param>
            <param name="endPos">Bottom right cell position to create range position.</param>
            <exception cref="T:System.ArgumentException">Throw when specified address is invalid.</exception>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridRange.#ctor(unvell.ReoGrid.CellPosition)">
            <summary>
            Create range position which contains single cell position.
            </summary>
            <param name="singlePos">Cell position used to create range position.</param>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridRange.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Create range position by specified start position and size.
            </summary>
            <param name="row">Zero-based number of row to start create range position.</param>
            <param name="col">Zero-based number of column to start create range position.</param>
            <param name="rows">Number of rows inside the range to be created. (Minimum single row required)</param>
            <param name="cols">Number of columns inside the range to be created. (Minimum single column required)</param>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridRange.#ctor(System.String,System.String)">
            <summary>
            Create range position by specified two cell addresses. (Top left and bottom right) 
            </summary>
            <param name="startCell">Address at top left of range.</param>
            <param name="endCell">Address at bottom right of range.</param>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridRange.#ctor(System.String)">
            <summary>
            Create range position by specified single cell address. (Range contains only one cell or one merged cell)
            </summary>
            <param name="address">Address to locate the cell contained in the range.</param>
            <exception cref="T:System.ArgumentException">Throw when specified address is invalid.</exception>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridRange.Equals(System.Object)">
            <summary>
            Check for whether or not specified object is same as this range
            </summary>
            <param name="obj">target range to be checked</param>
            <returns>true if two ranges are same, otherwise return false</returns>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridRange.op_Equality(unvell.ReoGrid.ReoGridRange,unvell.ReoGrid.ReoGridRange)">
            <summary>
            Compare whether or not specified two ranges are same
            </summary>
            <param name="r1">first range to be compared</param>
            <param name="r2">second range to be compared</param>
            <returns>true if two ranges are same, false if ranges are not same</returns>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridRange.op_Inequality(unvell.ReoGrid.ReoGridRange,unvell.ReoGrid.ReoGridRange)">
            <summary>
            Compare whether or not specified two ranges are same
            </summary>
            <param name="r1">first range to be compared</param>
            <param name="r2">second range to be compared</param>
            <returns>true if two ranges are not same, false if ranges are same</returns>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridRange.GetHashCode">
            <summary>
            Calculate hash code for this range
            </summary>
            <returns>hash code calculated for this range</returns>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridRange.Contains(unvell.ReoGrid.CellPosition)">
            <summary>
            Check whether the position is contained by this range
            </summary>
            <param name="pos">Position to be checked</param>
            <returns>true if the position is contained by this range</returns>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridRange.Contains(System.Int32,System.Int32)">
            <summary>
            Check whether the position specified by row and col is contained by this range
            </summary>
            <param name="row">row of position</param>
            <param name="col">col of position</param>
            <returns>true if position is contained by this range</returns>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridRange.Contains(unvell.ReoGrid.ReoGridRange)">
            <summary>
            Copmpare another range and check whether or not the range is contained by this range
            </summary>
            <param name="range">Another range to be checked</param>
            <returns>True if the specified range is contained by this range; otherwise false</returns>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridRange.ContainsRow(System.Int32)">
            <summary>
            Check whether the spcified row is contained by this range
            </summary>
            <param name="row">zero-based index of row to be checked</param>
            <returns>true if specified row is contained by this range; otherwise false</returns>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridRange.ContainsColumn(System.Int32)">
            <summary>
            Check whether the specified column is contained by this range
            </summary>
            <param name="col">zero-based index of column to be checked</param>
            <returns>true if specified column is contained by this range; otherwise false</returns>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridRange.IntersectWith(unvell.ReoGrid.ReoGridRange)">
            <summary>
            Check whether or not specified range is intersected with current range
            </summary>
            <param name="range">another range to be checked</param>
            <returns>true if specified range is intersected with current range; otherwise false</returns>
        </member>
        <member name="F:unvell.ReoGrid.ReoGridRange.Empty">
            <summary>
            Empty range constant define
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.ReoGridRange.EntireRange">
            <summary>
            Entire range constant define
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReoGridRange.IsEmpty">
            <summary>
            Return whether current range is empty
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridRange.ToString">
            <summary>
            Convert range to address string.
            </summary>
            <returns>Address string of range.</returns>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridRange.ToRelativeAddress">
            <summary>
            Convert range into address string A1:B1 style.
            </summary>
            <returns>Address string converted from range position.</returns>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridRange.ToAbsoluteAddress">
            <summary>
            Convert into absolute address
            </summary>
            <returns>absolute address identifier</returns>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridRange.ToStringSpans">
            <summary>
            Convert range into string in span style (4R x 3C)
            </summary>
            <returns>converted string of span style</returns>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridRange.Offset(System.Int32,System.Int32)">
            <summary>
            Offset range by specified number of rows and cols
            </summary>
            <param name="rows">rows to be offseted</param>
            <param name="cols">cols to be offseted</param>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridRange.IsValidAddress(System.String)">
            <summary>
            Check whether the string is a valid address in current spreadsheet
            </summary>
            <param name="address">address to be checked</param>
            <returns>true if address is valid</returns>
        </member>
        <member name="P:unvell.ReoGrid.ReoGridRange.IsSingleCell">
            <summary>
            Identify whether this range only contains one single cell
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridRange.FromCellPosition(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Create range position instance from specified four coordinates. 
            This method finds and uses the minimum and maximum row and column automatically.
            </summary>
            <param name="startRow">Number of row</param>
            <param name="startColumn">Number of column</param>
            <param name="endRow">Number of end row</param>
            <param name="endColumn">Number of end column</param>
            <returns>Range created from two cell positions</returns>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridRange.Union(unvell.ReoGrid.ReoGridRange,unvell.ReoGrid.ReoGridRange)">
            <summary>
            Union two range positions and return a new merged range.
            </summary>
            <param name="range1">The first range to be combined.</param>
            <param name="range2">The secondary range to be combined.</param>
            <returns>Return the new range combined from specified two range positions.</returns>
        </member>
        <member name="T:unvell.ReoGrid.PositionProperty">
            <summary>
            Represents the range or cell position properties.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.PositionProperty.Relative">
            <summary>
            Relative address for cell or range position.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.PositionProperty.Absolute">
            <summary>
            Absolute address for cell or range position.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.NamedRange">
            <summary>
            Named range reference to spreadsheet
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.NamedRange.Name">
            <summary>
            Name to the range
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.NamedRange.Comment">
            <summary>
            Comment for describing this range
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.NamedRange.#ctor(unvell.ReoGrid.Worksheet,System.String,System.String)">
            <summary>
            Create named range from specified worksheet and address
            </summary>
            <param name="worksheet">worksheet to hold this named range</param>
            <param name="name">name to identify this range on spreadsheet</param>
            <param name="address">address identifier to locate a range on spreadsheet</param>
        </member>
        <member name="M:unvell.ReoGrid.NamedRange.#ctor(unvell.ReoGrid.Worksheet,System.String,unvell.ReoGrid.RangePosition)">
            <summary>
            Create named range from specified worksheet and address
            </summary>
            <param name="worksheet">worksheet to hold this named range</param>
            <param name="name">name to identify this range on spreadsheet</param>
            <param name="range">address identifier to locate a range on spreadsheet</param>
        </member>
        <member name="M:unvell.ReoGrid.NamedRange.#ctor(unvell.ReoGrid.Worksheet,System.String,unvell.ReoGrid.CellPosition,unvell.ReoGrid.CellPosition)">
            <summary>
            Create named range from specified worksheet and address
            </summary>
            <param name="worksheet">worksheet to hold this named range</param>
            <param name="name">name to identify this range on spreadsheet</param>
            <param name="startPos">start position to locate range start on spreadsheet</param>
            <param name="endPos">start position to locate range end on spreadsheet</param>
        </member>
        <member name="E:unvell.ReoGrid.NamedRange.NameChanged">
            <summary>
            Event raised when name is changed
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.NamedRange.IsValidName(System.String)">
            <summary>
            Check whether or not the specified name is valid name
            </summary>
            <param name="name">Name to be checked</param>
            <returns>True if specified name is valid; otherwise return false</returns>
        </member>
        <member name="P:unvell.ReoGrid.NamedRange.Scope">
            <summary>
            Get or set the scope of named range
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.NamedRange.ToString">
            <summary>
            Convert named range to string.
            </summary>
            <returns>String to describe the named range.</returns>
        </member>
        <member name="T:unvell.ReoGrid.NamedRangeScope">
            <summary>
            Scope flags for named range
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.NamedRangeScope.Workbook">
            <summary>
            Named range is valid inside whole workbook (available for all worksheets)
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.NamedRangeScope.Worksheet">
            <summary>
            Named range is valid inside specified worksheet
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.NamedRangeCollection">
            <summary>
            Collection of named range on workbook.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.NamedRangeCollection.Add(unvell.ReoGrid.NamedRange)">
            <summary>
            Add named range instance
            </summary>
            <param name="item">range to be added</param>
        </member>
        <member name="M:unvell.ReoGrid.NamedRangeCollection.Clear">
            <summary>
            Clear all named range
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.NamedRangeCollection.Contains(unvell.ReoGrid.NamedRange)">
            <summary>
            Check whether or not specified range exists already
            </summary>
            <param name="range">Range to be checked</param>
            <returns>Return true if specified range exists; Otherwise return false</returns>
        </member>
        <member name="M:unvell.ReoGrid.NamedRangeCollection.CopyTo(unvell.ReoGrid.NamedRange[],System.Int32)">
            <summary>
            Copy named ranges into specified array
            </summary>
            <param name="array">Array to store named range</param>
            <param name="arrayIndex">Index to start copy ranges</param>
        </member>
        <member name="P:unvell.ReoGrid.NamedRangeCollection.Count">
            <summary>
            Get number of named ranges
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.NamedRangeCollection.IsReadOnly">
            <summary>
            Check whether or not to allow modify named range collection in this workbook
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.NamedRangeCollection.Remove(unvell.ReoGrid.NamedRange)">
            <summary>
            Remove specified range from named range list
            </summary>
            <param name="range">Range to be removed</param>
            <returns>Return true if specified range can be found, and removed successfully</returns>
        </member>
        <member name="M:unvell.ReoGrid.NamedRangeCollection.GetEnumerator">
            <summary>
            Get enumerator of this collection
            </summary>
            <returns>Enumerator used to iterate over this collection</returns>
        </member>
        <member name="P:unvell.ReoGrid.NamedRangeCollection.Item(System.String)">
            <summary>
            Get or set the named range by specified name.
            </summary>
            <param name="name">Name of range.</param>
            <returns>Instance of named range.</returns>
        </member>
        <member name="T:unvell.ReoGrid.ReferenceRange">
            <summary>
            Represents a range object refer to spreadsheet
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReferenceRange.Worksheet">
            <summary>
            Get or set the worksheet which contains this range
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReferenceRange.Range">
            <summary>
            Get range position.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReferenceRange.StartPos">
            <summary>
            Get or set start position.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReferenceRange.EndPos">
            <summary>
            Get or set end position.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReferenceRange.Row">
            <summary>
            Zero-based number of row to locate the start position of this range.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReferenceRange.Col">
            <summary>
            Zero-based number of column to locate the start position of this range.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReferenceRange.Column">
            <summary>
            Zero-based number of column to locate the start position of this range.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReferenceRange.Rows">
            <summary>
            Get or set number of rows.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReferenceRange.Cols">
            <summary>
            Get or set number of columns.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReferenceRange.EndRow">
            <summary>
            Get or set end number of row.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReferenceRange.EndCol">
            <summary>
            Get or set end number of column.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReferenceRange.EndColumn">
            <summary>
            Get or set end number of column.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReferenceRange.Position">
            <summary>
            Get or set the position of range on worksheet.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.ReferenceRange.Contains(unvell.ReoGrid.CellPosition)">
            <summary>
            Check whether or not the specified position is contained by this range.
            </summary>
            <param name="pos">Position to be checked.</param>
            <returns>True if specified position is contained by this range.</returns>
        </member>
        <member name="M:unvell.ReoGrid.ReferenceRange.Contains(unvell.ReoGrid.ReferenceRange)">
            <summary>
            Check whether or not a specified range is contained by this range.
            </summary>
            <param name="range">Range position to be checked.</param>
            <returns>True if the specified range is contained by this range; Otherwise return false.</returns>
        </member>
        <member name="M:unvell.ReoGrid.ReferenceRange.Contains(unvell.ReoGrid.RangePosition)">
            <summary>
            Check whether or not a specified range is contained by this range.
            </summary>
            <param name="range">Range position to be checked.</param>
            <returns>True if the specified range is contained by this range; Otherwise return false.</returns>
        </member>
        <member name="M:unvell.ReoGrid.ReferenceRange.IntersectWith(unvell.ReoGrid.RangePosition)">
            <summary>
            Check whether or not that the specified range intersects with this range.
            </summary>
            <param name="range">The range to be checked.</param>
            <returns>True if specified range intersects with this range.</returns>
        </member>
        <member name="M:unvell.ReoGrid.ReferenceRange.IntersectWith(unvell.ReoGrid.ReferenceRange)">
            <summary>
            Check whether or not that the specified range intersects with this range.
            </summary>
            <param name="range">The range to be checked.</param>
            <returns>True if specified range intersects with this range.</returns>
        </member>
        <member name="M:unvell.ReoGrid.ReferenceRange.op_Implicit(unvell.ReoGrid.ReferenceRange)~unvell.ReoGrid.RangePosition">
            <summary>
            Convert to ReoGridRange structure.
            </summary>
            <param name="refRange">The object to be converted.</param>
            <returns>ReoGridRange structure converted from reference range instance.</returns>
        </member>
        <member name="M:unvell.ReoGrid.ReferenceRange.ToString">
            <summary>
            Convert reference range into description string.
            </summary>
            <returns>String to describe this reference range.</returns>
        </member>
        <member name="M:unvell.ReoGrid.ReferenceRange.ToAddress">
            <summary>
            Convert referenced range into address position string. 
            </summary>
            <returns>Address position string to describe this range on worksheet.</returns>
        </member>
        <member name="M:unvell.ReoGrid.ReferenceRange.ToAbsoluteAddress">
            <summary>
            Convert referenced range into absolute address position string. 
            </summary>
            <returns>Absolute address position string to describe this range on worksheet.</returns>
        </member>
        <member name="P:unvell.ReoGrid.ReferenceRange.Data">
            <summary>
            Get or set data of this range.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.ReferenceRange.Select">
            <summary>
            Select this range.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReferenceRange.Style">
            <summary>
            Get the style set from this range.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReferenceRange.BorderLeft">
            <summary>
            Get or set left border styles for range.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReferenceRange.BorderTop">
            <summary>
            Get or set top border styles for range.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReferenceRange.BorderRight">
            <summary>
            Get or set right border styles for range.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReferenceRange.BorderBottom">
            <summary>
            Get or set bottom border styles for range.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReferenceRange.BorderInsideAll">
            <summary>
            Get or set all inside borders style for range.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReferenceRange.BorderInsideHorizontal">
            <summary>
            Get or set all horizontal border styles for range.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReferenceRange.BorderInsideVertical">
            <summary>
            Get or set all vertical border styles for range.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReferenceRange.BorderOutside">
            <summary>
            Get or set all outside border styles for range.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReferenceRange.BorderAll">
            <summary>
            Get or set all inside border styles for range.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.ReferenceRange.Merge">
            <summary>
            Merge this range into single cell
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.ReferenceRange.Unmerge">
            <summary>
            Unmerge this range
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReferenceRange.IsMergedCell">
            <summary>
            Determine whether or not this range contains only one merged cell
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.ReferenceRange.GroupRows">
            <summary>
            Group all rows in this range
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.ReferenceRange.GroupColumns">
            <summary>
            Group all columns in this range
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.ReferenceRange.UngroupRows">
            <summary>
            Ungroup all rows in this range
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.ReferenceRange.UngroupColumns">
            <summary>
            Ungroup all columns in this range
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReferenceRange.IsReadonly">
            <summary>
            Set or get readonly property to all cells inside this range
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReferenceRange.Cells">
            <summary>
            Get the collection of all cell instances in this range
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.ControlAppearanceColors">
            <summary>
            Key of control appearance item
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.ReoGridControlStyle">
            <summary>
            ReoGrid Control Appearance Colors
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.ControlAppearanceStyle">
            <summary>
            ReoGrid Control Appearance Colors
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.ControlAppearanceStyle.GetColor(unvell.ReoGrid.ControlAppearanceColors,unvell.ReoGrid.Graphics.SolidColor@)">
            <summary>
            Get color for appearance item
            </summary>
            <param name="colorKey">key to get the color item</param>
            <param name="color">output color get by specified key</param>
            <returns>true if color is found by specified key</returns>
        </member>
        <member name="M:unvell.ReoGrid.ControlAppearanceStyle.SetColor(unvell.ReoGrid.ControlAppearanceColors,unvell.ReoGrid.Graphics.SolidColor)">
            <summary>
            Set color for appearance item
            </summary>
            <param name="colorKey">Key of appearance item</param>
            <param name="color">Color to be set</param>
        </member>
        <member name="P:unvell.ReoGrid.ControlAppearanceStyle.Item(unvell.ReoGrid.ControlAppearanceColors)">
            <summary>
            Get or set color for appearance items
            </summary>
            <param name="colorKey"></param>
            <returns></returns>
        </member>
        <member name="M:unvell.ReoGrid.ControlAppearanceStyle.TryGetColor(unvell.ReoGrid.ControlAppearanceColors,unvell.ReoGrid.Graphics.SolidColor@)">
            <summary>
            Try get a color item from control appearance style set
            </summary>
            <param name="key">Key used to specify a item</param>
            <param name="color">Output color struction</param>
            <returns>True if key was found and color could be returned; otherwise return false</returns>
        </member>
        <member name="P:unvell.ReoGrid.ControlAppearanceStyle.SelectionBorderWidth">
            <summary>
            Get or set selection border weight
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.ControlAppearanceStyle.#ctor">
            <summary>
            Construct empty control appearance
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.ControlAppearanceStyle.#ctor(unvell.ReoGrid.Graphics.SolidColor,unvell.ReoGrid.Graphics.SolidColor,System.Boolean)">
            <summary>
            Construct control appearance with two theme colors
            </summary>
            <param name="mainTheme">Main theme color</param>
            <param name="salientTheme">Salient theme color</param>
            <param name="useSystemHighlight">Whether use highlight colors of system default</param>
        </member>
        <member name="M:unvell.ReoGrid.ControlAppearanceStyle.CreateDefaultControlStyle">
            <summary>
            Create default style for grid control.
            </summary>
            <returns>Default style created</returns>
        </member>
        <member name="T:unvell.ReoGrid.LanguageResource">
            <summary>
            Static language resources
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.LanguageResource.Filter_SortAtoZ">
            <summary>
            Text displayed on column filter. (Sort A to Z)
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.LanguageResource.Filter_SortZtoA">
            <summary>
            Text displayed on column filter (Sort Z to A)
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.LanguageResource.Filter_SelectAll">
            <summary>
            Text displayed on column filter (Select All)
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.LanguageResource.Filter_Blanks">
            <summary>
            Text of blank option in filter list. (Blanks)
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.LanguageResource.Menu_InsertSheet">
            <summary>
            Text displayed on sheet tab control (Insert)
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.LanguageResource.Menu_DeleteSheet">
            <summary>
            Text displayed on sheet tab control (Delete)
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.LanguageResource.Menu_RenameSheet">
            <summary>
            Text displayed on sheet tab control (Rename...)
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.LanguageResource.Sheet_RenameDialog_Title">
            <summary>
            Text displayed on sheet renaming dialog (Rename sheet)
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.LanguageResource.Sheet_RenameDialog_NameLabel">
            <summary>
            Label text displayed on sheet renaming dialog (Name: )
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.LanguageResource.Button_OK">
            <summary>
            Common text displayed as label of OK button (OK)
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.LanguageResource.Button_Cancel">
            <summary>
            Common text displayed as label of Cancel button (Cancel)
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.LanguageResource.Sheet">
            <summary>
            Text of word sheet (Sheet)
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Workbook.#ctor(unvell.ReoGrid.Main.IControlAdapter)">
            <summary>
            Create workbook instance
            </summary>
            <param name="adapter">Control instance adapter</param>
        </member>
        <member name="M:unvell.ReoGrid.Workbook.Clear">
            <summary>
            Clear all worksheets.
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.Workbook.WorkbookLoaded">
            <summary>
            Event raised when workbook loaded from stream or file
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.Workbook.WorkbookSaved">
            <summary>
            Event raised when workbook saved into stream or file
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Workbook.CopyWorksheet(System.Int32,System.Int32,System.String)">
            <summary>
            Duplicate worksheet and insert the new instance into specified position
            </summary>
            <param name="index">zero-based number of worksheet to be duplicated</param>
            <param name="newIndex">position used to insert duplicated new instance</param>
            <param name="newName">New name to be apply to copied worksheet</param>
            <returns>instance of duplicated worksheet from specified worksheet</returns>
        </member>
        <member name="M:unvell.ReoGrid.Workbook.CopyWorksheet(unvell.ReoGrid.Worksheet,System.Int32,System.String)">
            <summary>
            Duplicate worksheet and insert the new instance into specified position
            </summary>
            <param name="sheet">worksheet to be duplicated. The worksheet passed here should be 
            already added into current workbook.</param>
            <param name="newIndex">position used to insert duplicated new instance</param>
            <param name="newName">New name to be apply</param>
            <returns>instance of duplicated worksheet from specified worksheet</returns>
            <exception cref="T:unvell.ReoGrid.WorksheetNotFoundException">when specified worksheet does not belong to
            this workbook.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">when the position used to insert
            duplicated instace of worksheet is out of valid range of this workbook.</exception>
        </member>
        <member name="M:unvell.ReoGrid.Workbook.MoveWorksheet(System.Int32,System.Int32)">
            <summary>
            Move worksheet from a position to another position
            </summary>
            <param name="index">Worksheet in this position to be moved</param>
            <param name="newIndex">Target position moved to</param>
            <returns>Instance of moved worksheet</returns>
        </member>
        <member name="M:unvell.ReoGrid.Workbook.MoveWorksheet(unvell.ReoGrid.Worksheet,System.Int32)">
            <summary>
            Create a cloned worksheet and put into specified position
            </summary>
            <param name="sheet">Instance of worksheet to be moved, the worksheet must be already added into this workbook</param>
            <param name="newIndex">Target position moved to</param>
            <returns>New instance of copid worksheet</returns>
        </member>
        <member name="M:unvell.ReoGrid.Workbook.GetWorksheetIndex(unvell.ReoGrid.Worksheet)">
            <summary>
            Get index of specified worksheet from the collection in this workbook
            </summary>
            <param name="sheet">worksheet to be get</param>
            <returns>zero-based number of worksheet in this workbook's collection</returns>
        </member>
        <member name="M:unvell.ReoGrid.Workbook.GetWorksheetByName(System.String)">
            <summary>
            Find worksheet by specified name
            </summary>
            <param name="name">Name to find worksheet</param>
            <returns>Instance of worksheet that is found by specified name; otherwise return null</returns>
        </member>
        <member name="P:unvell.ReoGrid.Workbook.Worksheets">
            <summary>
            Collection of worksheets
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.Workbook.WorksheetCreated">
            <summary>
            Event raised when new worksheet is created
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.Workbook.WorksheetInserted">
            <summary>
            Event raised when new worksheet is inserted
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.Workbook.WorksheetRemoved">
            <summary>
            Event raised when new worksheet is removed
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.Workbook.BeforeWorksheetNameChange">
            <summary>
            Event raised before name of worksheet changing
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.Workbook.WorksheetNameChanged">
            <summary>
            Event raised when name of worksheet is changed
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Workbook.Reset">
            <summary>
            Reset a workbook to initial status (clear all worksheets and create one default)
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Workbook.SetSettings(unvell.ReoGrid.WorkbookSettings,System.Boolean)">
            <summary>
            Set settings for this workbook
            </summary>
            <param name="settings">settings to be set</param>
            <param name="value">set true to enable specified settings, false to disable</param>
        </member>
        <member name="M:unvell.ReoGrid.Workbook.GetSettings">
            <summary>
            Get current settings of workbook
            </summary>
            <returns>Workbook settings set</returns>
        </member>
        <member name="M:unvell.ReoGrid.Workbook.HasSettings(unvell.ReoGrid.WorkbookSettings)">
            <summary>
            Determine whether or not specified settings are set
            </summary>
            <param name="settings">settings to be checked</param>
            <returns>true if specified settings are set in current workbook</returns>
        </member>
        <member name="E:unvell.ReoGrid.Workbook.SettingsChanged">
            <summary>
            Event raised when workbook settings is changed
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.Workbook.ExceptionHappened">
            <summary>
            Event is used to notify if there are any internal exceptions happen on worksheets
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Workbook.NotifyExceptionHappen(unvell.ReoGrid.Worksheet,System.Exception)">
            <summary>
            Notify that there are exceptions happen on any worksheet. 
            The event ExceptionHappened of workbook will be invoked.
            </summary>
            <param name="sheet">Worksheet where the exception happened</param>
            <param name="ex">Exception to describe the details of error information</param>
        </member>
        <member name="P:unvell.ReoGrid.Workbook.Script">
            <summary>
            Script content for this control
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Workbook.srm">
            <summary>
            ReoScript Runtime Machine 
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Workbook.Srm">
            <summary>
            ReoScript Runtime Machine
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Workbook.RunScript">
            <summary>
            Run script belongs to this control
            </summary>
            <returns>Last value returned from script execution</returns>
        </member>
        <member name="M:unvell.ReoGrid.Workbook.RunScript(System.String)">
            <summary>
            Run specified script.
            </summary>
            <param name="script">Script to be executed.</param>
            <returns>Last value returned from script execution.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Workbook.InitSRM">
            <summary>
            Initial or reset Script Running Machine
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.IWorkbook">
            <summary>
            Represents an interface of workbook instance
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.IWorkbook.Save(System.String)">
            <summary>
            Save workbook into file.
            </summary>
            <param name="path">File path to create file and save workbook data.</param>
        </member>
        <member name="M:unvell.ReoGrid.IWorkbook.Save(System.String,unvell.ReoGrid.IO.FileFormat)">
            <summary>
            Save workbook into file.
            </summary>
            <param name="path">File path to create file and save workbook data.</param>
            <param name="fileFormat">Specified file format used to write data of workbook.</param>
        </member>
        <member name="M:unvell.ReoGrid.IWorkbook.Save(System.String,unvell.ReoGrid.IO.FileFormat,System.Text.Encoding)">
            <summary>
            Save workbook into file.
            </summary>
            <param name="path">File path to create file and save workbook data.</param>
            <param name="fileFormat">Specified file format used to write data of workbook.</param>
            <param name="encoding">Encoding used to write plain-text format file data. (Optional)</param>
        </member>
        <member name="M:unvell.ReoGrid.IWorkbook.Save(System.IO.Stream,unvell.ReoGrid.IO.FileFormat)">
            <summary>
            Save workbook into stream.
            </summary>
            <param name="stream">Output stream to write data of workbook.</param>
            <param name="fileFormat">Specifies the file format used to write data of workbook.</param>
        </member>
        <member name="M:unvell.ReoGrid.IWorkbook.Save(System.IO.Stream,unvell.ReoGrid.IO.FileFormat,System.Text.Encoding)">
            <summary>
            Save workbook into stream.
            </summary>
            <param name="stream">Output stream to write data of workbook.</param>
            <param name="fileFormat">Specifies the file format used to write data of workbook.</param>
            <param name="encoding">Encoding used to write plain-text from resource. (Optional)</param>
        </member>
        <member name="M:unvell.ReoGrid.IWorkbook.Load(System.String)">
            <summary>
            Load workbook from file by specified path.
            </summary>
            <param name="path">Path to locate the file and read workbook data from the file.</param>
        </member>
        <member name="M:unvell.ReoGrid.IWorkbook.Load(System.String,unvell.ReoGrid.IO.FileFormat)">
            <summary>
            Load workbook from file by specified path.
            </summary>
            <param name="path">Path to locate the file and read workbook data from the file.</param>
            <param name="fileFormat">Specified file format used to read data of workbook.</param>
        </member>
        <member name="M:unvell.ReoGrid.IWorkbook.Load(System.String,unvell.ReoGrid.IO.FileFormat,System.Text.Encoding)">
            <summary>
            Load workbook from file by specified path.
            </summary>
            <param name="path">Path to locate the file and read workbook data from the file.</param>
            <param name="fileFormat">Specified file format used to read data of workbook.</param>
            <param name="encoding">Encoding used to read plain-text format workbook data from stream. (Optional)</param>
        </member>
        <member name="M:unvell.ReoGrid.IWorkbook.Load(System.IO.Stream,unvell.ReoGrid.IO.FileFormat)">
            <summary>
            Load workbook from specified stream.
            </summary>
            <param name="stream">Input stream to read data of workbook.</param>
            <param name="fileFormat">Specified file format used to read workbook data from stream.</param>
        </member>
        <member name="M:unvell.ReoGrid.IWorkbook.Load(System.IO.Stream,unvell.ReoGrid.IO.FileFormat,System.Text.Encoding)">
            <summary>
            Load workbook from specified stream.
            </summary>
            <param name="stream">Input stream to read data of workbook.</param>
            <param name="fileFormat">Specified file format used to read workbook data from stream.</param>
            <param name="encoding">Encoding used to read plain-text format workbook data from stream. (Optional)</param>
        </member>
        <member name="E:unvell.ReoGrid.IWorkbook.WorkbookLoaded">
            <summary>
            Event raised when workbook loaded from stream or file.
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.IWorkbook.WorkbookSaved">
            <summary>
            Event raised when workbook saved into stream or file.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.IWorkbook.CreateWorksheet(System.String)">
            <summary>
            Create a new worksheet
            </summary>
            <param name="name">Name for the worksheet (null or empty name to use default sheet name)</param>
            <returns>Instance of worksheet has been created</returns>
        </member>
        <member name="M:unvell.ReoGrid.IWorkbook.InsertWorksheet(System.Int32,unvell.ReoGrid.Worksheet)">
            <summary>
            Insert worksheet into workbook before specified index
            </summary>
            <param name="index">Zero-based number of workbook to insert specified worksheet</param>
            <param name="sheet">Worksheet to be inserted</param>
        </member>
        <member name="M:unvell.ReoGrid.IWorkbook.AddWorksheet(unvell.ReoGrid.Worksheet)">
            <summary>
            Add worksheet into workbook
            </summary>
            <param name="sheet">Worksheet to be added</param>
        </member>
        <member name="M:unvell.ReoGrid.IWorkbook.RemoveWorksheet(System.Int32)">
            <summary>
            Remove specified worksheet from workbook by specified index
            </summary>
            <param name="index">Zero-based number of worksheet to be removed</param>
            <returns>True if specified worksheet can be found, and removed successfully</returns>
        </member>
        <member name="M:unvell.ReoGrid.IWorkbook.RemoveWorksheet(unvell.ReoGrid.Worksheet)">
            <summary>
            Remove specified worksheet from workbook
            </summary>
            <param name="sheet">Worksheet to be removed</param>
            <returns>True if worksheet is removed from this workbook successfully</returns>
        </member>
        <member name="M:unvell.ReoGrid.IWorkbook.GetWorksheetIndex(unvell.ReoGrid.Worksheet)">
            <summary>
            Get the index of specified worksheet from workbook
            </summary>
            <param name="sheet">Worksheet to be get</param>
            <returns>Zero-based number of worksheet in the collection</returns>
        </member>
        <member name="M:unvell.ReoGrid.IWorkbook.GetWorksheetByName(System.String)">
            <summary>
            Find worksheet by specified name
            </summary>
            <param name="name">Name to find worksheet</param>
            <returns>Instance of worksheet that is found by specified name; otherwise return null</returns>
        </member>
        <member name="M:unvell.ReoGrid.IWorkbook.CopyWorksheet(System.Int32,System.Int32,System.String)">
            <summary>
            Create a cloned worksheet and put into specified position.
            </summary>
            <param name="index">Index of source worksheet to be copied</param>
            <param name="newIndex">Target index used to insert the copied worksheet</param>
            <param name="newName">Name for new worksheet, set as null to use a default worksheet name e.g. Sheet1, Sheet2...</param>
            <returns>New instance of copid worksheet</returns>
        </member>
        <member name="M:unvell.ReoGrid.IWorkbook.CopyWorksheet(unvell.ReoGrid.Worksheet,System.Int32,System.String)">
            <summary>
            Create a cloned worksheet and put into specified position.
            </summary>
            <param name="sheet">Source worksheet to be copied, the worksheet must be already added into this workbook</param>
            <param name="newIndex">Target index used to insert the copied worksheet</param>
            <param name="newName">Name for new worksheet, set as null to use a default worksheet name e.g. Sheet1, Sheet2...</param>
            <returns>New instance of copid worksheet</returns>
        </member>
        <member name="M:unvell.ReoGrid.IWorkbook.MoveWorksheet(System.Int32,System.Int32)">
            <summary>
            Move worksheet from a position to another position
            </summary>
            <param name="index">Worksheet in this position to be moved</param>
            <param name="newIndex">Target position moved to</param>
            <returns>Instance of moved worksheet</returns>
        </member>
        <member name="M:unvell.ReoGrid.IWorkbook.MoveWorksheet(unvell.ReoGrid.Worksheet,System.Int32)">
            <summary>
            Create a cloned worksheet and put into specified position
            </summary>
            <param name="sheet">Instance of worksheet to be moved, the worksheet must be already added into this workbook</param>
            <param name="newIndex">Target position moved to</param>
            <returns>Instance of moved worksheet</returns>
        </member>
        <member name="P:unvell.ReoGrid.IWorkbook.Worksheets">
            <summary>
            Get the collection of worksheets
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.IWorkbook.Readonly">
            <summary>
            Determine whether or not this workbook is read-only
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.IWorkbook.Reset">
            <summary>
            Reset this workbook (Clear all worksheets and put one new)
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.IWorkbook.WorksheetCreated">
            <summary>
            Event raised when worksheet is created.
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.IWorkbook.WorksheetInserted">
            <summary>
            Event raised when worksheet is inserted into this workbook.
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.IWorkbook.WorksheetRemoved">
            <summary>
            Event raised when worksheet is removed from this workbook.
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.IWorkbook.WorksheetNameChanged">
            <summary>
            Event raised when name of worksheet is changed.
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.IWorkbook.ExceptionHappened">
            <summary>
            Event raised when exception has been happened during internal processed.
            Usually these internal processes are raised by hot-keys pressed by user.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.IWorkbook.NotifyExceptionHappen(unvell.ReoGrid.Worksheet,System.Exception)">
            <summary>
            Notify that there are exceptions happen on any worksheet. 
            The event ExceptionHappened of workbook will be invoked.
            </summary>
            <param name="sheet">Worksheet where the exception happened</param>
            <param name="ex">Exception to describe the details of error information</param>
        </member>
        <member name="T:unvell.ReoGrid.WorksheetCollection">
            <summary>
            Collection of Worksheet 
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.WorksheetCollection.Create(System.String)">
            <summary>
            Create worksheet by specified name
            </summary>
            <param name="name">Unique name used to identify the worksheet</param>
            <returns>Instance of worksheet created by specified name</returns>
        </member>
        <member name="M:unvell.ReoGrid.WorksheetCollection.Add(unvell.ReoGrid.Worksheet)">
            <summary>
            Add worksheet
            </summary>
            <param name="sheet">Worksheet to be added</param>
        </member>
        <member name="M:unvell.ReoGrid.WorksheetCollection.Insert(System.Int32,unvell.ReoGrid.Worksheet)">
            <summary>
            Insert worksheet at specified position
            </summary>
            <param name="index">Zero-based number of worksheet to insert the worksheet</param>
            <param name="sheet">Worksheet to be inserted</param>
        </member>
        <member name="M:unvell.ReoGrid.WorksheetCollection.Clear">
            <summary>
            Clear all worksheet from this workbook
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.WorksheetCollection.Contains(unvell.ReoGrid.Worksheet)">
            <summary>
            Check whether or not specified worksheet is contained in this workbook
            </summary>
            <param name="sheet"></param>
            <returns></returns>
        </member>
        <member name="P:unvell.ReoGrid.WorksheetCollection.Count">
            <summary>
            Get number of worksheets in this workbook
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.WorksheetCollection.IsReadOnly">
            <summary>
            Check whether or not current workbook is read-only
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.WorksheetCollection.Remove(unvell.ReoGrid.Worksheet)">
            <summary>
            Remove worksheet instance
            </summary>
            <param name="sheet">Instace of worksheet to be removed</param>
            <returns></returns>
        </member>
        <member name="M:unvell.ReoGrid.WorksheetCollection.GetEnumerator">
            <summary>
            Get enumerator of worksheet list
            </summary>
            <returns>Enumerator of worksheet list</returns>
        </member>
        <member name="M:unvell.ReoGrid.WorksheetCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Get enumerator of worksheet list
            </summary>
            <returns>Enumerator of worksheet list</returns>
        </member>
        <member name="P:unvell.ReoGrid.WorksheetCollection.Item(System.Int32)">
            <summary>
            Get or set worksheet by specified position
            </summary>
            <param name="index">Zero-based number of worksheet</param>
            <returns>Instance of worksheet found at specified position</returns>
        </member>
        <member name="P:unvell.ReoGrid.WorksheetCollection.Item(System.String)">
            <summary>
            Get worksheet by specified name.
            </summary>
            <param name="name">Name to find worksheet</param>
            <returns>Instacne of worksheet found by specified name</returns>
        </member>
        <member name="M:unvell.ReoGrid.WorksheetCollection.IndexOf(unvell.ReoGrid.Worksheet)">
            <summary>
            Get the index position of specified worksheet
            </summary>
            <param name="sheet">Instace of worksheet</param>
            <returns>Zero-based number of worksheet</returns>
        </member>
        <member name="M:unvell.ReoGrid.WorksheetCollection.RemoveAt(System.Int32)">
            <summary>
            Remove worksheet from specified position
            </summary>
            <param name="index">Zero-based number of worksheet to locate the worksheet to be removed</param>
        </member>
        <member name="M:unvell.ReoGrid.WorksheetCollection.CopyTo(unvell.ReoGrid.Worksheet[],System.Int32)">
            <summary>
            Copy all worksheet instances into specified array
            </summary>
            <param name="array">Array used to store worksheets</param>
            <param name="arrayIndex">Start index to copy the worksheets</param>
        </member>
        <member name="T:unvell.ReoGrid.Print.PrintSession">
            <summary>
            Represents a print session to print worksheets.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Print.PrintSession.CurrentWorksheetIndex">
            <summary>
            Get or set the zero-based index of current worksheet.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Print.PrintSession.CurrentWorksheet">
            <summary>
            Get current worksheet instance.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Print.PrintSession.IsPrinting">
            <summary>
            Get whether current is in the operation of print or preview
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Print.PrintSession.Print">
            <summary>
            Start output document to printer.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Print.PrintSettings">
            <summary>
            Print settings for spreadsheet.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Print.PrintSettings.PrinterName">
            <summary>
            Get or set the name of output printer. (Null to use system default printer)
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Print.PrintSettings.PageOrder">
            <summary>
            Determine the orientation to output the print pages.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Print.PrintSettings.ShowMargins">
            <summary>
            Determine whether or not to show the paper margins during preview and print.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Print.PrintSettings.ShowGridLines">
            <summary>
            Determines whether or not print grid lines.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Print.PrintSettings.PageScaling">
            <summary>
            Scale factor for printing each pages (0.1f - 4f).
            This property might be changed by adjusting the break lines automatically.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Print.PrintSettings.PaperName">
            <summary>
            Get or set the name of this paper type.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Print.PrintSettings.Landscape">
            <summary>
            Determine the paper orientation (landscape or portrait).
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Print.PrintSettings.PaperWidth">
            <summary>
            Get or set the width of the paper, in hundredths of an inch. (only available when PaperSize is custom)
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Print.PrintSettings.PaperHeight">
            <summary>
            Get or set the height of the paper, in hundredths of an inch. (only available when PaperSize is custom)
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Print.PrintSettings.Margins">
            <summary>
            Get or set the paper margins.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Print.PrintSettings.#ctor">
            <summary>
            Construct print settings instance.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Print.PrintSettings.Clone">
            <summary>
            Create a copy of current print settings object.
            </summary>
            <returns>Cloned print settings object.</returns>
        </member>
        <member name="T:unvell.ReoGrid.Print.PageMargins">
            <summary>
            Page margin values (in hundredths of an inch)
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Print.PageMargins.Top">
            <summary>
            Get or set top margin (in hundredths of an inch)
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Print.PageMargins.Bottom">
            <summary>
            Get or set bottom margin (in hundredths of an inch)
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Print.PageMargins.Left">
            <summary>
            Get or set left margin (in hundredths of an inch)
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Print.PageMargins.Right">
            <summary>
            Get or set right margin (in hundredths of an inch)
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Print.PageMargins.#ctor(System.Double)">
            <summary>
            Create and set all values with same value
            </summary>
            <param name="all">Value applied to all margins</param>
        </member>
        <member name="M:unvell.ReoGrid.Print.PageMargins.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Create with every specified values
            </summary>
            <param name="top">Top margin</param>
            <param name="bottom">Bottom margin</param>
            <param name="left">Left margin</param>
            <param name="right">Right margin</param>
        </member>
        <member name="F:unvell.ReoGrid.Print.PageMargins.Empty">
            <summary>
            Predefined empty margin values (All zero)
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Print.PageMargins.op_Equality(unvell.ReoGrid.Print.PageMargins,unvell.ReoGrid.Print.PageMargins)">
            <summary>
            Compare two margin values whether are same
            </summary>
            <param name="p1">Margin value 1 to be compared</param>
            <param name="p2">Margin value 2 to be compared</param>
            <returns>True if two margin values are same; otherwise return false</returns>
        </member>
        <member name="M:unvell.ReoGrid.Print.PageMargins.op_Inequality(unvell.ReoGrid.Print.PageMargins,unvell.ReoGrid.Print.PageMargins)">
            <summary>
            Compare two margin values whether are not same
            </summary>
            <param name="p1">Margin value 1 to be compared</param>
            <param name="p2">Margin  value 2 to be compared</param>
            <returns>True if two margin values are not same; otherwise return false</returns>
        </member>
        <member name="M:unvell.ReoGrid.Print.PageMargins.Equals(System.Object)">
            <summary>
            Compare an object and check whether two margin value are same
            </summary>
            <param name="obj">Another object to be checked</param>
            <returns>True if two margin values are same; otherwise return false</returns>
        </member>
        <member name="M:unvell.ReoGrid.Print.PageMargins.GetHashCode">
            <summary>
            Get hash code of this object
            </summary>
            <returns>Hash code</returns>
        </member>
        <member name="M:unvell.ReoGrid.Print.PageMargins.op_Implicit(unvell.ReoGrid.Print.PageMargins)~System.Drawing.Printing.Margins">
            <summary>
            Convert to Windows Form Margins type
            </summary>
            <param name="pv"></param>
            <returns></returns>
        </member>
        <member name="M:unvell.ReoGrid.Print.PageMargins.op_Implicit(System.Drawing.Printing.Margins)~unvell.ReoGrid.Print.PageMargins">
            <summary>
            Convert from Windows Form Margins type
            </summary>
            <param name="m"></param>
            <returns></returns>
        </member>
        <member name="T:unvell.ReoGrid.Print.PaperManager">
            <summary>
            Manages the paper size list for printing spreadsheet.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Print.PaperManager.PaperSizesInch">
            <summary>
            Collection of paper size.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Print.PaperSize">
            <summary>
            Perdefiend paper size
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Print.PaperSize.Auto">
            <summary>
            Detect the default paper size from specified printer
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Print.PaperSize.Letter">
            <summary>
            ANSI Letter (8.5 x 11 inches, 216 mm x 279 mm)
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Print.PaperSize.Custom">
            <summary>
            Specify to use customize pager size
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Print.PrintPageOrder">
            <summary>
            Paging order decide print each pages in what order
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Print.PrintPageOrder.DownThenOver">
            <summary>
            First down, then over (Vertical Paging) (Default)
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Print.PrintPageOrder.OverThenDown">
            <summary>
            First over, then down (Horizontal Paging)
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Drawing.WorksheetDrawingCanvas.OnPaint(unvell.ReoGrid.Rendering.DrawingContext)">
            <summary>
            Worksheet Drawing Canvas alwayas keep transparent and doesn't draw anything from itself
            </summary>
            <param name="dc">Platform no-associated drawing context instance.</param>
        </member>
        <member name="T:unvell.ReoGrid.Drawing.FloatingDrawingContext">
            <summary>
            Represents the floating objects drawing context.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Drawing.FloatingDrawingContext.CurrentObject">
            <summary>
            Get the current drawing object.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Drawing.MouseEventArgs">
            <summary>
            Represents mouse event arguments.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Drawing.MouseEventArgs.Location">
            <summary>
            Get the location of mouse event happened.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Drawing.MouseEventArgs.Buttons">
            <summary>
            Get mouse button press-down status of mouse event.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Drawing.MouseEventArgs.#ctor(unvell.ReoGrid.Graphics.Point,unvell.ReoGrid.Interaction.MouseButtons)">
            <summary>
            Create an instance of mouse event arguments.
            </summary>
            <param name="location">The location of mouse event happened.</param>
            <param name="buttons">The mouse button press-down status of mous event happened.</param>
        </member>
        <member name="T:unvell.ReoGrid.Drawing.KeyboardEventArgs">
            <summary>
            Keyboard event arguments
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Drawing.KeyboardEventArgs.Keys">
            <summary>
            Get the merged key press-down status code
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Drawing.KeyboardEventArgs.#ctor(unvell.ReoGrid.Interaction.KeyCode)">
            <summary>
            Create an instance of keyboard event arguments
            </summary>
            <param name="keys">The key of user pressed down when event happening</param>
        </member>
        <member name="T:unvell.ReoGrid.Drawing.Shapes.ShapeObject">
            <summary>
            Represents an abstract shape drawing object.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Drawing.Shapes.ShapeObject.Text">
            <summary>
            Get or set the text displayed inside this shape.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Drawing.Shapes.ShapeObject.Style">
            <summary>
            Get style object.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Drawing.Shapes.ShapeObject.TextBounds">
            <summary>
            Get the text bounds for display text inside this shape.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Drawing.Shapes.ShapeObject.OnPaint(unvell.ReoGrid.Rendering.DrawingContext)">
            <summary>
            Render shape object to graphics context.
            </summary>
            <param name="dc">Platform no-associated drawing context instance.</param>
        </member>
        <member name="M:unvell.ReoGrid.Drawing.Shapes.ShapeObject.OnPaintText(unvell.ReoGrid.Rendering.DrawingContext)">
            <summary>
            Paint text inside this shape.
            </summary>
            <param name="dc">Instance of cross-platform drawing context.</param>
        </member>
        <member name="T:unvell.ReoGrid.Drawing.Shapes.IDrawingShapeObjectStyle">
            <summary>
            Interface of drawing shape object.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Drawing.Shapes.IDrawingShapeObjectStyle.TextColor">
            <summary>
            Get or set the color of text.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Drawing.Shapes.IDrawingShapeObjectStyle.HorizontalAlignment">
            <summary>
            Get or set the horizontal alignment for text.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Drawing.Shapes.IDrawingShapeObjectStyle.VerticalAlignment">
            <summary>
            Get or set the vertical alignment for text.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Drawing.Shapes.DrawingShapeObjectStyle">
            <summary>
            Represents style object for shape object.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Drawing.Shapes.DrawingShapeObjectStyle.ShapeObject">
            <summary>
            Get the instance of owner drawing object.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Drawing.Shapes.DrawingShapeObjectStyle.TextColor">
            <summary>
            Get or set the text color.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Drawing.Shapes.Line">
            <summary>
            Represents straight line connection.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Drawing.Shapes.Line.StartPoint">
            <summary>
            Get or set the start position.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Drawing.Shapes.Line.EndPoint">
            <summary>
            Get or set the end position.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Drawing.Shapes.Line.UpdateBoundsByTwoPoints">
            <summary>
            Update bounds by start and end positions.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Drawing.Shapes.Line.Draw(unvell.ReoGrid.Rendering.DrawingContext)">
            <summary>
            Render line object to graphics context.
            </summary>
            <param name="dc">Platform no-associated drawing context instance.</param>
        </member>
        <member name="P:unvell.ReoGrid.Drawing.Shapes.Line.Style">
            <summary>
            Get line style object.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Drawing.Shapes.RectangleShape">
            <summary>
            Represents regular rectangle drawing object.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Drawing.Shapes.EllipseShape">
            <summary>
            Represents ellipse shape object.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Drawing.Shapes.EllipseShape.OnPaint(unvell.ReoGrid.Rendering.DrawingContext)">
            <summary>
            Render ellipse shape to graphics context.
            </summary>
            <param name="dc">Platform no-associated drawing context.</param>
        </member>
        <member name="T:unvell.ReoGrid.Drawing.IDrawingObject">
            <summary>
            Represents interface of drawing objects.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Drawing.IDrawingObject.ClientBounds">
            <summary>
            Get or set the client bounds of drawing object.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Drawing.IDrawingObject.ScaleX">
            <summary>
            Get or set horizontal scaling of drawing object.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Drawing.IDrawingObject.ScaleY">
            <summary>
            Get or set vertical scaling of drawing object.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Drawing.IDrawingObject.RotateAngle">
            <summary>
            Get or set the rotation angle of drawing object.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Drawing.IDrawingObject.Container">
            <summary>
            Get or set the container of drawing object.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Drawing.IDrawingObject.Style">
            <summary>
            Access the style set of drawing object.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Drawing.IDrawingObject.Draw(unvell.ReoGrid.Rendering.DrawingContext)">
            <summary>
            Render this drawing object.
            </summary>
            <param name="dc">Platform no-associated drawing context instance.</param>
        </member>
        <member name="T:unvell.ReoGrid.Drawing.IDrawingObjectCollection">
            <summary>
            Represents collection of drawing object.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Drawing.IFloatingObject">
            <summary>
            Represents an floating object above worksheet
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Drawing.IFloatingObject.Bounds">
            <summary>
            Get or set the bounds relative to the container of this floating object.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Drawing.IFloatingObject.X">
            <summary>
            Get or set the position on X-coordinate.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Drawing.IFloatingObject.Y">
            <summary>
            Get or set the position on Y-coordinate.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Drawing.IFloatingObject.Location">
            <summary>
            Get or set position on both X and Y coordinates.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Drawing.IFloatingObject.Left">
            <summary>
            Get left position of bounds relative to the container of this floating object.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Drawing.IFloatingObject.Right">
            <summary>
            Get right position of bounds relative to the container of this floating object.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Drawing.IFloatingObject.Top">
            <summary>
            Get top position of bounds relative to the container of this floating object.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Drawing.IFloatingObject.Bottom">
            <summary>
            Get bottom position of bounds relative to the container of this floating object.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Drawing.IFloatingObject.Size">
            <summary>
            Get or set size of this floating object.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Drawing.IFloatingObject.Width">
            <summary>
            Get and set the width of this floating object.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Drawing.IFloatingObject.Height">
            <summary>
            Get or set the height of this floating object.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Drawing.IFloatingObject.OnBoundsChanged(unvell.ReoGrid.Graphics.Rectangle)">
            <summary>
            Method invoked when Bounds property changed.
            </summary>
            <param name="oldRect">Previous bounds value before changing.</param>
        </member>
        <member name="T:unvell.ReoGrid.Drawing.IFloatingObjectCollection`1">
            <summary>
            Collection of floating object
            </summary>
            <typeparam name="T">Type inherts from <seealso>IFloattingObject</seealso></typeparam>
        </member>
        <member name="P:unvell.ReoGrid.Drawing.IFloatingObjectCollection`1.Item(System.Int32)">
            <summary>
            Access element from collection
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:unvell.ReoGrid.Drawing.IFloatingObjectCollection`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Add all elements from another collection
            </summary>
            <param name="drawingObjects"></param>
        </member>
        <member name="T:unvell.ReoGrid.Drawing.HorizontalAlignment">
            <summary>
            Represents the horizontal alignment for drawing objects.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Drawing.VerticalAlignment">
            <summary>
            Represents the vertical alignment for drawing objects.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Drawing.IDrawingObjectStyle">
            <summary>
            Represents the interface of drawing object style set.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Drawing.IDrawingObjectStyle.FillColor">
            <summary>
            Get or set fill background color.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Drawing.IDrawingObjectStyle.LineColor">
            <summary>
            Get or set line color.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Drawing.IDrawingObjectStyle.LineWidth">
            <summary>
            Get or set line width.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Drawing.IDrawingObjectStyle.LineStyle">
            <summary>
            Get or set line style.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Drawing.IDrawingLineObjectStyle">
            <summary>
            Represents the interface of line object style.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Drawing.IDrawingLineObjectStyle.StartCap">
            <summary>
            Get or set the start cap style.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Drawing.IDrawingLineObjectStyle.EndCap">
            <summary>
            Get or set the end cap style.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Drawing.IDrawingComponentStyle">
            <summary>
            Represents the interface of drawing component style.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Drawing.IDrawingComponentStyle.Padding">
            <summary>
            Get or set padding.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Drawing.DrawingObjectStyle">
            <summary>
            Represents the implementation of drawing objects style set.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Drawing.DrawingObjectStyle.OwnerObject">
            <summary>
            Get the instance of owner drawing object.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Drawing.DrawingObjectStyle.FillColor">
            <summary>
            Get or set fill background color.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Drawing.DrawingObjectStyle.LineColor">
            <summary>
            Get or set line color.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Drawing.DrawingObjectStyle.LineWidth">
            <summary>
            Get or set line width.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Drawing.DrawingObjectStyle.LineStyle">
            <summary>
            Get or set line style.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Drawing.DrawingComponentStyle">
            <summary>
            Represents 
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Drawing.DrawingComponentStyle.Padding">
            <summary>
            Get or set padding.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Drawing.Text.FontStyles">
            <summary>
            Font style
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Drawing.Text.FontStyles.Regular">
            <summary>
            Regular
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Drawing.Text.FontStyles.Bold">
            <summary>
            Bold
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Drawing.Text.FontStyles.Italic">
            <summary>
            Italic
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Drawing.Text.FontStyles.Underline">
            <summary>
            Underline
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Drawing.Text.FontStyles.Strikethrough">
            <summary>
            Strikethrough
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Drawing.IDrawingContainer">
            <summary>
            Represents container of drawing objects.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Drawing.IDrawingContainer.Children">
            <summary>
            Collection of children objects in this container
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Drawing.IDrawingContainer.ClipBounds">
            <summary>
            Clip bounds for rendering final object
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Drawing.IDrawingContainer.OnChildAdded(unvell.ReoGrid.Drawing.IDrawingObject,System.Int32)">
            <summary>
            Method invoked when child object added.
            </summary>
            <param name="child">Instance of child object has been added.</param>
            <param name="index">The index of child object in container.</param>
        </member>
        <member name="M:unvell.ReoGrid.Drawing.IDrawingContainer.OnChildRemoved(unvell.ReoGrid.Drawing.IDrawingObject,System.Int32)">
            <summary>
            Method invoked when child object removed from container.
            </summary>
            <param name="child">Instance of child object has been removed.</param>
            <param name="index">The index of child object in container.</param>
        </member>
        <member name="M:unvell.ReoGrid.Drawing.IDrawingContainer.OnChildrenClear">
            <summary>
            Method invoked when all child objects has been removed.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Drawing.DrawingComponent">
            <summary>
            Represents drawing component object that contains others drawing objects.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Drawing.DrawingComponent.ClipBounds">
            <summary>
            Get or set the clip bounds to render final object
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Drawing.DrawingComponent.OnPaint(unvell.ReoGrid.Rendering.DrawingContext)">
            <summary>
            Render drawing object to graphics context.
            </summary>
            <param name="dc">Platform no-associated drawing context instance.</param>
        </member>
        <member name="M:unvell.ReoGrid.Drawing.DrawingComponent.DrawChildren(unvell.ReoGrid.Rendering.DrawingContext)">
            <summary>
            Render children objects to graphics context.
            </summary>
            <param name="dc">Platform no-associated drawing context instance.</param>
        </member>
        <member name="P:unvell.ReoGrid.Drawing.DrawingComponent.Style">
            <summary>
            Get style object.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Drawing.FloatingObject">
            <summary>
            Represents basic drawing object.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Drawing.FloatingObject.#ctor">
            <summary>
            Create drawing object instance.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Drawing.FloatingObject.X">
            <summary>
            Get or set X position.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Drawing.FloatingObject.Y">
            <summary>
            Get or set Y position.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Drawing.FloatingObject.Location">
            <summary>
            Get or set object position.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Drawing.FloatingObject.Width">
            <summary>
            Get or set width.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Drawing.FloatingObject.Height">
            <summary>
            Get or set height.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Drawing.FloatingObject.Left">
            <summary>
            Get left position. (x-coordinate)
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Drawing.FloatingObject.Top">
            <summary>
            Get top position. (y-coordinate)
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Drawing.FloatingObject.Right">
            <summary>
            Get right position. (x-coordinate)
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Drawing.FloatingObject.Bottom">
            <summary>
            Get bottom position. (y-coordinate)
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Drawing.FloatingObject.Size">
            <summary>
            Get or set size.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Drawing.FloatingObject.Bounds">
            <summary>
            Get bounds position relative to object container.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Drawing.FloatingObject.OnBoundsChanged(unvell.ReoGrid.Graphics.Rectangle)">
            <summary>
            This method will be invoked when bounds of drawing object is changed.
            </summary>
            <param name="oldRect"></param>
        </member>
        <member name="M:unvell.ReoGrid.Drawing.FloatingObject.GetPreferredSize">
            <summary>
            Get preferred size of drawing object. (Default is 160x100)
            </summary>
            <returns></returns>
        </member>
        <member name="E:unvell.ReoGrid.Drawing.FloatingObject.MouseDown">
            <summary>
            Event raised when mouse pressed down inside this drawing object.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Drawing.FloatingObject.OnMouseDown(unvell.ReoGrid.Graphics.Point,unvell.ReoGrid.Interaction.MouseButtons)">
            <summary>
            This method will be invoked when mouse button pressed down inside drawing object.
            </summary>
            <param name="location">Location relateved to drawing object.</param>
            <param name="buttons">Mouse button pressing status.</param>
            <returns>True if event has been handled; otherwise return false.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Drawing.FloatingObject.OnMouseMove(unvell.ReoGrid.Graphics.Point,unvell.ReoGrid.Interaction.MouseButtons)">
            <summary>
            This method will be invoked when mouse moving inside drawing object.
            </summary>
            <param name="location">Location relateved to drawing object.</param>
            <param name="buttons">Mouse button pressing status.</param>
            <returns>True if event has been handled; otherwise return false.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Drawing.FloatingObject.OnMouseUp(unvell.ReoGrid.Graphics.Point,unvell.ReoGrid.Interaction.MouseButtons)">
            <summary>
            This method will be invoked when mouse button released inside drawing object.
            </summary>
            <param name="location">Location relateved to drawing object.</param>
            <param name="buttons">Mouse button pressing status.</param>
            <returns>True if event has been handled; otherwise return false.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Drawing.FloatingObject.OnMouseDoubleClick(unvell.ReoGrid.Graphics.Point,unvell.ReoGrid.Interaction.MouseButtons)">
            <summary>
            This method will be invoked when mouse button double clicked inside drawing object.
            </summary>
            <param name="location">Location relateved to drawing object.</param>
            <param name="buttons">Mouse button pressing status.</param>
            <returns>True if event has been handled; otherwise return false.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Drawing.FloatingObject.OnKeyDown(unvell.ReoGrid.Interaction.KeyCode)">
            <summary>
            This method will be invoked when keyboard is pressed when drawing object is focused.
            </summary>
            <param name="keys">Virtual keyboard code to determine that which key is being pressed by user.</param>
            <returns>True if event has been handled; otherwise return false.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Drawing.FloatingObject.SetFocus">
            <summary>
            Make drawing object getting focus.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Drawing.FloatingObject.FreeFocus">
            <summary>
            Make drawing object losing focus.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Drawing.SelectableFloatingObject">
            <summary>
            Represents user intervatable floating object.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Drawing.SelectableFloatingObject.Invalidate">
            <summary>
            Redraw this object.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Drawing.SelectableFloatingObject.IsSelected">
            <summary>
            Determine whether or not this drawing object is being selected.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Drawing.SelectableFloatingObject.OnSelect">
            <summary>
            This method will be invoked when drawing object is selected by user.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Drawing.SelectableFloatingObject.OnDeselect">
            <summary>
            This method will be invoked when drawing object is no longer selected by user.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Drawing.DrawingObject">
            <summary>
            Represents drawing object.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Drawing.DrawingObject.#ctor">
            <summary>
            Create drawing object instance.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Drawing.DrawingObject.Container">
            <summary>
            Get or set the container of this drawing object.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Drawing.DrawingObject.Invalidate">
            <summary>
            Invalidate the drawing object on rendering device.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Drawing.DrawingObject.ClientBounds">
            <summary>
            Get client bounds position.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Drawing.DrawingObject.OriginPoint">
            <summary>
            Get the origin point of this object.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Drawing.DrawingObject.ScaleX">
            <summary>
            Get or set the horizontal display scaling.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Drawing.DrawingObject.ScaleY">
            <summary>
            Get or set the vertial display sacling.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Drawing.DrawingObject.RotateAngle">
            <summary>
            Get or set object rotation angle
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Drawing.DrawingObject.Visible">
            <summary>
            Get or set visibility of this object.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Drawing.DrawingObject.Style">
            <summary>
            Get style object.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Drawing.DrawingObject.Draw(unvell.ReoGrid.Rendering.DrawingContext)">
            <summary>
            Render this drawing object.
            </summary>
            <param name="dc">Platform no-associated drawing context instance.</param>
        </member>
        <member name="M:unvell.ReoGrid.Drawing.DrawingObject.OnPaint(unvell.ReoGrid.Rendering.DrawingContext)">
            <summary>
            Render drawing object to graphics context.
            </summary>
            <param name="dc">Platform no-associated drawing context instance.</param>
        </member>
        <member name="M:unvell.ReoGrid.Drawing.DrawingObject.DrawSelection(unvell.ReoGrid.Rendering.DrawingContext)">
            <summary>
            Render when object is selected.
            </summary>
            <param name="dc">Platform no-associated drawing context instance</param>
        </member>
        <member name="M:unvell.ReoGrid.Drawing.DrawingObject.OnSelect">
            <summary>
            This method will be invoked when drawing object is selected by user.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Drawing.DrawingObject.OnDeselect">
            <summary>
            This method will be invoked when drawing object is no longer selected by user.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Drawing.DrawingObject.ThumbPoints">
            <summary>
            Get thumb points.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Drawing.DrawingObjectCollection">
            <summary>
            Represents collection of drawing objects.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Drawing.DrawingObjectCollection.Owner">
            <summary>
            Get container of drawing collection.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Drawing.DrawingObjectCollection.#ctor(unvell.ReoGrid.Drawing.DrawingComponent)">
            <summary>
            Create collection of drawing object.
            </summary>
            <param name="owner">Container instance of collection.</param>
        </member>
        <member name="M:unvell.ReoGrid.Drawing.DrawingObjectCollection.Add(unvell.ReoGrid.Drawing.IDrawingObject)">
            <summary>
            Add drawing object item.
            </summary>
            <param name="item">Drawing object to be added.</param>
        </member>
        <member name="P:unvell.ReoGrid.Drawing.DrawingObjectCollection.Item(System.Int32)">
            <summary>
            Get child object by specified index position.
            </summary>
            <param name="index">Index position in parent object container.</param>
            <returns>Child object from parent object container.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Drawing.DrawingObjectCollection.Clear">
            <summary>
            Remove all object from parent object container.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Drawing.DrawingObjectCollection.Contains(unvell.ReoGrid.Drawing.IDrawingObject)">
            <summary>
            Check whether a specified object is contained by this object container.
            </summary>
            <param name="item">Object to be checked.</param>
            <returns>True if specified object is contained by this object container; Otherwise return false.</returns>
        </member>
        <member name="T:unvell.ReoGrid.Formula.BuiltinFunctionNames">
            <summary>
            Constants of all built-in function name.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Formula.FormulaValue.ToString">
            <summary>
            Convert this value into string
            </summary>
            <returns>Return the value in string type</returns>
        </member>
        <member name="T:unvell.ReoGrid.Formula.FormulaStatus">
            <summary>
            Flag to identify the status of formula parsing and calculation
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Formula.FormulaStatus.Normal">
            <summary>
            Normal status (No errors happen)
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Formula.FormulaStatus.SyntaxError">
            <summary>
            Formula has syntax errors and cannot be parsed correctly
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Formula.FormulaStatus.CircularReference">
            <summary>
            Represents that circular reference problem was detected in formula.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Formula.FormulaStatus.InvalidValue">
            <summary>
            A number value was required in formula calculation, but no valid number found. (Similar to "#VALUE!" in Excel)
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Formula.FormulaStatus.InvalidReference">
            <summary>
            A reference to a cell or range is invalid. (Similar to "#REF!" in Excel)
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Formula.FormulaStatus.NameNotFound">
            <summary>
            A name was referenced in formula, but no valid range was found by this name. (Similar to "#NAME!" in Excel)
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Formula.FormulaStatus.MismatchedParameter">
            <summary>
            Attempt to call a function with mismatched parameter type or amount.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Formula.FormulaStatus.UnspecifiedError">
            <summary>
            Some unspecified errors happened during formula parsing and calculation.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Formula.FormulaEvalutionException">
            <summary>
            Exception will be thrown when errors happened during formula evalution
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Formula.FormulaEvalutionException.Cell">
            <summary>
            Cell of exception happened.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Formula.FormulaEvalutionException.#ctor(unvell.ReoGrid.Cell,System.Exception,System.String)">
            <summary>
            Create exception instance
            </summary>
            <param name="cell">Cell instance that may include the formula.</param>
            <param name="innerException">Original exception instance</param>
            <param name="message">Addtional message to describe this exception</param>
        </member>
        <member name="M:unvell.ReoGrid.Formula.FormulaEvalutionException.#ctor(unvell.ReoGrid.Cell,System.String)">
            <summary>
            Create exception instance.
            </summary>
            <param name="cell">Cell instance that may include the formula.</param>
            <param name="message">Addtional message to describe this exception</param>
        </member>
        <member name="T:unvell.ReoGrid.Formula.FormulaTypeMismatchException">
            <summary>
            This exception will be throw if formula attempts to use a number value during calculation, 
            but the cell data cannot be converted into number value.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Formula.FormulaTypeMismatchException.#ctor(unvell.ReoGrid.Cell)">
            <summary>
            Create the exception instance
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Formula.FormulaNoNameException">
            <summary>
            This exception will be thrown if formula attempts to reference a named range, 
            but the name cannot be found or referenced correctly. 
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Formula.FormulaNoNameException.#ctor(unvell.ReoGrid.Cell)">
            <summary>
            Create the exception instance
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Formula.FormulaParameterMismatchException">
            <summary>
            This exception will be thrown if formula attempts to 
            call a function with mismatched parameters type or amount.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Formula.FormulaParameterMismatchException.#ctor(unvell.ReoGrid.Cell)">
            <summary>
            Create the exception instance
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Formula.FormulaParameterMismatchException.#ctor(unvell.ReoGrid.Cell,System.String)">
            <summary>
            Create the exception instance with additional message
            </summary>
            <param name="cell">Cell instance where the exception happened</param>
            <param name="message">Additional message to describe this exception</param>
        </member>
        <member name="T:unvell.ReoGrid.Formula.FormulaExtension">
            <summary>
            Represents the interface of external formula extension
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Formula.FormulaExtension.CustomFunctions">
            <summary>
            Get collection of custom functions
            </summary>
            <example>
            // Example function to make latters uppercase
            unvell.ReoGrid.Formula.FormulaExtension.CustomFunctions["upper"] =
              (args) => {
              
                if (args.Length == 0) 
                {
                  // this function need at least one arguments
            		  return null;
            	  }
            	  
                return Convert.ToString(args[0]).ToUpper();
              };
            </example>
        </member>
        <member name="P:unvell.ReoGrid.Formula.FormulaExtension.NameReferenceProvider">
            <summary>
            Custom provider for named reference parsing
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Formula.FormulaExtension.EmptyCellReferenceProvider">
            <summary>
            Custom provider for empty cell reference returning
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Formula.FormulaExtension.ChangeToStandardFunctionNames">
            <summary>
            Change built-in function name list to standard English set.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Formula.FormulaExtension.ChangeToRussianFunctionNames">
            <summary>
            Change built-in function name list to Russian language set.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Formula.Parser">
            <summary>
            Excel-compatible formula syntax parser
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Formula.Parser.Parse(unvell.ReoGrid.IWorkbook,unvell.ReoGrid.Cell,System.String)">
            <summary>
            Convert formula to syntax tree
            </summary>
            <param name="workbook">Workbook instance.</param>
            <param name="cell">Cell instance.</param>
            <param name="input">Formula to be converted.</param>
            <returns>syntax tree constructed from specified formula.</returns>
        </member>
        <member name="P:unvell.ReoGrid.Formula.STNode.Children">
            <summary>
            Children nodes
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Formula.STNode.Type">
            <summary>
            Type of node
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Formula.STNode.Start">
            <summary>
            Start index from an input string
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Formula.STNode.Length">
            <summary>
            Length of value in an input string
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Formula.STNode.#ctor(unvell.ReoGrid.Formula.STNodeType,System.Int32,System.Int32)">
            <summary>
            Construct STNode by specified arguments
            </summary>
            <param name="type">Type of node</param>
            <param name="start">Start index from an input string</param>
            <param name="len">Length of value in an input string</param>
        </member>
        <member name="M:unvell.ReoGrid.Formula.STNode.#ctor(unvell.ReoGrid.Formula.STNodeType,System.Int32,System.Int32,System.Collections.Generic.List{unvell.ReoGrid.Formula.STNode})">
            <summary>
            Construct STNode by specified arguments
            </summary>
            <param name="type">Type of node</param>
            <param name="start">Start index from an input string</param>
            <param name="len">Length of value in an input string</param>
            <param name="children">Children nodes of tree from this node</param>
        </member>
        <member name="P:unvell.ReoGrid.Formula.STNode.Item(System.Int32)">
            <summary>
            Get child node from specified position
            </summary>
            <param name="index">zero-based number of child to be get</param>
            <returns>child node from specified position</returns>
        </member>
        <member name="M:unvell.ReoGrid.Formula.STNode.Clone">
            <summary>
            Create a copy from this stnode.
            </summary>
            <returns>The copied stnode.</returns>
        </member>
        <member name="T:unvell.ReoGrid.Formula.STNodeType">
            <summary>
            Determine the kind of type for node in a tree.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Formula.FormulaParseException">
            <summary>
            Exception thrown when any errors happen during formula parsing and evaluation.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Formula.FormulaParseException.Index">
            <summary>
            Zero-based number of character of the position error happened
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Formula.FormulaParseException.#ctor(System.String,System.Int32)">
            <summary>
            Create exception with specified message and the position in formula where error happens.
            </summary>
            <param name="message">additional message to describe the error</param>
            <param name="index">zero-based number of character of the position error happened</param>
        </member>
        <member name="T:unvell.ReoGrid.Graphics.LineStyles">
            <summary>
            Represents line styles.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Graphics.LineStyles.Solid">
            <summary>
            Solid
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Graphics.LineStyles.Dash">
            <summary>
            Dashed
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Graphics.LineStyles.Dot">
            <summary>
            Dotted
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Graphics.LineStyles.DashDot">
            <summary>
            Dashed dot
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Graphics.LineStyles.DashDotDot">
            <summary>
            Dashed double dot
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Graphics.LineCapStyles">
            <summary>
            Represents line cap styles.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Graphics.LineCapStyles.None">
            <summary>
            None
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Graphics.LineCapStyles.Arrow">
            <summary>
            Arrow
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Graphics.LineCapStyles.Ellipse">
            <summary>
            Ellipse
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Graphics.LineCapStyles.Round">
            <summary>
            Round
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Graphics.Matrix3x2f">
            <summary>
            Matrix for 2D graphics.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Graphics.Matrix3x2f.Identify">
            <summary>
            Predefined identify matrix.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Graphics.Matrix3x2f.Translate(System.Double,System.Double)">
            <summary>
            Translate this matrix.
            </summary>
            <param name="x">value of x-coordinate to be offset.</param>
            <param name="y">Value of y-coordinate to be offset.</param>
        </member>
        <member name="M:unvell.ReoGrid.Graphics.Matrix3x2f.Rotate(System.Single)">
            <summary>
            Rotate this matrix.
            </summary>
            <param name="angle">Angle to be rotated.</param>
        </member>
        <member name="M:unvell.ReoGrid.Graphics.Matrix3x2f.Scale(System.Single,System.Single)">
            <summary>
            Scale this matrix.
            </summary>
            <param name="x">Value of x-aspect to be scaled.</param>
            <param name="y">Value of y-aspect to be scaled.</param>
        </member>
        <member name="T:unvell.ReoGrid.Graphics.Point">
            <summary>
            Represents point information that includes the x-coordinate value and y-coordinate value.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Graphics.Point.X">
            <summary>
            Get or set the value on x-coordinate.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Graphics.Point.Y">
            <summary>
            Get or set the value on y-coordinate.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Graphics.Point.#ctor(System.Double,System.Double)">
            <summary>
            Create point by specified x-coordinate value and y-coordinate value.
            </summary>
            <param name="x">Value on x-coordinate.</param>
            <param name="y">Value on y-coordinate.</param>
        </member>
        <member name="M:unvell.ReoGrid.Graphics.Point.Equals(System.Object)">
            <summary>
            Compare two points to check whether or not they are same.
            </summary>
            <param name="obj">Another object to be compared with this point.</param>
            <returns>True if two points are same; Otherwise return false.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Graphics.Point.GetHashCode">
            <summary>
            Get hash code of this point.
            </summary>
            <returns></returns>
        </member>
        <member name="M:unvell.ReoGrid.Graphics.Point.ToString">
            <summary>
            Convert point into string. (Format: {x, y})
            </summary>
            <returns>String converted from this point.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Graphics.Point.op_Equality(unvell.ReoGrid.Graphics.Point,unvell.ReoGrid.Graphics.Point)">
            <summary>
            Compare two points to check whether or not they are same.
            </summary>
            <param name="size1">First point to be compared.</param>
            <param name="size2">Second point to be compared.</param>
            <returns>True if two points are same; Otherwise return false.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Graphics.Point.op_Inequality(unvell.ReoGrid.Graphics.Point,unvell.ReoGrid.Graphics.Point)">
            <summary>
            Compare two points to check whether or not they are not same.
            </summary>
            <param name="size1">First point to be compared.</param>
            <param name="size2">Second point to be compared.</param>
            <returns>True if two points are not same; Otherwise return false.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Graphics.Point.op_Multiply(unvell.ReoGrid.Graphics.Point,unvell.ReoGrid.Graphics.Matrix3x2f)">
            <summary>
            Transform point by specified matrix.
            </summary>
            <param name="p">Point to be transformed.</param>
            <param name="m">Matrix used to calculate the result of transform.</param>
            <returns>A transformed point from specified matrix.</returns>
        </member>
        <member name="T:unvell.ReoGrid.Graphics.Rectangle">
            <summary>
            Represents a rectangle that contains x, y, width and height information.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Graphics.Rectangle.X">
            <summary>
            Get or set the x-coordinate of rectangle.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Graphics.Rectangle.Y">
            <summary>
            Get or set the y-coordinate of rectangle.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Graphics.Rectangle.Width">
            <summary>
            Get or set the width of rectangle.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Graphics.Rectangle.Height">
            <summary>
            Get or set the height of rectangle.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Graphics.Rectangle.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Create rectangle with specified x, y, width and height.
            </summary>
            <param name="x">Value on x-coordinate of rectangle.</param>
            <param name="y">Value on y-coordinate of rectangle.</param>
            <param name="width">Width of rectangle.</param>
            <param name="height">Height of rectangle.</param>
        </member>
        <member name="M:unvell.ReoGrid.Graphics.Rectangle.#ctor(unvell.ReoGrid.Graphics.Point,unvell.ReoGrid.Graphics.Size)">
            <summary>
            Create rectangle with specified position and size.
            </summary>
            <param name="position">Position of rectangle.</param>
            <param name="size">Size of rectangle.</param>
        </member>
        <member name="M:unvell.ReoGrid.Graphics.Rectangle.#ctor(unvell.ReoGrid.Graphics.Point,unvell.ReoGrid.Graphics.Point)">
            <summary>
            Create rectangle from specified two positions. This method will find the 
            top-left position and bottom-right position from two positions and create
            rectangle at correct position.
            </summary>
            <param name="firstPosition">First position.</param>
            <param name="secondPosition">Second position.</param>
        </member>
        <member name="P:unvell.ReoGrid.Graphics.Rectangle.Location">
            <summary>
            Get or set the location of rectangle.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Graphics.Rectangle.Size">
            <summary>
            Get or set the size of rectangle.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Graphics.Rectangle.Left">
            <summary>
            Get or set the left position of rectangle.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Graphics.Rectangle.Right">
            <summary>
            Get or set the right position of rectangle.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Graphics.Rectangle.Top">
            <summary>
            Get or set the top position of rectangle.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Graphics.Rectangle.Bottom">
            <summary>
            Get or set the bottom position of rectangle.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Graphics.Rectangle.OriginX">
            <summary>
            Get origin X-coordinate of rectangle.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Graphics.Rectangle.OriginY">
            <summary>
            Get origin Y-coordinate of rectangle.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Graphics.Rectangle.Origin">
            <summary>
            Get origin of rectangle.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Graphics.Rectangle.Contains(unvell.ReoGrid.Graphics.Point)">
            <summary>
            Check whether or not the specified point is contained by this rectangle.
            </summary>
            <param name="p">Point to be checked.</param>
            <returns>True if the point is contained by this rectangle; Otherwise return false;</returns>
        </member>
        <member name="M:unvell.ReoGrid.Graphics.Rectangle.Contains(System.Double,System.Double)">
            <summary>
            Check whether or not the specified point (described by x and y) is contained by this rectangle.
            </summary>
            <param name="x">Value on x-coordinate.</param>
            <param name="y">Value on y-coordinate.</param>
            <returns>True if the point is contained by this rectangle; Otherwise return false;</returns>
        </member>
        <member name="M:unvell.ReoGrid.Graphics.Rectangle.Offset(System.Double,System.Double)">
            <summary>
            Move the rectangle by amount specified by x and y coordinates.
            </summary>
            <param name="x">Value on x-coordinate.</param>
            <param name="y">Value on y-coordinate.</param>
        </member>
        <member name="M:unvell.ReoGrid.Graphics.Rectangle.Inflate(System.Double,System.Double)">
            <summary>
            Inflate the rectangle by amount specified by x and y coordinates.
            <remarks>
            It is also possible to shrink this rectangle by specifying negative values.
            </remarks>
            </summary>
            <param name="x">Value on x-coordinate.</param>
            <param name="y">Value on y-coordinate.</param>
        </member>
        <member name="M:unvell.ReoGrid.Graphics.Rectangle.IntersectWith(unvell.ReoGrid.Graphics.Rectangle)">
            <summary>
            Determines if this rectangle intersets with rect. 
            </summary>
            <param name="rect">The rectangle to test.</param>
            <returns>This method returns true if there is any intersection, otherwise false.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Graphics.Rectangle.Intersect(unvell.ReoGrid.Graphics.Rectangle)">
            <summary>
            Creates a Rectangle that represents the intersection between this Rectangle and rect.
            </summary>
            <param name="rect">The rectangle to test.</param>
        </member>
        <member name="M:unvell.ReoGrid.Graphics.Rectangle.Intersect(unvell.ReoGrid.Graphics.Rectangle,unvell.ReoGrid.Graphics.Rectangle)">
            <summary>
            Check two rectangles and calculate the intersection of two rectangles.
            If no intersection detected, a rectangle with zero width and height is returned.
            </summary>
            <param name="a">First rectangle to be test.</param>
            <param name="b">Second rectangle to be test.</param>
            <returns>Intersected rectangle.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Graphics.Rectangle.Equals(System.Object)">
            <summary>
            Compare two rectangles to check whether or not they are same.
            </summary>
            <param name="obj">Another rectange compared to this rectangle.</param>
            <returns>True if two rectangles are same; Otherwise return false.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Graphics.Rectangle.GetHashCode">
            <summary>
            Get hash code of this rectangle.
            </summary>
            <returns></returns>
        </member>
        <member name="M:unvell.ReoGrid.Graphics.Rectangle.op_Multiply(unvell.ReoGrid.Graphics.Rectangle,System.Double)">
            <summary>
            Scale rectangle by multiplying specified scale factor.
            </summary>
            <param name="r">The rectangle to be scaled.</param>
            <param name="s">Scale factor to be multiplied.</param>
            <returns></returns>
        </member>
        <member name="M:unvell.ReoGrid.Graphics.Rectangle.op_Equality(unvell.ReoGrid.Graphics.Rectangle,unvell.ReoGrid.Graphics.Rectangle)">
            <summary>
            Compare two rectangels to check whether or not they are same.
            </summary>
            <param name="r1">First rectangle to be compared.</param>
            <param name="r2">Second rectangle to be compared.</param>
            <returns>True if two rectangles are same; Otherwise return false.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Graphics.Rectangle.op_Inequality(unvell.ReoGrid.Graphics.Rectangle,unvell.ReoGrid.Graphics.Rectangle)">
            <summary>
            Compare two rectangles to check whether or not they are not same.
            </summary>
            <param name="r1">First rectangle to be compared.</param>
            <param name="r2">Second rectangle to be compared.</param>
            <returns>True if two rectangles are not same; Otherwise return false.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Graphics.Rectangle.ToString">
            <summary>
            Convert this rectangle into string. (Format: {x, y, w, h})
            </summary>
            <returns>String converted from this rectangle object.</returns>
        </member>
        <member name="T:unvell.ReoGrid.Graphics.Size">
            <summary>
            Represents size information that contains width and height value.
            </summary>
            <remarks>
            Width and height properties defined as float on Windows Form platform;
            And defined as double on other platforms.
            </remarks>
        </member>
        <member name="P:unvell.ReoGrid.Graphics.Size.Width">
            <summary>
            Get and set the width of size.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Graphics.Size.Height">
            <summary>
            Get or set the height of size.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Graphics.Size.#ctor(System.Double,System.Double)">
            <summary>
            Create size with specified width and height value. 
            </summary>
            <param name="width">Width of size.</param>
            <param name="height">Height of size.</param>
        </member>
        <member name="M:unvell.ReoGrid.Graphics.Size.Equals(System.Object)">
            <summary>
            Check another object to see whether or not two objects are same.
            </summary>
            <param name="obj">Another object to be compared.</param>
            <returns>True if specified object is size, and its width and height are same with this object.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Graphics.Size.GetHashCode">
            <summary>
            Get hash code of size object.
            </summary>
            <returns></returns>
        </member>
        <member name="M:unvell.ReoGrid.Graphics.Size.ToString">
            <summary>
            Convert size into string. (e.g. Size[100, 50])
            </summary>
            <returns></returns>
        </member>
        <member name="M:unvell.ReoGrid.Graphics.Size.op_Equality(unvell.ReoGrid.Graphics.Size,unvell.ReoGrid.Graphics.Size)">
            <summary>
            Compare two size objects to check whether or not thay have same width and height.
            </summary>
            <param name="size1">First size to be compared.</param>
            <param name="size2">Second size to be compared.</param>
            <returns>True if two size have same width and height; Otherwise return false.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Graphics.Size.op_Inequality(unvell.ReoGrid.Graphics.Size,unvell.ReoGrid.Graphics.Size)">
            <summary>
            Compare two size objects to check whether or not thay have same width and height.
            </summary>
            <param name="size1">First size to be compared.</param>
            <param name="size2">Second size to be compared.</param>
            <returns>False if two size have same width and height; Otherwise return true.</returns>
        </member>
        <member name="T:unvell.ReoGrid.Graphics.IColor">
            <summary>
            Color interface
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Graphics.IColor.IsTransparent">
            <summary>
            Determines whether or not this color is fully transparent.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Graphics.IColor.ToSolidColor">
            <summary>
            Get solid color converted from this color interface.
            </summary>
            <returns></returns>
        </member>
        <member name="T:unvell.ReoGrid.Graphics.SolidColor">
            <summary>
            Represents ARGB format solid color.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Graphics.SolidColor.A">
            <summary>
            Get or set alpha value.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Graphics.SolidColor.R">
            <summary>
            Get or set red value.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Graphics.SolidColor.G">
            <summary>
            Get or set green value.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Graphics.SolidColor.B">
            <summary>
            Get or set blue value.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Graphics.SolidColor.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Construct color value with specified ARGB value.
            </summary>
            <param name="a">Alpha value.</param>
            <param name="r">Red value.</param>
            <param name="g">Green value.</param>
            <param name="b">Blue value.</param>
        </member>
        <member name="M:unvell.ReoGrid.Graphics.SolidColor.#ctor(System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            Construct color value with specified ARGB value. (0-255)
            </summary>
            <param name="a">Alpha value.</param>
            <param name="r">Red value.</param>
            <param name="g">Green value.</param>
            <param name="b">Blue value.</param>
        </member>
        <member name="M:unvell.ReoGrid.Graphics.SolidColor.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Construct color value with specified ARGB value. (0-255)
            </summary>
            <param name="r">Red value.</param>
            <param name="g">Green value.</param>
            <param name="b">Blue value.</param>
        </member>
        <member name="M:unvell.ReoGrid.Graphics.SolidColor.#ctor(System.Byte,System.Byte,System.Byte)">
            <summary>
            Construct color value with specified ARGB value. (0-255)
            </summary>
            <param name="r">Red value.</param>
            <param name="g">Green value.</param>
            <param name="b">Blue value.</param>
        </member>
        <member name="M:unvell.ReoGrid.Graphics.SolidColor.#ctor(System.Int32,unvell.ReoGrid.Graphics.SolidColor)">
            <summary>
            Create color with specified alpha factor and another solid color.
            </summary>
            <param name="alpha">Alpha factor used to decide the transparency of this color.</param>
            <param name="rgb">Another solid color used to create this color.</param>
        </member>
        <member name="M:unvell.ReoGrid.Graphics.SolidColor.#ctor(System.String)">
            <summary>
            Create color from hex format string. (e.g. AABBCCDD or #AABBCCDD)
            </summary>
            <param name="hex"></param>
        </member>
        <member name="M:unvell.ReoGrid.Graphics.SolidColor.ToArgb">
            <summary>
            Convert color value to 4 bytes integer value.
            </summary>
            <returns>Converted 4 bytes integer value.</returns>
        </member>
        <member name="P:unvell.ReoGrid.Graphics.SolidColor.IsTransparent">
            <summary>
            Check whether or not this color is transparent.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Graphics.SolidColor.FromArgb(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Create color with specified ARGB values.
            </summary>
            <param name="a">Alpha value.</param>
            <param name="r">Red value.</param>
            <param name="g">Green value.</param>
            <param name="b">Blue value.</param>
            <returns>Converted color value.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Graphics.SolidColor.FromArgb(System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            Create color with specified ARGB values.
            </summary>
            <param name="a">Alpha value.</param>
            <param name="r">Red value.</param>
            <param name="g">Green value.</param>
            <param name="b">Blue value.</param>
            <returns>Converted color value.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Graphics.SolidColor.FromArgb(System.Int32,System.Int32,System.Int32)">
            <summary>
            Create color with specified RGB values.
            </summary>
            <param name="r">Red value.</param>
            <param name="g">Green value.</param>
            <param name="b">Blue value.</param>
            <returns>Converted color value.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Graphics.SolidColor.FromArgb(System.Byte,System.Byte,System.Byte)">
            <summary>
            Create color with specified RGB values.
            </summary>
            <param name="r">Red value.</param>
            <param name="g">Green value.</param>
            <param name="b">Blue value.</param>
            <returns>Converted color value.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Graphics.SolidColor.FromArgb(System.Int32)">
            <summary>
            Construct color value with merged ARGB int value.
            </summary>
            <param name="argb">Merged ARGB int value to create color object.</param>
        </member>
        <member name="M:unvell.ReoGrid.Graphics.SolidColor.FromRGB(System.Int32)">
            <summary>
            Construct color value with merged RGB int value.
            </summary>
            <param name="rgb">Merged RGB value to create color object.</param>
        </member>
        <member name="M:unvell.ReoGrid.Graphics.SolidColor.ToString">
            <summary>
            Convert to friendly description.
            </summary>
            <returns>Description of color.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Graphics.SolidColor.ToStringARGB">
            <summary>
            Convert to friendly description. (e.g. A, R, G, B)
            </summary>
            <returns></returns>
        </member>
        <member name="M:unvell.ReoGrid.Graphics.SolidColor.ToStringHex">
            <summary>
            Convert to friendly description. (e.g. AABBCCDD)
            </summary>
            <returns></returns>
        </member>
        <member name="M:unvell.ReoGrid.Graphics.SolidColor.ToSolidColor">
            <summary>
            Convert to solid color. (equal to self)
            </summary>
            <returns>Converted solid color.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Graphics.SolidColor.Randomly">
            <summary>
            Randomly generate a color.
            </summary>
            <returns>New random solid color.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Graphics.SolidColor.Light(unvell.ReoGrid.Graphics.SolidColor)">
            <summary>
            Returns a lighter color of specified color.
            </summary>
            <param name="color">Original color to be changed.</param>
            <returns>Lighter color.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Graphics.SolidColor.Dark(unvell.ReoGrid.Graphics.SolidColor)">
            <summary>
            Returns a darker color of specified color.
            </summary>
            <param name="color">Original color to be changed.</param>
            <returns>Darker color.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Graphics.SolidColor.SetBrightness(System.Single,unvell.ReoGrid.Graphics.SolidColor)">
            <summary>
            Change color brightness.
            </summary>
            <param name="bright">Brightness value.</param>
            <param name="color">Color to be changed.</param>
            <returns>Color has been changed.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Graphics.SolidColor.op_Equality(unvell.ReoGrid.Graphics.SolidColor,unvell.ReoGrid.Graphics.SolidColor)">
            <summary>
            Compare two colors and check whether they are same
            </summary>
            <param name="c1">First color to be compared</param>
            <param name="c2">Second color to be compared</param>
            <returns>True if specified two color are same</returns>
        </member>
        <member name="M:unvell.ReoGrid.Graphics.SolidColor.op_Inequality(unvell.ReoGrid.Graphics.SolidColor,unvell.ReoGrid.Graphics.SolidColor)">
            <summary>
            Compare two colors and check whether they are not same
            </summary>
            <param name="c1">First color to be compared</param>
            <param name="c2">Second color to be compared</param>
            <returns>True if specified two color are not same</returns>
        </member>
        <member name="M:unvell.ReoGrid.Graphics.SolidColor.Equals(System.Object)">
            <summary>
            Compare specified object whether is same as this object
            </summary>
            <param name="obj">Object to be compared</param>
            <returns>True if specified object are same as this object</returns>
        </member>
        <member name="M:unvell.ReoGrid.Graphics.SolidColor.GetHashCode">
            <summary>
            Get hash code
            </summary>
            <returns>Hash code</returns>
        </member>
        <member name="T:unvell.ReoGrid.Graphics.LinearColor">
            <summary>
            Store the ARGB values of linear color.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Graphics.LinearColor.StartColor">
            <summary>
            Get or set the start color of linear fill region.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Graphics.LinearColor.EndColor">
            <summary>
            Get or set the end color of linear fill region.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Graphics.LinearColor.Angle">
            <summary>
            Linear angle
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Graphics.LinearColor.ToSolidColor">
            <summary>
            Convert linear color to a solid color.
            </summary>
            <returns>Solid color converted from this linear color.</returns>
        </member>
        <member name="P:unvell.ReoGrid.Graphics.LinearColor.IsTransparent">
            <summary>
            Check whether or not this color is transparent.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Graphics.HatchStyles">
            <summary>
            Specifies the hatch style patterns. 
            (This enum is a copy from System.Drawing.Drawing2D.HatchStyle)
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Graphics.IGraphics">
            <summary>
            Represents abstract cross-platform drawing context.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Interaction.MouseButtons">
            <summary>
            Mouse button down status
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Interaction.MouseButtons.None">
            <summary>
            None
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Interaction.MouseButtons.Left">
            <summary>
            Left
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Interaction.MouseButtons.Right">
            <summary>
            Right
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Interaction.MouseButtons.Middle">
            <summary>
            Middle
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Interaction.CursorStyle">
            <summary>
            Cursor style 
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Interaction.CursorStyle.PlatformDefault">
            <summary>
            Default (Auto)
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Interaction.CursorStyle.Hand">
            <summary>
            Hand
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Interaction.CursorStyle.Selection">
            <summary>
            Range Selection
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Interaction.CursorStyle.FullRowSelect">
            <summary>
            Full Row Selector
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Interaction.CursorStyle.FullColumnSelect">
            <summary>
            Full Column Selector
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Interaction.CursorStyle.EntireSheet">
            <summary>
            Entire worksheet Selector
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Interaction.CursorStyle.Move">
            <summary>
            Move object
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Interaction.CursorStyle.Copy">
            <summary>
            Copy object
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Interaction.CursorStyle.ChangeColumnWidth">
            <summary>
            Change Column Width
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Interaction.CursorStyle.ChangeRowHeight">
            <summary>
            Change Row Height
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Interaction.CursorStyle.ResizeHorizontal">
            <summary>
            Horizontal Resize
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Interaction.CursorStyle.ResizeVertical">
            <summary>
            Vertical Resize
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Interaction.CursorStyle.Busy">
            <summary>
            Busy (Waiting)
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Interaction.CursorStyle.Cross">
            <summary>
            Cross Cursor
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Interaction.ToggleStatus">
            <summary>
            Represent for the button status of mouse
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Interaction.ToggleStatus.Normal">
            <summary>
            The button has its normal appearance (three-dimensional).
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Interaction.ToggleStatus.Inactive">
            <summary>
            The button is inactive (grayed).
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Interaction.ToggleStatus.Pushed">
            <summary>
            The button appears pressed.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Interaction.ToggleStatus.Checked">
            <summary>
            The button has a checked or latched appearance. Use this appearance to show
            that a toggle button has been pressed.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Interaction.ToggleStatus.Flat">
            <summary>
            The button has a flat, two-dimensional appearance.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Interaction.ToggleStatus.All">
            <summary>
            All flags except Normal are set.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Interaction.IUserVisual">
            <summary>
            Represents an user-interactive object in ReoGrid cross-platform views system.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Interaction.IUserVisual.OnMouseDown(unvell.ReoGrid.Graphics.Point,unvell.ReoGrid.Interaction.MouseButtons)">
            <summary>
            Handle mouse down event
            </summary>
            <param name="location">Transformed relative location to this object</param>
            <param name="buttons">Current mouse button pressing status</param>
            <returns>True if event handled; otherwise return false</returns>
        </member>
        <member name="M:unvell.ReoGrid.Interaction.IUserVisual.OnMouseMove(unvell.ReoGrid.Graphics.Point,unvell.ReoGrid.Interaction.MouseButtons)">
            <summary>
            Handle mouse move event
            </summary>
            <param name="location">Transformed relative location to this object</param>
            <param name="buttons">Current mouse button pressing status</param>
            <returns>True if event handled; otherwise return false</returns>
        </member>
        <member name="M:unvell.ReoGrid.Interaction.IUserVisual.OnMouseUp(unvell.ReoGrid.Graphics.Point,unvell.ReoGrid.Interaction.MouseButtons)">
            <summary>
            Handle mouse up event
            </summary>
            <param name="location">Transformed relative location to this object</param>
            <param name="buttons">Current mouse button pressing status</param>
            <returns>True if event handled; otherwise return false</returns>
        </member>
        <member name="M:unvell.ReoGrid.Interaction.IUserVisual.OnMouseDoubleClick(unvell.ReoGrid.Graphics.Point,unvell.ReoGrid.Interaction.MouseButtons)">
            <summary>
            Handle mouse double click event
            </summary>
            <param name="location">Transformed relative location to this object</param>
            <param name="buttons">Current mouse button pressing status</param>
            <returns>True if event handled; otherwise return false</returns>
        </member>
        <member name="M:unvell.ReoGrid.Interaction.IUserVisual.OnKeyDown(unvell.ReoGrid.Interaction.KeyCode)">
            <summary>
            Handle key down event
            </summary>
            <param name="keys">ReoGrid virtual keys (equal to System.Windows.Forms.Keys)</param>
            <returns>True if event handled; otherwise return false</returns>
        </member>
        <member name="M:unvell.ReoGrid.Interaction.IUserVisual.SetFocus">
            <summary>
            Set this object to get user interface focus. Object after get focus can always 
            receive user's mouse and keyboard input.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Interaction.IUserVisual.FreeFocus">
            <summary>
            Release user interface focus from this object. This object will no longer be able to 
            receive user's mouse and keyboard input.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Interaction.IUserVisual.Invalidate">
            <summary>
            Redraw this object.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Properties.Resources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Properties.Resources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Properties.Resources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Properties.Resources.base_lib">
            <summary>
              Looks up a localized resource of type System.Byte[].
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Properties.Resources.cross">
            <summary>
              Looks up a localized resource of type System.Byte[].
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Properties.Resources.EULA_EN">
            <summary>
              Looks up a localized string similar to END-USER LICENSE AGREEMENT FOR UNVELL IMPORTANT PLEASE READ THE TERMS AND CONDITIONS OF THIS LICENSE AGREEMENT CAREFULLY BEFORE CONTINUING WITH THIS PROGRAM INSTALL: UNVELL End-User License Agreement (&quot;EULA&quot;) is a legal agreement between you (either an individual or a single entity) and UNVELL. for the UNVELL software product(s) identified above which may include associated software components, media, printed materials, and &quot;online&quot; or electronic documentation (&quot;EULA&quot;). By installing, copying, or otherwise  [rest of string was truncated]&quot;;.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Properties.Resources.eye_16xLG_png">
            <summary>
              Looks up a localized resource of type System.Byte[].
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Properties.Resources.full_col_select">
            <summary>
              Looks up a localized resource of type System.Byte[].
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Properties.Resources.full_row_select">
            <summary>
              Looks up a localized resource of type System.Byte[].
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Properties.Resources.grid_select">
            <summary>
              Looks up a localized resource of type System.Byte[].
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Properties.Resources.icon_list_png">
            <summary>
              Looks up a localized resource of type System.Byte[].
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Properties.Resources.NewBuildDefinition_8952_inactive_png">
            <summary>
              Looks up a localized resource of type System.Byte[].
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Properties.Resources.NewBuildDefinition_8952_png">
            <summary>
              Looks up a localized resource of type System.Byte[].
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Properties.Resources.pick_range">
            <summary>
              Looks up a localized resource of type System.Byte[].
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Properties.Resources.seek">
            <summary>
              Looks up a localized resource of type System.Byte[].
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Properties.Resources.theme1">
             <summary>
               Looks up a localized string similar to &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;
            &lt;a:theme xmlns:a=&quot;http://schemas.openxmlformats.org/drawingml/2006/main&quot; name=&quot;Office Theme&quot;&gt;
            	&lt;a:themeElements&gt;
            		&lt;a:clrScheme name=&quot;Office&quot;&gt;
            			&lt;a:dk1&gt;
            				&lt;a:sysClr val=&quot;windowText&quot; lastClr=&quot;000000&quot;/&gt;
            			&lt;/a:dk1&gt;
            			&lt;a:lt1&gt;
            				&lt;a:sysClr val=&quot;window&quot; lastClr=&quot;FFFFFF&quot;/&gt;
            			&lt;/a:lt1&gt;
            			&lt;a:dk2&gt;
            				&lt;a:srgbClr val=&quot;1F497D&quot;/&gt;
            			&lt;/a:dk2&gt;
            			&lt;a:lt2&gt;
            				&lt;a:srgbClr val=&quot;EEECE1&quot;/&gt;
            			&lt;/a:lt2&gt;
            			&lt;a:accent1&gt;
            				&lt;a:srgbClr val=&quot;4F81BD&quot;/&gt;
            		 [rest of string was truncated]&quot;;.
             </summary>
        </member>
        <member name="T:unvell.ReoGrid.Utility.StyleUtility">
            <summary>
            Range style utility
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Utility.StyleUtility.HasStyle(unvell.ReoGrid.WorksheetRangeStyle,unvell.ReoGrid.PlainStyleFlag)">
            <summary>
            Check whether or not the style set contains the specified item
            </summary>
            <param name="style">style set to be checked</param>
            <param name="flag">style item to be checked</param>
            <returns>true if the style set contains the specified item</returns>
        </member>
        <member name="M:unvell.ReoGrid.Utility.StyleUtility.CheckAndRemoveCellStyle(unvell.ReoGrid.Worksheet,unvell.ReoGrid.Cell)">
            <summary>
            Remove repeated styles if it does same as default style.
            This function also can be used to create a default style for specified cell.
            </summary>
            <param name="grid">Instance of worksheet.</param>
            <param name="cell">The style from this cell will be checked.</param>
            <returns>Checked style, null if given cell or style of cell is null.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Utility.StyleUtility.GetStyleItem(unvell.ReoGrid.WorksheetRangeStyle,unvell.ReoGrid.PlainStyleFlag)">
            <summary>
            Get single style from style set
            </summary>
            <param name="style">style set to find specified single style</param>
            <param name="flag">single style specifeid by this flag to be get</param>
            <returns>single style as object returned from style set</returns>
        </member>
        <member name="M:unvell.ReoGrid.Utility.StyleUtility.CreateFontStyle(unvell.ReoGrid.WorksheetRangeStyle)">
            <summary>
            Convert to union font style flag from worksheet styleset object.
            </summary>
            <param name="style"></param>
            <returns></returns>
        </member>
        <member name="T:unvell.ReoGrid.Utility.CellUtility">
            <summary>
            Common utility functions for cell.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Utility.CellUtility.CopyCell(unvell.ReoGrid.Cell,unvell.ReoGrid.Cell)">
            <summary>
            Clone new cell instance from another cell.
            </summary>
            <param name="toCell">Target cell to be copied into.</param>
            <param name="fromCell">Original cell to be copied from.</param>
            <returns>Instance of cell cloned</returns>
        </member>
        <member name="M:unvell.ReoGrid.Utility.CellUtility.CopyCellContent(unvell.ReoGrid.Cell,unvell.ReoGrid.Cell)">
            <summary>
            Copy all content from a cell to another cell.
            </summary>
            <param name="toCell">Target cell to be copied into.</param>
            <param name="fromCell">Source cell to be copied from.</param>
        </member>
        <member name="M:unvell.ReoGrid.Utility.CellUtility.IsNumberData(unvell.ReoGrid.Cell)">
            <summary>
            Check specified data from a cell is whether or not a number.
            </summary>
            <param name="cell">Cell instance of data.</param>
            <returns>True if data from the cell is number.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Utility.CellUtility.IsNumberData(System.Object)">
            <summary>
            Check specified data is whether or not a number.
            </summary>
            <param name="data">Data to be check.</param>
            <returns>True if data is number.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Utility.CellUtility.TryGetNumberData(unvell.ReoGrid.Cell,System.Double@)">
            <summary>
            Try get double value from specified cell.
            </summary>
            <param name="cell">Instance of cell.</param>
            <param name="value">The output value converted from data.</param>
            <returns>True if convert is succesful.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Utility.CellUtility.TryGetNumberData(System.Object,System.Double@)">
            <summary>
            Try get double value from specified object.
            </summary>
            <param name="data">Data to be check and converted.</param>
            <param name="value">The output value converted from data.</param>
            <returns>True if convert is succesful.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Utility.CellUtility.ConvertData``1(System.Object)">
            <summary>
            Convert cell data into another type if possible.
            </summary>
            <param name="data">Cell data to be converted.</param>
            <returns>Output object after convert.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Utility.CellUtility.ConvertData``1(System.Object,``0@)">
            <summary>
            Convert cell data into another type if possible.
            </summary>
            <typeparam name="T">Type after convert.</typeparam>
            <param name="data">Cell data to be converted.</param>
            <param name="value">Output object after convert.</param>
            <returns>True if convert is successful.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Utility.ColorUtility.RGBToHSL(unvell.ReoGrid.Graphics.SolidColor)">
            <summary>
            Source: http://ciintelligence.blogspot.jp/2012/02/converting-excel-theme-color-and-tint.html
            </summary>
            <param name="rgbColor"></param>
            <returns></returns>
        </member>
        <member name="M:unvell.ReoGrid.Utility.ColorUtility.HSLToRgb(unvell.ReoGrid.Utility.HSLColor)">
            <summary>
            Source: http://ciintelligence.blogspot.jp/2012/02/converting-excel-theme-color-and-tint.html
            </summary>
            <param name="hslColor"></param>
            <returns></returns>
        </member>
        <member name="M:unvell.ReoGrid.Utility.ColorUtility.SetColor(System.Single,System.Single,System.Single)">
            <summary>
            Source: http://ciintelligence.blogspot.jp/2012/02/converting-excel-theme-color-and-tint.html
            </summary>
            <param name="t1"></param>
            <param name="t2"></param>
            <param name="t3"></param>
            <returns></returns>
        </member>
        <member name="M:unvell.ReoGrid.Utility.ColorUtility.CalculateFinalLumValue(System.Single,System.Single)">
            <summary>
            Source: http://ciintelligence.blogspot.jp/2012/02/converting-excel-theme-color-and-tint.html
            </summary>
            <param name="tint"></param>
            <param name="lum"></param>
            <returns></returns>
        </member>
        <member name="T:unvell.ReoGrid.Utility.NET35ZipArchiveFactory">
            <summary>
            Original Document: http://www.codeproject.com/Articles/209731/Csharp-use-Zip-archives-without-external-libraries
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Utility.ZipStreamHelper">
            <summary>
            Helper class for compress and decompress zip stream
            </summary>
            <remarks>Provided by Rick Meyer</remarks>
        </member>
        <member name="M:unvell.ReoGrid.Utility.ZipStreamHelper.Decompress(System.Byte[])">
            <summary>
            Decompress a byte array
            </summary>
            <param name="zippedData">Compressed Byte Array</param>
            <returns>Decompressed Byte Array</returns>
        </member>
        <member name="M:unvell.ReoGrid.Utility.ZipStreamHelper.Compress(System.Byte[])">
            <summary>
            Compress a byte Array using Gzip
            </summary>
            <param name="plainData">The byte array to compress</param>
            <returns>Returns a compressed byte array</returns>
        </member>
        <member name="T:unvell.ReoGrid.Actions.WorkbookAction">
            <summary>
            Represents an action of workbook.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Actions.WorkbookAction.Workbook">
            <summary>
            Get the workbook instance.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.WorkbookAction.#ctor(unvell.ReoGrid.IWorkbook)">
            <summary>
            Create workbook action with specified workbook instance.
            </summary>
            <param name="workbook"></param>
        </member>
        <member name="M:unvell.ReoGrid.Actions.WorkbookAction.Do">
            <summary>
            Do this action.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.WorkbookAction.Undo">
            <summary>
            Undo this action.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.WorkbookAction.Redo">
            <summary>
            Redo this action.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.WorkbookAction.GetName">
            <summary>
            Get the friendly name of this action.
            </summary>
            <returns></returns>
        </member>
        <member name="T:unvell.ReoGrid.Actions.InsertWorksheetAction">
            <summary>
            Action for inserting worksheet
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Actions.InsertWorksheetAction.Index">
            <summary>
            Number of worksheet
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Actions.InsertWorksheetAction.Worksheet">
            <summary>
            Worksheet instance
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.InsertWorksheetAction.#ctor(System.Int32,unvell.ReoGrid.Worksheet)">
            <summary>
            Create this action to insert worksheet
            </summary>
            <param name="index">Number of worksheet</param>
            <param name="worksheet">Worksheet instance</param>
        </member>
        <member name="M:unvell.ReoGrid.Actions.InsertWorksheetAction.Do">
            <summary>
            Do this action to insert worksheet
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.InsertWorksheetAction.Undo">
            <summary>
            Undo this action to remove the inserted worksheet
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.InsertWorksheetAction.GetName">
            <summary>
            Get friendly name of this action
            </summary>
            <returns></returns>
        </member>
        <member name="T:unvell.ReoGrid.Actions.RemoveWorksheetAction">
            <summary>
            Action for removing worksheet
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Actions.RemoveWorksheetAction.Index">
            <summary>
            Number of worksheet
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Actions.RemoveWorksheetAction.Worksheet">
            <summary>
            Worksheet instance
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.RemoveWorksheetAction.#ctor(System.Int32,unvell.ReoGrid.Worksheet)">
            <summary>
            Create this action to insert worksheet
            </summary>
            <param name="index">Number of worksheet</param>
            <param name="worksheet">Worksheet instance</param>
        </member>
        <member name="M:unvell.ReoGrid.Actions.RemoveWorksheetAction.Do">
            <summary>
            Do this action to remove worksheet
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.RemoveWorksheetAction.Undo">
            <summary>
            Undo this action to restore the removed worksheet
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.RemoveWorksheetAction.GetName">
            <summary>
            Get friendly name of this action
            </summary>
            <returns></returns>
        </member>
        <member name="T:unvell.ReoGrid.Actions.BaseWorksheetAction">
            <summary>
            Base action for all actions that are used for worksheet operations.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Actions.BaseWorksheetAction.Worksheet">
            <summary>
            Instance for the grid control will be setted before action performed.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.BaseWorksheetAction.Do">
            <summary>
            Do this action.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.BaseWorksheetAction.Undo">
            <summary>
            Undo this action.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.BaseWorksheetAction.Redo">
            <summary>
            Redo this action.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.BaseWorksheetAction.GetName">
            <summary>
            Get friendly name of this action.
            </summary>
            <returns>Get friendly name of this action.</returns>
        </member>
        <member name="T:unvell.ReoGrid.Actions.WorksheetActionGroup">
            <summary>
            The action group is one type of RGAction to support Do/Undo/Redo a series of actions.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Actions.WorksheetActionGroup.Actions">
            <summary>
            Actions stored in this list will be Do/Undo/Redo together
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.WorksheetActionGroup.#ctor">
            <summary>
            Create instance for RGActionGroup
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.WorksheetActionGroup.Do">
            <summary>
            Do all actions stored in this action group
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.WorksheetActionGroup.Undo">
            <summary>
            Undo all actions stored in this action group
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.WorksheetActionGroup.GetName">
            <summary>
            Get friendly name of this action group
            </summary>
            <returns></returns>
        </member>
        <member name="T:unvell.ReoGrid.Actions.WorksheetReusableAction">
            <summary>
            Reusable action is one type of RGAction to support repeat operation
            to a specified range. It is good practice to make all actions with 
            a range target to inherit from this class.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Actions.WorksheetReusableAction.Range">
            <summary>
            Range to be appiled this action
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.WorksheetReusableAction.#ctor(unvell.ReoGrid.RangePosition)">
            <summary>
            Constructor of RGReusableAction 
            </summary>
            <param name="range">Range to be applied this action</param>
        </member>
        <member name="M:unvell.ReoGrid.Actions.WorksheetReusableAction.Clone(unvell.ReoGrid.RangePosition)">
            <summary>
            Create a copy from this action in order to apply the operation to another range.
            </summary>
            <param name="range">New range where this operation will be appiled to.</param>
            <returns>New action instance copied from this action.</returns>
        </member>
        <member name="T:unvell.ReoGrid.Actions.WorksheetReusableActionGroup">
            <summary>
            Reusable action group is one type of RGActionGroup to support repeat 
            operation to a specified range. It is good practice to make all reusable 
            action groups to inherit from this class.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Actions.WorksheetReusableActionGroup.Actions">
            <summary>
            All reusable actions stored in this list will be performed together.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.WorksheetReusableActionGroup.#ctor(unvell.ReoGrid.RangePosition)">
            <summary>
            Constructor of ReusableActionGroup
            </summary>
            <param name="range">Range to be appiled this action group</param>
        </member>
        <member name="M:unvell.ReoGrid.Actions.WorksheetReusableActionGroup.#ctor(unvell.ReoGrid.RangePosition,System.Collections.Generic.List{unvell.ReoGrid.Actions.WorksheetReusableAction})">
            <summary>
            Constructor of ReusableActionGroup
            </summary>
            <param name="range">Range to be appiled this action group</param>
            <param name="actions">Action list to be performed together</param>
        </member>
        <member name="M:unvell.ReoGrid.Actions.WorksheetReusableActionGroup.Do">
            <summary>
            Do all actions stored in this action group
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.WorksheetReusableActionGroup.Undo">
            <summary>
            Undo all actions stored in this action group
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.WorksheetReusableActionGroup.GetName">
            <summary>
            Get friendly name of this action group
            </summary>
            <returns></returns>
        </member>
        <member name="M:unvell.ReoGrid.Actions.WorksheetReusableActionGroup.Clone(unvell.ReoGrid.RangePosition)">
            <summary>
            Create cloned reusable action group from this action group
            </summary>
            <param name="range">Specified new range to apply this action group</param>
            <returns>New reusable action group cloned from this action group</returns>
        </member>
        <member name="T:unvell.ReoGrid.Actions.SetRangeStyleAction">
            <summary>
            Action for set styles to specified range
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Actions.SetRangeStyleAction.Style">
            <summary>
            Styles to be set
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.SetRangeStyleAction.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,unvell.ReoGrid.WorksheetRangeStyle)">
            <summary>
            Create an action to set styles into specified range
            </summary>
            <param name="row">Zero-based number of start row</param>
            <param name="col">Zero-based number of start column</param>
            <param name="rows">Number of rows in the range</param>
            <param name="cols">Number of columns in the range</param>
            <param name="style">Styles to be set</param>
        </member>
        <member name="M:unvell.ReoGrid.Actions.SetRangeStyleAction.#ctor(System.String,unvell.ReoGrid.WorksheetRangeStyle)">
            <summary>
            Create an action to set styles into specified range
            </summary>
            <param name="address">Address to locate the cell or range on spreadsheet (Cannot specify named range for this method)</param>
            <param name="style">Styles to be set</param>
            <exception cref="T:unvell.ReoGrid.InvalidAddressException">Throw if specified address or name is invalid</exception>
        </member>
        <member name="M:unvell.ReoGrid.Actions.SetRangeStyleAction.#ctor(unvell.ReoGrid.RangePosition,unvell.ReoGrid.WorksheetRangeStyle)">
            <summary>
            Create an action that perform set styles to specified range
            </summary>
            <param name="range">Range to be appiled this action</param>
            <param name="style">Style to be set to specified range</param>
        </member>
        <member name="M:unvell.ReoGrid.Actions.SetRangeStyleAction.Do">
            <summary>
            Do this action
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.SetRangeStyleAction.Undo">
            <summary>
            Undo this action
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.SetRangeStyleAction.GetName">
            <summary>
            Returns friendly name for this action.
            </summary>
            <returns></returns>
        </member>
        <member name="M:unvell.ReoGrid.Actions.SetRangeStyleAction.Clone(unvell.ReoGrid.RangePosition)">
            <summary>
            Create a copy from this action in order to apply the operation to another range.
            </summary>
            <param name="range">New range where this operation will be appiled to.</param>
            <returns>New action instance copied from this action.</returns>
        </member>
        <member name="T:unvell.ReoGrid.Actions.RemoveRangeStyleAction">
            <summary>
            Remove style from specified range action
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Actions.RemoveRangeStyleAction.Flag">
            <summary>
            Style flag indicates what type of style to be handled.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.RemoveRangeStyleAction.#ctor(unvell.ReoGrid.RangePosition,unvell.ReoGrid.PlainStyleFlag)">
            <summary>
            Create instance for action to remove style from specified range.
            </summary>
            <param name="range">Styles from this specified range to be removed</param>
            <param name="flag">Style flag indicates what type of style should be removed</param>
        </member>
        <member name="M:unvell.ReoGrid.Actions.RemoveRangeStyleAction.Do">
            <summary>
            Do this action
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.RemoveRangeStyleAction.Undo">
            <summary>
            Undo this action
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.RemoveRangeStyleAction.GetName">
            <summary>
            Get friendly name of this action
            </summary>
            <returns></returns>
        </member>
        <member name="M:unvell.ReoGrid.Actions.RemoveRangeStyleAction.Clone(unvell.ReoGrid.RangePosition)">
            <summary>
            Create a copy from this action in order to apply the operation to another range.
            </summary>
            <param name="range">New range where this operation will be appiled to.</param>
            <returns>New action instance copied from this action.</returns>
        </member>
        <member name="T:unvell.ReoGrid.Actions.StepRangeFontSizeAction">
            <summary>
            Make font size larger or smaller action.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Actions.StepRangeFontSizeAction.Enlarge">
            <summary>
            True if this action making font size larger.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.StepRangeFontSizeAction.#ctor(unvell.ReoGrid.RangePosition,System.Boolean)">
            <summary>
            Create instance for this action with specified range and enlarge flag.
            </summary>
            <param name="range">Specified range to apply this action</param>
            <param name="enlarge">True to set text larger, false to set smaller</param>
        </member>
        <member name="M:unvell.ReoGrid.Actions.StepRangeFontSizeAction.Do">
            <summary>
            Do this action
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.StepRangeFontSizeAction.Undo">
            <summary>
            Undo this action
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.StepRangeFontSizeAction.GetName">
            <summary>
            Get friendly name of this action
            </summary>
            <returns></returns>
        </member>
        <member name="M:unvell.ReoGrid.Actions.StepRangeFontSizeAction.Clone(unvell.ReoGrid.RangePosition)">
            <summary>
            Create a copy from this action in order to apply the operation to another range.
            </summary>
            <param name="range">New range where this operation will be appiled to.</param>
            <returns>New action instance copied from this action.</returns>
        </member>
        <member name="T:unvell.ReoGrid.Actions.InsertRowsAction">
            <summary>
            Insert rows action
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Actions.InsertRowsAction.Row">
            <summary>
            Index of row to insert empty rows. Set to Control.RowCount to 
            append columns at end of rows.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Actions.InsertRowsAction.Count">
            <summary>
            Number of empty rows to be inserted
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.InsertRowsAction.#ctor(System.Int32,System.Int32)">
            <summary>
            Create instance for InsertRowsAction
            </summary>
            <param name="row">Index of row to insert</param>
            <param name="count">Number of rows to be inserted</param>
        </member>
        <member name="M:unvell.ReoGrid.Actions.InsertRowsAction.Do">
            <summary>
            Do this action
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.InsertRowsAction.Undo">
            <summary>
            Undo this action
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.InsertRowsAction.GetName">
            <summary>
            Get friendly name of this action
            </summary>
            <returns></returns>
        </member>
        <member name="M:unvell.ReoGrid.Actions.InsertRowsAction.Clone(unvell.ReoGrid.RangePosition)">
            <summary>
            Create a copy from this action in order to apply the operation to another range.
            </summary>
            <param name="range">New range where this operation will be appiled to.</param>
            <returns>New action instance copied from this action.</returns>
        </member>
        <member name="T:unvell.ReoGrid.Actions.InsertColumnsAction">
            <summary>
            Insert columns action
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Actions.InsertColumnsAction.Column">
            <summary>
            Index of column to insert new columns. Set to Control.ColCount to
            append columns at end of columns.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Actions.InsertColumnsAction.Count">
            <summary>
            Number of columns to be inserted
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.InsertColumnsAction.#ctor(System.Int32,System.Int32)">
            <summary>
            Create instance for InsertColumnsAction
            </summary>
            <param name="column">Index of column to insert</param>
            <param name="count">Number of columns to be insertted</param>
        </member>
        <member name="M:unvell.ReoGrid.Actions.InsertColumnsAction.Do">
            <summary>
            Do this action
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.InsertColumnsAction.Undo">
            <summary>
            Undo this action
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.InsertColumnsAction.GetName">
            <summary>
            Get friendly name of this action
            </summary>
            <returns></returns>
        </member>
        <member name="M:unvell.ReoGrid.Actions.InsertColumnsAction.Clone(unvell.ReoGrid.RangePosition)">
            <summary>
            Create a copy from this action in order to apply the operation to another range.
            </summary>
            <param name="range">New range where this operation will be appiled to.</param>
            <returns>New action instance copied from this action.</returns>
        </member>
        <member name="T:unvell.ReoGrid.Actions.RemoveRowsAction">
            <summary>
            Remove rows actions
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.RemoveRowsAction.#ctor(System.Int32,System.Int32)">
            <summary>
            Create instance for RemoveRowsAction
            </summary>
            <param name="row">Index of row start to remove</param>
            <param name="rows">Number of rows to be removed</param>
        </member>
        <member name="M:unvell.ReoGrid.Actions.RemoveRowsAction.Do">
            <summary>
            Do this action
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.RemoveRowsAction.Undo">
            <summary>
            Undo this action
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.RemoveRowsAction.GetName">
            <summary>
            Get friendly name of this action
            </summary>
            <returns></returns>
        </member>
        <member name="M:unvell.ReoGrid.Actions.RemoveRowsAction.Clone(unvell.ReoGrid.RangePosition)">
            <summary>
            Create a copy from this action in order to apply the operation to another range.
            </summary>
            <param name="range">New range where this operation will be appiled to.</param>
            <returns>New action instance copied from this action.</returns>
        </member>
        <member name="T:unvell.ReoGrid.Actions.RemoveColumnsAction">
            <summary>
            Remove columns action.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.RemoveColumnsAction.#ctor(System.Int32,System.Int32)">
            <summary>
            Create instance for RemoveColumnsAction
            </summary>
            <param name="column">Index of column start to remove</param>
            <param name="count">Number of columns to be removed</param>
        </member>
        <member name="M:unvell.ReoGrid.Actions.RemoveColumnsAction.Do">
            <summary>
            Do this action
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.RemoveColumnsAction.Undo">
            <summary>
            Undo this action
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.RemoveColumnsAction.GetName">
            <summary>
            Get friendly name of this action
            </summary>
            <returns></returns>
        </member>
        <member name="M:unvell.ReoGrid.Actions.RemoveColumnsAction.Clone(unvell.ReoGrid.RangePosition)">
            <summary>
            Create a copy from this action in order to apply the operation to another range.
            </summary>
            <param name="range">New range where this operation will be appiled to.</param>
            <returns>New action instance copied from this action.</returns>
        </member>
        <member name="T:unvell.ReoGrid.Actions.SetRowsHeightAction">
            <summary>
            Set height of row action
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Actions.SetRowsHeightAction.Height">
            <summary>
            Height to be set
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.SetRowsHeightAction.#ctor(System.Int32,System.Int32,System.UInt16)">
            <summary>
            Create instance for SetRowsHeightAction
            </summary>
            <param name="row">Index of row start to set</param>
            <param name="count">Number of rows to be set</param>
            <param name="height">New height to set to specified rows</param>
        </member>
        <member name="M:unvell.ReoGrid.Actions.SetRowsHeightAction.Do">
            <summary>
            Do this action
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.SetRowsHeightAction.Undo">
            <summary>
            Undo this action
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.SetRowsHeightAction.GetName">
            <summary>
            Get friendly name of this action
            </summary>
            <returns></returns>
        </member>
        <member name="M:unvell.ReoGrid.Actions.SetRowsHeightAction.Clone(unvell.ReoGrid.RangePosition)">
            <summary>
            Create a copy from this action in order to apply the operation to another range.
            </summary>
            <param name="range">New range where this operation will be appiled to.</param>
            <returns>New action instance copied from this action.</returns>
        </member>
        <member name="T:unvell.ReoGrid.Actions.SetColsWidthAction">
            <summary>
            Action for adjusting columns width
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.SetColsWidthAction.#ctor(System.Int32,System.Int32,System.UInt16)">
            <summary>
            Create instance for SetColsWidthAction
            </summary>
            <param name="col">Index of column start to set</param>
            <param name="count">Number of columns to be set</param>
            <param name="width">Width of column to be set</param>
        </member>
        <member name="T:unvell.ReoGrid.Actions.SetColumnsWidthAction">
            <summary>
            Action for adjusting columns width.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Actions.SetColumnsWidthAction.Width">
            <summary>
            Width to be set
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.SetColumnsWidthAction.#ctor(System.Int32,System.Int32,System.UInt16)">
            <summary>
            Create instance for SetColsWidthAction
            </summary>
            <param name="col">Index of column start to set</param>
            <param name="count">Number of columns to be set</param>
            <param name="width">Width of column to be set</param>
        </member>
        <member name="M:unvell.ReoGrid.Actions.SetColumnsWidthAction.Do">
            <summary>
            Do this action
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.SetColumnsWidthAction.Undo">
            <summary>
            Undo this action
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.SetColumnsWidthAction.GetName">
            <summary>
            Get friendly name of this action
            </summary>
            <returns></returns>
        </member>
        <member name="M:unvell.ReoGrid.Actions.SetColumnsWidthAction.Clone(unvell.ReoGrid.RangePosition)">
            <summary>
            Create a copy from this action in order to apply the operation to another range.
            </summary>
            <param name="range">New range where this operation will be appiled to.</param>
            <returns>New action instance copied from this action.</returns>
        </member>
        <member name="T:unvell.ReoGrid.Actions.HideRowsAction">
            <summary>
            Hide specified rows action
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.HideRowsAction.#ctor(System.Int32,System.Int32)">
            <summary>
            Create action to hide specified rows.
            </summary>
            <param name="row">Zero-based row index to start hiding.</param>
            <param name="count">Number of rows to be hidden.</param>
        </member>
        <member name="M:unvell.ReoGrid.Actions.HideRowsAction.Do">
            <summary>
            Do action to hide specified rows.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.HideRowsAction.Undo">
            <summary>
            Undo action to show hidden rows.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.HideRowsAction.Clone(unvell.ReoGrid.RangePosition)">
            <summary>
            Create a copy from this action in order to apply the operation to another range.
            </summary>
            <param name="range">New range where this operation will be appiled to.</param>
            <returns>New action instance copied from this action.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Actions.HideRowsAction.GetName">
            <summary>
            Get friendly name of this action.
            </summary>
            <returns>friendly name of this action.</returns>
        </member>
        <member name="T:unvell.ReoGrid.Actions.UnhideRowsAction">
            <summary>
            Action to unhide specified rows.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.UnhideRowsAction.#ctor(System.Int32,System.Int32)">
            <summary>
            Create action to show specified rows.
            </summary>
            <param name="row">number of row to start unhidden.</param>
            <param name="count">number of rows to be unhidden.</param>
        </member>
        <member name="M:unvell.ReoGrid.Actions.UnhideRowsAction.Do">
            <summary>
            Do action to show specified hidden rows.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.UnhideRowsAction.Undo">
            <summary>
            Undo action to hide visible rows.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.UnhideRowsAction.Clone(unvell.ReoGrid.RangePosition)">
            <summary>
            Create a copy from this action in order to apply the operation to another range.
            </summary>
            <param name="range">New range where this operation will be appiled to.</param>
            <returns>New action instance copied from this action.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Actions.UnhideRowsAction.GetName">
            <summary>
            Get friendly name of this action
            </summary>
            <returns>firendly name of this action</returns>
        </member>
        <member name="T:unvell.ReoGrid.Actions.HideColumnsAction">
            <summary>
            Action to hide specified columns
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.HideColumnsAction.#ctor(System.Int32,System.Int32)">
            <summary>
            Create action to hide specified columns.
            </summary>
            <param name="col">zero-based number of column to start hide columns.</param>
            <param name="count">number of columns to be hidden.</param>
        </member>
        <member name="M:unvell.ReoGrid.Actions.HideColumnsAction.Do">
            <summary>
            Perform action to hide specified columns.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.HideColumnsAction.Undo">
            <summary>
            Undo action to show hidden columns.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.HideColumnsAction.Clone(unvell.ReoGrid.RangePosition)">
            <summary>
            Create a copy from this action in order to apply the operation to another range.
            </summary>
            <param name="range">New range where this operation will be appiled to.</param>
            <returns>New action instance copied from this action.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Actions.HideColumnsAction.GetName">
            <summary>
            Get friendly name of this action.
            </summary>
            <returns></returns>
        </member>
        <member name="T:unvell.ReoGrid.Actions.UnhideColumnsAction">
            <summary>
            Unhide specified columns action
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.UnhideColumnsAction.#ctor(System.Int32,System.Int32)">
            <summary>
            Create action to show hidden columns
            </summary>
            <param name="col">Number of column start to unhide</param>
            <param name="count">Number of columns to be unhidden</param>
        </member>
        <member name="M:unvell.ReoGrid.Actions.UnhideColumnsAction.Do">
            <summary>
            Do action to show hidden columns
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.UnhideColumnsAction.Undo">
            <summary>
            Do action to hide specified visible columns
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.UnhideColumnsAction.Clone(unvell.ReoGrid.RangePosition)">
            <summary>
            Create a copy from this action in order to apply the operation to another range.
            </summary>
            <param name="range">New range where this operation will be appiled to.</param>
            <returns>New action instance copied from this action.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Actions.UnhideColumnsAction.GetName">
            <summary>
            Get friendly name of this action
            </summary>
            <returns>friendly name of this action</returns>
        </member>
        <member name="T:unvell.ReoGrid.Actions.SetRangeBorderAction">
            <summary>
            Action to set borders to specified range
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Actions.SetRangeBorderAction.Borders">
            <summary>
            Borders to be set
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.SetRangeBorderAction.#ctor(unvell.ReoGrid.RangePosition,unvell.ReoGrid.BorderPositions,unvell.ReoGrid.RangeBorderStyle)">
            <summary>
            Create action that perform setting border to a range
            </summary>
            <param name="range">Range to be appiled this action</param>
            <param name="pos">Position of range to set border</param>
            <param name="styles">Style of border</param>
        </member>
        <member name="M:unvell.ReoGrid.Actions.SetRangeBorderAction.#ctor(unvell.ReoGrid.RangePosition,unvell.ReoGrid.RangeBorderInfo[])">
            <summary>
            Create action that perform setting border to a range
            </summary>
            <param name="range">Range to be appiled this action</param>
            <param name="styles">Style of border</param>
        </member>
        <member name="M:unvell.ReoGrid.Actions.SetRangeBorderAction.Do">
            <summary>
            Do this action
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.SetRangeBorderAction.Undo">
            <summary>
            Undo this action
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.SetRangeBorderAction.GetName">
            <summary>
            Get friendly name of this action
            </summary>
            <returns></returns>
        </member>
        <member name="M:unvell.ReoGrid.Actions.SetRangeBorderAction.Clone(unvell.ReoGrid.RangePosition)">
            <summary>
            Create a copy from this action in order to apply the operation to another range.
            </summary>
            <param name="range">New range where this operation will be appiled to.</param>
            <returns>New action instance copied from this action.</returns>
        </member>
        <member name="T:unvell.ReoGrid.Actions.RemoveRangeBorderAction">
            <summary>
            Action of Removing borders from specified range
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Actions.RemoveRangeBorderAction.BorderPos">
            <summary>
            Get or set the position of borders to be removed
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.RemoveRangeBorderAction.#ctor(unvell.ReoGrid.RangePosition,unvell.ReoGrid.BorderPositions)">
            <summary>
            Create instance for SetRangeBorderAction with specified range and border styles.
            </summary>
            <param name="range">Range to be appiled this action</param>
            <param name="pos">Position of range to set border</param>
        </member>
        <member name="M:unvell.ReoGrid.Actions.RemoveRangeBorderAction.Do">
            <summary>
            Do this action
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.RemoveRangeBorderAction.Undo">
            <summary>
            Undo this action
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.RemoveRangeBorderAction.GetName">
            <summary>
            Get friendly name of this action
            </summary>
            <returns></returns>
        </member>
        <member name="M:unvell.ReoGrid.Actions.RemoveRangeBorderAction.Clone(unvell.ReoGrid.RangePosition)">
            <summary>
            Create a copy from this action in order to apply the operation to another range.
            </summary>
            <param name="range">New range where this operation will be appiled to.</param>
            <returns>New action instance copied from this action.</returns>
        </member>
        <member name="T:unvell.ReoGrid.Actions.MergeRangeAction">
            <summary>
            Merge range action
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.MergeRangeAction.#ctor(unvell.ReoGrid.RangePosition)">
            <summary>
            Create instance for MergeRangeAction with specified range
            </summary>
            <param name="range">The range to be merged</param>
        </member>
        <member name="M:unvell.ReoGrid.Actions.MergeRangeAction.Clone(unvell.ReoGrid.RangePosition)">
            <summary>
            Create a copy from this action in order to apply the operation to another range.
            </summary>
            <param name="range">New range where this operation will be appiled to.</param>
            <returns>New action instance copied from this action.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Actions.MergeRangeAction.Do">
            <summary>
            Do this operation.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.MergeRangeAction.Undo">
            <summary>
            Undo this operation.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.MergeRangeAction.GetName">
            <summary>
            Get friendly name of this action.
            </summary>
            <returns></returns>
        </member>
        <member name="T:unvell.ReoGrid.Actions.UnmergeRangeAction">
            <summary>
            Unmerge range action.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.UnmergeRangeAction.#ctor(unvell.ReoGrid.RangePosition)">
            <summary>
            Create instance for UnmergeRangeAction with specified range.
            </summary>
            <param name="range">The range to be unmerged</param>
        </member>
        <member name="M:unvell.ReoGrid.Actions.UnmergeRangeAction.Clone(unvell.ReoGrid.RangePosition)">
            <summary>
            Create a copy from this action in order to apply the operation to another range.
            </summary>
            <param name="range">New range where this operation will be appiled to.</param>
            <returns>New action instance copied from this action.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Actions.UnmergeRangeAction.Do">
            <summary>
            Do this action.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.UnmergeRangeAction.Undo">
            <summary>
            Undo this action.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.UnmergeRangeAction.GetName">
            <summary>
            Get friendly name of this action.
            </summary>
            <returns></returns>
        </member>
        <member name="T:unvell.ReoGrid.Actions.SetCellDataAction">
            <summary>
            Set data of cell action.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Actions.SetCellDataAction.Row">
            <summary>
            Index of row to set data.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Actions.SetCellDataAction.Col">
            <summary>
            Index of column to set data.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Actions.SetCellDataAction.Data">
            <summary>
            Data of cell.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.SetCellDataAction.#ctor(System.Int32,System.Int32,System.Object)">
            <summary>
            Create SetCellValueAction with specified index of row and column.
            </summary>
            <param name="row">index of row to set data.</param>
            <param name="col">index of column to set data.</param>
            <param name="data">data to be set.</param>
        </member>
        <member name="M:unvell.ReoGrid.Actions.SetCellDataAction.#ctor(unvell.ReoGrid.CellPosition,System.Object)">
            <summary>
            Create SetCellValueAction with specified index of row and column.
            </summary>
            <param name="pos">position to locate the cell to be set.</param>
            <param name="data">data to be set.</param>
        </member>
        <member name="M:unvell.ReoGrid.Actions.SetCellDataAction.#ctor(System.String,System.Object)">
            <summary>
            Create action to set cell data.
            </summary>
            <param name="address">address to locate specified cell.</param>
            <param name="data">data to be set.</param>
        </member>
        <member name="M:unvell.ReoGrid.Actions.SetCellDataAction.Do">
            <summary>
            Do this operation.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.SetCellDataAction.Undo">
            <summary>
            Undo this operation.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.SetCellDataAction.GetName">
            <summary>
            Get friendly name of this action
            </summary>
            <returns></returns>
        </member>
        <member name="T:unvell.ReoGrid.Actions.SetRangeDataFormatAction">
            <summary>
            Set range data format action.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.SetRangeDataFormatAction.#ctor(unvell.ReoGrid.RangePosition,unvell.ReoGrid.DataFormat.CellDataFormatFlag,System.Object)">
            <summary>
            Create instance for SetRangeDataFormatAction.
            </summary>
            <param name="range">Range to be appiled this action.</param>
            <param name="format">Format type of cell to be set.</param>
            <param name="dataFormatArgs">Argument belongs to format type to be set.</param>
        </member>
        <member name="M:unvell.ReoGrid.Actions.SetRangeDataFormatAction.Do">
            <summary>
            Do this operation.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.SetRangeDataFormatAction.Undo">
            <summary>
            Undo this operation.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.SetRangeDataFormatAction.Clone(unvell.ReoGrid.RangePosition)">
            <summary>
            Create a copy from this action in order to apply the operation to another range.
            </summary>
            <param name="range">New range where this operation will be appiled to.</param>
            <returns>New action instance copied from this action.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Actions.SetRangeDataFormatAction.GetName">
            <summary>
            Get friendly name of this action.
            </summary>
            <returns>friendly name of this action.</returns>
        </member>
        <member name="T:unvell.ReoGrid.Actions.SetRangeDataAction">
            <summary>
            Create action to set data into specified range of spreadsheet.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.SetRangeDataAction.#ctor(unvell.ReoGrid.RangePosition,System.Object[0:,0:])">
            <summary>
            Create action to set data into specified range of spreadsheet.
            </summary>
            <param name="range">range to set specified data.</param>
            <param name="data">data to be set.</param>
        </member>
        <member name="M:unvell.ReoGrid.Actions.SetRangeDataAction.Clone(unvell.ReoGrid.RangePosition)">
            <summary>
            Create a copy from this action in order to apply the operation to another range.
            </summary>
            <param name="range">New range where this operation will be appiled to.</param>
            <returns>New action instance copied from this action.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Actions.SetRangeDataAction.Do">
            <summary>
            Do action to set data into specified range of spreadsheet
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.SetRangeDataAction.Undo">
            <summary>
            Undo action to remove data which has been set into specified range of spreadsheet
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.SetRangeDataAction.GetName">
            <summary>
            Get friendly name of this action.
            </summary>
            <returns>friendly name of this action.</returns>
        </member>
        <member name="T:unvell.ReoGrid.Actions.RemoveRangeDataAction">
            <summary>
            Action to remove data from specified range.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.RemoveRangeDataAction.#ctor(unvell.ReoGrid.RangePosition)">
            <summary>
            Create action to remove data from specified range.
            </summary>
            <param name="range">data from cells in this range will be removed.</param>
        </member>
        <member name="M:unvell.ReoGrid.Actions.RemoveRangeDataAction.Clone(unvell.ReoGrid.RangePosition)">
            <summary>
            Create a copy from this action in order to apply the operation to another range.
            </summary>
            <param name="range">New range where this operation will be appiled to.</param>
            <returns>New action instance copied from this action.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Actions.RemoveRangeDataAction.Do">
            <summary>
            Do action to remove data from specified range.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.RemoveRangeDataAction.Undo">
            <summary>
            Undo action to restore removed data.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.RemoveRangeDataAction.GetName">
            <summary>
            Get friendly name of this action.
            </summary>
            <returns>friendly name of this action.</returns>
        </member>
        <member name="T:unvell.ReoGrid.Actions.MoveRangeAction">
            <summary>
            Action to move specified range from a position to another position.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Actions.MoveRangeAction.ContentFlags">
            <summary>
            Specifies the content to be moved: data, borders and styles.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Actions.MoveRangeAction.FromRange">
            <summary>
            Range to be moved.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Actions.MoveRangeAction.ToPosition">
            <summary>
            Position that range will be moved to.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.MoveRangeAction.#ctor(unvell.ReoGrid.RangePosition,unvell.ReoGrid.CellPosition)">
            <summary>
            Construct this action to move specified range from a position to another position.
            </summary>
            <param name="fromRange">range to be moved.</param>
            <param name="toPosition">position to be moved to.</param>
        </member>
        <member name="M:unvell.ReoGrid.Actions.MoveRangeAction.Do">
            <summary>
            Do this action.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.MoveRangeAction.Undo">
            <summary>
            Undo this action.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.MoveRangeAction.GetName">
            <summary>
            Get friendly name of this action.
            </summary>
            <returns>friendly name of this action.</returns>
        </member>
        <member name="T:unvell.ReoGrid.Actions.CopyRangeAction">
            <summary>
            Action to copy the specified range from a position to another position.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Actions.CopyRangeAction.ContentFlags">
            <summary>
            Specifies the content to be moved: data, borders and styles.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Actions.CopyRangeAction.FromRange">
            <summary>
            Range to be moved
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Actions.CopyRangeAction.ToPosition">
            <summary>
            Position that range will be moved to
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.CopyRangeAction.#ctor(unvell.ReoGrid.RangePosition,unvell.ReoGrid.CellPosition)">
            <summary>
            Construct this action to move specified range from a position to another position
            </summary>
            <param name="fromRange">range to be moved</param>
            <param name="toPosition">position to be moved to</param>
        </member>
        <member name="M:unvell.ReoGrid.Actions.CopyRangeAction.Do">
            <summary>
            Do this action.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.CopyRangeAction.Undo">
            <summary>
            Undo this action.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.CopyRangeAction.GetName">
            <summary>
            Get friendly name of this action.
            </summary>
            <returns>friendly name of this action.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Actions.RGSetPartialGridAction.#ctor(unvell.ReoGrid.RangePosition,unvell.ReoGrid.PartialGrid)">
            <summary>
            Create action to set partial grid.
            </summary>
            <param name="range">Range to set grid.</param>
            <param name="data">Data of partial grid to be set.</param>
        </member>
        <member name="T:unvell.ReoGrid.Actions.SetPartialGridAction">
            <summary>
            Action to set partial grid.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.SetPartialGridAction.#ctor(unvell.ReoGrid.RangePosition,unvell.ReoGrid.PartialGrid)">
            <summary>
            Create action to set partial grid.
            </summary>
            <param name="range">target range to set partial grid.</param>
            <param name="data">partial grid to be set.</param>
        </member>
        <member name="M:unvell.ReoGrid.Actions.SetPartialGridAction.Do">
            <summary>
            Do action to set partial grid.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.SetPartialGridAction.Undo">
            <summary>
            Undo action to restore setting partial grid.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.SetPartialGridAction.GetName">
            <summary>
            Get friendly name of this action.
            </summary>
            <returns>Friendly name of this action.</returns>
        </member>
        <member name="T:unvell.ReoGrid.Actions.CreateAutoFilterAction">
            <summary>
            Action to create column filter
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Actions.CreateAutoFilterAction.Range">
            <summary>
            Get filter apply range.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Actions.CreateAutoFilterAction.AutoColumnFilter">
            <summary>
            Get auto column filter instance created by this action. (Will be null before doing action)
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.CreateAutoFilterAction.#ctor(unvell.ReoGrid.RangePosition)">
            <summary>
            Create action to create column filter
            </summary>
            <param name="range">filter range</param>
        </member>
        <member name="M:unvell.ReoGrid.Actions.CreateAutoFilterAction.Undo">
            <summary>
            Undo action to remove column filter that is created by this action
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.CreateAutoFilterAction.Do">
            <summary>
            Do action to create column filter
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.CreateAutoFilterAction.GetName">
            <summary>
            Get friendly name of this action
            </summary>
            <returns>friendly name of this action</returns>
        </member>
        <member name="T:unvell.ReoGrid.Actions.BaseOutlineAction">
            <summary>
            Base class for all classes of outline actions
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Actions.BaseOutlineAction.rowOrColumn">
            <summary>
            Outline direction.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Actions.BaseOutlineAction.RowOrColumn">
            <summary>
            Specify row or column outline
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.BaseOutlineAction.#ctor(unvell.ReoGrid.RowOrColumn)">
            <summary>
            Create base outline action instance
            </summary>
            <param name="rowOrColumn">Flag to specify row or column</param>
        </member>
        <member name="M:unvell.ReoGrid.Actions.BaseOutlineAction.GetRowOrColumnDesc">
            <summary>
            Get description text of outline direction.
            </summary>
            <returns>Text of outline direction.</returns>
        </member>
        <member name="T:unvell.ReoGrid.Actions.OutlineAction">
            <summary>
            Base class for all classes of single outline action
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Actions.OutlineAction.Start">
            <summary>
            Number of line of start position to outilne
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Actions.OutlineAction.Count">
            <summary>
            Number of lines does outline include
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.OutlineAction.#ctor(unvell.ReoGrid.RowOrColumn,System.Int32,System.Int32)">
            <summary>
            Create base outline action instance
            </summary>
            <param name="rowOrColumn">Flag to specify row or column</param>
            <param name="start">Number of line to start add outline</param>
            <param name="count">Number of lines to be added into this outline</param>
        </member>
        <member name="T:unvell.ReoGrid.Actions.AddOutlineAction">
            <summary>
            Add outline action
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.AddOutlineAction.#ctor(unvell.ReoGrid.RowOrColumn,System.Int32,System.Int32)">
            <summary>
            Create action to add outline
            </summary>
            <param name="rowOrColumn">Row or column to be added</param>
            <param name="start">Number of line to start add outline</param>
            <param name="count">Number of lines to be added into this outline</param>
        </member>
        <member name="M:unvell.ReoGrid.Actions.AddOutlineAction.Do">
            <summary>
            Do this action
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.AddOutlineAction.Undo">
            <summary>
            Undo this action
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.AddOutlineAction.GetName">
            <summary>
            Get friendly name of this action
            </summary>
            <returns>Name of action</returns>
        </member>
        <member name="T:unvell.ReoGrid.Actions.RemoveOutlineAction">
            <summary>
            Remove outline action
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Actions.RemoveOutlineAction.RemovedOutline">
            <summary>
            Instance of removed outline if operation was successfully
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.RemoveOutlineAction.#ctor(unvell.ReoGrid.RowOrColumn,System.Int32,System.Int32)">
            <summary>
            Create action instance to remove outline
            </summary>
            <param name="rowOrColumn">Row or column to find specified outline</param>
            <param name="start">Number of line of specified outline</param>
            <param name="count">Number of lines of specified outline</param>
        </member>
        <member name="M:unvell.ReoGrid.Actions.RemoveOutlineAction.Do">
            <summary>
            Do this action
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.RemoveOutlineAction.Undo">
            <summary>
            Undo this action
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.RemoveOutlineAction.GetName">
            <summary>
            Get friendly name of this action
            </summary>
            <returns>Name of action</returns>
        </member>
        <member name="T:unvell.ReoGrid.Actions.CollapseOutlineAction">
            <summary>
            Action to collapse outline
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.CollapseOutlineAction.#ctor(unvell.ReoGrid.RowOrColumn,System.Int32,System.Int32)">
            <summary>
            Create action to collapse outline
            </summary>
            <param name="rowOrColumn">Row or column to find specified outline</param>
            <param name="start">Number of line of specified outline</param>
            <param name="count">Number of lines of specified outline</param>
        </member>
        <member name="M:unvell.ReoGrid.Actions.CollapseOutlineAction.Do">
            <summary>
            Do this action
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.CollapseOutlineAction.Undo">
            <summary>
            Undo this action
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.CollapseOutlineAction.GetName">
            <summary>
            Get friendly name of this action
            </summary>
            <returns>Name of action</returns>
        </member>
        <member name="T:unvell.ReoGrid.Actions.ExpandOutlineAction">
            <summary>
            Action to collapse outline
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.ExpandOutlineAction.#ctor(unvell.ReoGrid.RowOrColumn,System.Int32,System.Int32)">
            <summary>
            Create action instance to expand outline
            </summary>
            <param name="rowOrColumn">Row or column to find specified outline</param>
            <param name="start">Number of line of specified outline</param>
            <param name="count">Number of lines of specified outline</param>
        </member>
        <member name="M:unvell.ReoGrid.Actions.ExpandOutlineAction.Do">
            <summary>
            Do this action
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.ExpandOutlineAction.Undo">
            <summary>
            Undo this action
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.ExpandOutlineAction.GetName">
            <summary>
            Get friendly name of this action
            </summary>
            <returns>Name of action</returns>
        </member>
        <member name="T:unvell.ReoGrid.Actions.ClearOutlineAction">
            <summary>
            Action to clear all outlines
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.ClearOutlineAction.#ctor(unvell.ReoGrid.RowOrColumn)">
            <summary>
            Create action to clear all outlines on specified range
            </summary>
            <param name="rowOrColumn">The range to clear outlines (row, column or both row and column)</param>
        </member>
        <member name="M:unvell.ReoGrid.Actions.ClearOutlineAction.Do">
            <summary>
            Do this action
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.ClearOutlineAction.Undo">
            <summary>
            Undo this action
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Actions.ClearOutlineAction.GetName">
            <summary>
            Get friendly name of this action
            </summary>
            <returns>Name of action</returns>
        </member>
        <member name="T:unvell.ReoGrid.CellTypes.CellTypesManager">
            <summary>
            Manage the collection of available cell types 
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.CellTypes.CellTypesManager.CellTypes">
            <summary>
            Get the available collection of cell types
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.CellTypes.ICellBody">
            <summary>
            Represents cell body interface.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.ICellBody.OnSetup(unvell.ReoGrid.Cell)">
            <summary>
            This method invoked when cell body set into a cell.
            </summary>
            <param name="cell">The cell instance to load this body.</param>
        </member>
        <member name="P:unvell.ReoGrid.CellTypes.ICellBody.Bounds">
            <summary>
            Get the cell body bounds. (Relative position to owner cell)
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.ICellBody.OnBoundsChanged">
            <summary>
            This method invoked when body bounds is changed.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.ICellBody.AutoCaptureMouse">
            <summary>
            Determine whether or not to allow capture the mouse moving after mouse button pressed inside the body bounds.
            </summary>
            <returns>Return true to capture mouse after mouse down; Otherwise return false to do nothing.</returns>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.ICellBody.OnMouseDown(unvell.ReoGrid.Events.CellMouseEventArgs)">
            <summary>
            This method will be invoked when mouse button pressed inside the body bounds.
            </summary>
            <param name="e">Mouse event argument</param>
            <returns>Return true if event has been handled; Otherwise return false to recall default operations.</returns>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.ICellBody.OnMouseMove(unvell.ReoGrid.Events.CellMouseEventArgs)">
            <summary>
            This method will be invoked when mouse has been moved inside the body bounds.
            </summary>
            <param name="e">Mouse event argument</param>
            <returns>Return true if event has been handled; Otherwise false to recall default operations.</returns>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.ICellBody.OnMouseUp(unvell.ReoGrid.Events.CellMouseEventArgs)">
            <summary>
            This method will be invoked when mouse button released inside the body bounds.
            </summary>
            <param name="e">Mouse event argument</param>
            <returns>Return true if event has been handled; Otherwise false to recall default operations.</returns>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.ICellBody.OnMouseEnter(unvell.ReoGrid.Events.CellMouseEventArgs)">
            <summary>
            This method will be invoked when mouse moved enter the body bounds.
            </summary>
            <param name="e">Mouse event argument</param>
            <returns>Return true if event has been handled; Otherwise return false to recall default operations.</returns>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.ICellBody.OnMouseLeave(unvell.ReoGrid.Events.CellMouseEventArgs)">
            <summary>
            This method will be invoked when mouse moved out from the body bounds.
            </summary>
            <param name="e">Mouse event argument</param>
            <returns>Return true if event has been handled; Otherwise return false to recall default operations.</returns>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.ICellBody.OnMouseWheel(unvell.ReoGrid.Events.CellMouseEventArgs)">
            <summary>
            This method will be invoked when mouse scrolled inside the body bounds.
            </summary>
            <param name="e">Mouse event argument</param>
            <returns>Return true if event has been handled; Otherwise return false to recall default operations</returns>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.ICellBody.OnKeyDown(unvell.ReoGrid.Interaction.KeyCode)">
            <summary>
            This method will be invoked when any key pressed when body being focused.
            </summary>
            <param name="e">Mouse event argument.</param>
            <returns>Return true if event has been handled inside the body bounds; Otherwise return false to recall default operations.</returns>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.ICellBody.OnKeyUp(unvell.ReoGrid.Interaction.KeyCode)">
            <summary>
            This method will be invoked when any key released on this body.
            </summary>
            <param name="e">Mouse event argument.</param>
            <returns>Return true if event has been handled; Otherwise return false to recall default operations.</returns>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.ICellBody.OnPaint(unvell.ReoGrid.Rendering.CellDrawingContext)">
            <summary>
            This method will be invoked when cell body is required to repaint on worksheet.
            </summary>
            <param name="dc">Drawing context used to paint the cell body.</param>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.ICellBody.OnStartEdit">
            <summary>
            This method will be invoked when the owner cell of this body begin to edit. (Changing to editing mode)
            </summary>
            <returns>Return true to allow editing; Otherwise return false to abort editing operation.</returns>
        </member>
        <member name="P:unvell.ReoGrid.CellTypes.ICellBody.DisableWhenCellReadonly">
            <summary>
            Determines whether or not become disable when owner cell is set as read-only. 
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.ICellBody.OnEndEdit(System.Object)">
            <summary>
            This method will be invoked when the owner cell of this body finished edit.
            </summary>
            <param name="data">The data of user inputted.</param>
            <returns>Data used to be set into the cell. If don't want to change user data, return the data from method parameter.</returns>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.ICellBody.OnGotFocus">
            <summary>
            This method invoked when cell getting focus.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.ICellBody.OnLostFocus">
            <summary>
            This method invoked when cell losing focus.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.ICellBody.OnSetData(System.Object)">
            <summary>
            This method invoked when cell data was updated.
            </summary>
            <param name="data">The data will be set into the cell.</param>
            <returns>Return the new data used to set into the cell.</returns>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.ICellBody.Clone">
            <summary>
            Clone a cell body from this object.
            </summary>
            <returns>New instance of cell body.</returns>
        </member>
        <member name="T:unvell.ReoGrid.CellTypes.CellBody">
            <summary>
            Cell body
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.CellTypes.CellBody.Cell">
            <summary>
            Owner cell contains this body.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.CellBody.OnSetup(unvell.ReoGrid.Cell)">
            <summary>
            When the body set into a cell.
            </summary>
            <param name="cell">Current owner cell</param>
        </member>
        <member name="P:unvell.ReoGrid.CellTypes.CellBody.Bounds">
            <summary>
            Get cell body bounds rectangle.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.CellTypes.CellBody.DisableWhenCellReadonly">
            <summary>
            Determines whether or not become disable when owner cell is set as read-only. (Default is True)
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.CellBody.OnBoundsChanged">
            <summary>
            Invoked when body boundary has been changed.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.CellBody.AutoCaptureMouse">
            <summary>
            Determines whether or not to allow capture the mouse when mouse down inside this body.
            </summary>
            <returns>True to allow caption; False to abort capture.</returns>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.CellBody.OnMouseDown(unvell.ReoGrid.Events.CellMouseEventArgs)">
            <summary>
            This method will be invoked when mouse button pressed inside the body bounds.
            </summary>
            <param name="e">Mouse event argument.</param>
            <returns>Return true if event has been handled; Otherwise return false to recall default operations.</returns>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.CellBody.OnMouseMove(unvell.ReoGrid.Events.CellMouseEventArgs)">
            <summary>
            This method will be invoked when mouse has been moved inside the body bounds.
            </summary>
            <param name="e">Mouse event argument</param>
            <returns>Return true if event has been handled; Otherwise false to recall default operations.</returns>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.CellBody.OnMouseUp(unvell.ReoGrid.Events.CellMouseEventArgs)">
            <summary>
            This method will be invoked when any key released on this body.
            </summary>
            <param name="e">Mouse event argument.</param>
            <returns>Return true if event has been handled; Otherwise return false to recall default operations.</returns>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.CellBody.OnMouseEnter(unvell.ReoGrid.Events.CellMouseEventArgs)">
            <summary>
            Invoked when mouse moved enter this body.
            </summary>
            <param name="e">Mouse event argument.</param>
            <returns>True if event has been handled inside this body, otherwise false to recall built-in operations.</returns>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.CellBody.OnMouseLeave(unvell.ReoGrid.Events.CellMouseEventArgs)">
            <summary>
            Invoked when mouse moved out from this body.
            </summary>
            <param name="e">Mouse event argument.</param>
            <returns>True if event has been handled inside this body, otherwise false to recall built-in operations.</returns>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.CellBody.OnMouseWheel(unvell.ReoGrid.Events.CellMouseEventArgs)">
            <summary>
            Invoked when mouse scrolled inside this body.
            </summary>
            <param name="e">Mouse event argument.</param>
            <returns>True if event has been handled inside this body, otherwise false to recall built-in operations.</returns>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.CellBody.OnKeyDown(unvell.ReoGrid.Interaction.KeyCode)">
            <summary>
            Invoked when any key pressed on this body.
            </summary>
            <param name="e">Mouse event argument.</param>
            <returns>True if event has been handled inside this body, otherwise false to recall built-in operations.</returns>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.CellBody.OnKeyUp(unvell.ReoGrid.Interaction.KeyCode)">
            <summary>
            Invoked when any key released on this body.
            </summary>
            <param name="e">Mouse event argument.</param>
            <returns>True if event has been handled inside this body, otherwise false to recall built-in operations.</returns>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.CellBody.OnPaint(unvell.ReoGrid.Rendering.CellDrawingContext)">
            <summary>
            Paint the content of body.
            </summary>
            <param name="dc">Platform independency graphics context.</param>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.CellBody.OnStartEdit">
            <summary>
            Invoked when cell of this body begin to edit. (Enter edit mode)
            </summary>
            <returns>True to allow edit; Otherwise false to cancel edit.</returns>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.CellBody.OnEndEdit(System.Object)">
            <summary>
            Invoked when cell of this body finish edit. 
            Return data to be set into spreadsheet instead of user inputted.
            </summary>
            <param name="data">user inputted data.</param>
            <returns>new data to be into spreadsheet.</returns>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.CellBody.OnGotFocus">
            <summary>
            Invoked when cell get focus.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.CellBody.OnLostFocus">
            <summary>
            Invoked when cell lost focus.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.CellBody.OnSetData(System.Object)">
            <summary>
            Invoked when cell data updating.
            </summary>
            <param name="data">Data to be updated.</param>
            <returns>New data that is used to replace the data inputted.</returns>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.CellBody.Clone">
            <summary>
            Clone a cell body from this object.
            </summary>
            <returns>New instance of cell body.</returns>
        </member>
        <member name="T:unvell.ReoGrid.CellTypes.ContentCellBody">
            <summary>
            Represents a cell body that maintains a visual content region for child objects, such as Check-box or Radio-button.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.CellTypes.ContentCellBody.ContentBounds">
            <summary>
            Get or set child content bounds rectangle.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.ContentCellBody.GetContentSize">
            <summary>
            Determines the preferred body size.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.ContentCellBody.OnBoundsChanged">
            <summary>
            Handles when bounds changed.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.ContentCellBody.OnPaint(unvell.ReoGrid.Rendering.CellDrawingContext)">
            <summary>
            Paint cell body.
            </summary>
            <param name="dc">Platform independency graphics context.</param>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.ContentCellBody.OnContentPaint(unvell.ReoGrid.Rendering.CellDrawingContext)">
            <summary>
            Paint content of cell body.
            </summary>
            <param name="dc">Platform independency graphics context.</param>
        </member>
        <member name="T:unvell.ReoGrid.CellTypes.IHeaderBody">
            <summary>
            Represent the interface of row and column header body
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.IHeaderBody.OnPaint(unvell.ReoGrid.Rendering.CellDrawingContext,unvell.ReoGrid.Graphics.Size)">
            <summary>
            Onwer drawing
            </summary>
            <param name="dc">Drawing context</param>
            <param name="headerSize">Header size</param>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.IHeaderBody.OnMouseMove(unvell.ReoGrid.Graphics.Size,unvell.ReoGrid.Events.WorksheetMouseEventArgs)">
            <summary>
            Mouse move event
            </summary>
            <param name="headerSize">Header size</param>
            <param name="e">Event argument</param>
            <returns>true if this event is handled</returns>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.IHeaderBody.OnMouseDown(unvell.ReoGrid.Graphics.Size,unvell.ReoGrid.Events.WorksheetMouseEventArgs)">
            <summary>
            Mouse down event
            </summary>
            <param name="headerSize">Header size</param>
            <param name="e">Event argument</param>
            <returns>true if this event is handled</returns>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.IHeaderBody.OnDataChange(System.Int32,System.Int32)">
            <summary>
            Event when data in any cells on this header is changed
            </summary>
            <param name="startRow">Zero-based number of row of changed cells</param>
            <param name="endRow">Zero-based number of column of changed cells</param>
        </member>
        <member name="T:unvell.ReoGrid.CellTypes.HeaderBody">
            <summary>
            Represent the interface of row and column header body
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.HeaderBody.OnPaint(unvell.ReoGrid.Rendering.CellDrawingContext,unvell.ReoGrid.Graphics.Size)">
            <summary>
            Paint this header body.
            </summary>
            <param name="dc">Drawing context</param>
            <param name="headerSize">Header size</param>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.HeaderBody.OnMouseMove(unvell.ReoGrid.Graphics.Size,unvell.ReoGrid.Events.WorksheetMouseEventArgs)">
            <summary>
            Method raised when mouse moving inside this body.
            </summary>
            <param name="headerSize">Header size</param>
            <param name="e">Event argument</param>
            <returns>true if this event is handled</returns>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.HeaderBody.OnMouseDown(unvell.ReoGrid.Graphics.Size,unvell.ReoGrid.Events.WorksheetMouseEventArgs)">
            <summary>
            Method raised when mouse pressed inside this body.
            </summary>
            <param name="headerSize">Header size</param>
            <param name="e">Event argument</param>
            <returns>true if this event is handled</returns>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.HeaderBody.OnDataChange(System.Int32,System.Int32)">
            <summary>
            Method raised when data changed from cells on this header.
            </summary>
            <param name="startRow">Zero-based number of row of changed cells.</param>
            <param name="endRow">Zero-based number of column of changed cells.</param>
        </member>
        <member name="T:unvell.ReoGrid.CellTypes.ButtonCell">
            <summary>
            Representation for button of cell body.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.ButtonCell.#ctor">
            <summary>
            Create button cell
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.ButtonCell.#ctor(System.String)">
            <summary>
            Create button cell with specified text.
            </summary>
            <param name="defaultText"></param>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.ButtonCell.OnSetup(unvell.ReoGrid.Cell)">
            <summary>
            On body is setup to cell.
            </summary>
            <param name="cell">cell instance</param>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.ButtonCell.OnPaint(unvell.ReoGrid.Rendering.CellDrawingContext)">
            <summary>
            Paint this cell body.
            </summary>
            <param name="dc">ReoGrid common drawing context</param>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.ButtonCell.DrawButton(unvell.ReoGrid.Rendering.CellDrawingContext)">
            <summary>
            Draw button surface.
            </summary>
            <param name="dc">Platform independence drawing context.</param>
            <param name="state">Button state.</param>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.ButtonCell.OnMouseDown(unvell.ReoGrid.Events.CellMouseEventArgs)">
            <summary>
            Invoked when mouse down inside this body
            </summary>
            <param name="e">mouse event argument</param>
            <returns>true if event has been handled</returns>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.ButtonCell.OnMouseUp(unvell.ReoGrid.Events.CellMouseEventArgs)">
            <summary>
            Determine whether the button is pressed or released
            </summary>
            <param name="e">mouse event argument</param>
            <returns>true to notify spreadsheet that event has been handled</returns>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.ButtonCell.OnKeyDown(unvell.ReoGrid.Interaction.KeyCode)">
            <summary>
            Check when user pressed Space key to press button.
            </summary>
            <param name="keyCode">Virtual keys code that is converted from system platform.</param>
            <returns>True to notify spreadsheet that event has been handled</returns>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.ButtonCell.OnKeyUp(unvell.ReoGrid.Interaction.KeyCode)">
            <summary>
            Check when user released Space key to restore button.
            </summary>
            <param name="keyCode">Virtual keys code that is converted from system platform.</param>
            <returns>True to notify spreadsheet that event has been handled.</returns>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.ButtonCell.OnStartEdit">
            <summary>
            Return false to disable edit operation for this cell.
            </summary>
            <returns>False to disable edit operation for this cell.</returns>
        </member>
        <member name="P:unvell.ReoGrid.CellTypes.ButtonCell.IsPressed">
            <summary>
            Check whether or not button is pressed.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.ButtonCell.PerformClick">
            <summary>
            Perform click operation.
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.CellTypes.ButtonCell.Click">
            <summary>
            Click event raised when user clicked on the button.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.ButtonCell.Clone">
            <summary>
            Clone a button cell from this object.
            </summary>
            <returns>New instance of button cell.</returns>
        </member>
        <member name="T:unvell.ReoGrid.CellTypes.ProgressCell">
            <summary>
            Representation for a button of cell body
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.CellTypes.ProgressCell.TopColor">
            <summary>
            Get or set the top color.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.CellTypes.ProgressCell.BottomColor">
            <summary>
            Get or set the bottom color.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.ProgressCell.#ctor">
            <summary>
            Create progress cell body.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.ProgressCell.OnPaint(unvell.ReoGrid.Rendering.CellDrawingContext)">
            <summary>
            Render the progress cell body.
            </summary>
            <param name="dc"></param>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.ProgressCell.Clone">
            <summary>
            Clone a progress bar from this object.
            </summary>
            <returns>New instance of progress bar.</returns>
        </member>
        <member name="T:unvell.ReoGrid.CellTypes.HyperlinkCell">
            <summary>
            Representation for hyperlink of cell body.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.CellTypes.HyperlinkCell.ActivateColor">
            <summary>
            Get or set color of mouse-hover status.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.CellTypes.HyperlinkCell.LinkColor">
            <summary>
            Get or set color of normal hyperlink.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.CellTypes.HyperlinkCell.VisitedColor">
            <summary>
            Get or set color of visited status.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.CellTypes.HyperlinkCell.LinkURL">
            <summary>
            Get or set the navigation url. (Redirected when AutoNavigation property is true)
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.HyperlinkCell.#ctor">
            <summary>
            Create hyperlink cell body instance.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.HyperlinkCell.#ctor(System.String)">
            <summary>
            Create instane of hyperlink cell body with specified navigation url and AutoNavigate property.
            </summary>
            <param name="navigationURL">Navigation url redirected to when hyperlink clicked. (Default is emtpy)</param>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.HyperlinkCell.#ctor(System.String,System.Boolean)">
            <summary>
            Create instane of hyperlink cell body with specified navigation url and AutoNavigate property.
            </summary>
            <param name="navigationURL">Navigation url redirected to when hyperlink clicked. (Default is emtpy)</param>
            <param name="autoNavigate">Determine whether or not redirect to specified url 
            when hyperlink clicked automatically. (Default is true)</param>
        </member>
        <member name="P:unvell.ReoGrid.CellTypes.HyperlinkCell.IsPressed">
            <summary>
            Determine whether or not the hyperlink is in pressed status.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.HyperlinkCell.OnStartEdit">
            <summary>
            Handle event when the cell of this body entered edit mode.
            </summary>
            <returns>True to allow edit; False to disallow edit.</returns>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.HyperlinkCell.OnSetup(unvell.ReoGrid.Cell)">
            <summary>
            Initialize cell body when set up into a cell.
            </summary>
            <param name="cell">Instance of cell to be set up.</param>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.HyperlinkCell.OnMouseDown(unvell.ReoGrid.Events.CellMouseEventArgs)">
            <summary>
            Change color of hyperlink to activate-status when mouse button pressed inside cell.
            </summary>
            <param name="e">Event argument of cell body mouse-down.</param>
            <returns>True if event has been handled.</returns>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.HyperlinkCell.OnMouseUp(unvell.ReoGrid.Events.CellMouseEventArgs)">
            <summary>
            Restore color of hyperlink to normal-status or hover-status when mouse button was released from cell.
            </summary>
            <param name="e">Event argument of cell body mouse-up.</param>
            <returns>True if event has been handled.</returns>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.HyperlinkCell.OnMouseEnter(unvell.ReoGrid.Events.CellMouseEventArgs)">
            <summary>
            Change color of hyperlink to hover-status when mouse moved into the cell.
            </summary>
            <param name="e">Event argument of cell body mouse-enter.</param>
            <returns>True if event has been handled.</returns>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.HyperlinkCell.OnMouseLeave(unvell.ReoGrid.Events.CellMouseEventArgs)">
            <summary>
            Restore color of hyperlink from hover-status when mouse leaved from cell.
            </summary>
            <param name="e">Argument of mouse leaving event.</param>
            <returns>True if this event has been handled; Otherwise return false.</returns>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.HyperlinkCell.OnKeyDown(unvell.ReoGrid.Interaction.KeyCode)">
            <summary>
            Handle keyboard down event.
            </summary>
            <param name="keyCode">Virtual keys code that is converted from system platform.</param>
            <returns>True if event has been handled; Otherwise return false.</returns>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.HyperlinkCell.OnKeyUp(unvell.ReoGrid.Interaction.KeyCode)">
            <summary>
            Handle keyboard up event.
            </summary>
            <param name="keyCode">Virtual keys code that is converted from system platform.</param>
            <returns>True if event has been handled; Otherwise return false;</returns>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.HyperlinkCell.OnLostFocus">
            <summary>
            Handle event if cell has lost focus.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.HyperlinkCell.PerformClick">
            <summary>
            Manually fire the hyperlink click event.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.HyperlinkCell.OnSetData(System.Object)">
            <summary>
            When data of cell set, read navigation url from cell data
            </summary>
            <param name="data">New data to be set</param>
            <returns>Replacement data if needed</returns>
        </member>
        <member name="E:unvell.ReoGrid.CellTypes.HyperlinkCell.Click">
            <summary>
            Event raised when hyperlink was preseed
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.CellTypes.HyperlinkCell.AutoNavigate">
            <summary>
            Determine whether or not redirect to navigation url when hyperlink was pressed
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.CellTypes.CheckBoxCell">
            <summary>
            Representation for check box of cell body
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.CheckBoxCell.#ctor">
            <summary>
            Create check box cell body.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.CheckBoxCell.#ctor(System.Boolean)">
            <summary>
            Create check box cell body.
            </summary>
            <param name="initChecked">Set the initial status. If this value is true, checkbox keep checked status when added into a cell.</param>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.CheckBoxCell.OnSetup(unvell.ReoGrid.Cell)">
            <summary>
            Override OnSetup method to set initial checked status.
            </summary>
            <param name="cell">The cell this body will set into.</param>
        </member>
        <member name="P:unvell.ReoGrid.CellTypes.CheckBoxCell.IsPressed">
            <summary>
            Determines whether or not mouse or key pressed inside check box.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.CheckBoxCell.OnMouseDown(unvell.ReoGrid.Events.CellMouseEventArgs)">
            <summary>
            Handle the mouse down event.
            </summary>
            <param name="e">Arguments of mouse down event.</param>
            <returns>True if event has been handled; Otherwise return false.</returns>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.CheckBoxCell.OnMouseUp(unvell.ReoGrid.Events.CellMouseEventArgs)">
            <summary>
            Handle the mouse up event.
            </summary>
            <param name="e">Arguments of mouse up event.</param>
            <returns>True if event has been handled; Otherwise return false.</returns>
        </member>
        <member name="E:unvell.ReoGrid.CellTypes.CheckBoxCell.Click">
            <summary>
            Event raied when user clicked inside check box.
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.CellTypes.CheckBoxCell.CheckChanged">
            <summary>
            Event raised when check status changed.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.CheckBoxCell.RaiseClickEvent">
            <summary>
            Raise the click event.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.CheckBoxCell.RaiseCheckChangedEvent">
            <summary>
            Raise the click event.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.CheckBoxCell.OnContentPaint(unvell.ReoGrid.Rendering.CellDrawingContext)">
            <summary>
            Paint content of cell body.
            </summary>
            <param name="dc">Platform independency graphics context.</param>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.CheckBoxCell.OnSetData(System.Object)">
            <summary>
            Handle event when data set into the cell of this body.
            </summary>
            <param name="data">Data inputted by user.</param>
            <returns>Data to be set into the cell.</returns>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.CheckBoxCell.ToggleCheckStatus">
            <summary>
            Toggle the check status of check box.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.CellTypes.CheckBoxCell.Checked">
            <summary>
            Determines whether or not check-box is pressed or checked.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.CellTypes.CheckBoxCell.isChecked">
            <summary>
            Check status.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.CellTypes.CheckBoxCell.IsChecked">
            <summary>
            Get or set the check-status of check box.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.CheckBoxCell.OnKeyDown(unvell.ReoGrid.Interaction.KeyCode)">
            <summary>
            Handle keyboard down event.
            </summary>
            <param name="keyCode">Virtual keys that are pressed.</param>
            <returns>True if event has been marked as handled.</returns>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.CheckBoxCell.OnKeyUp(unvell.ReoGrid.Interaction.KeyCode)">
            <summary>
            Handle keyboard up event.
            </summary>
            <param name="keyCode">Virtual keys code that is converted from system platform.</param>
            <returns>True if event has been handled; Otherwise return false.</returns>
        </member>
        <member name="T:unvell.ReoGrid.CellTypes.RadioButtonGroup">
            <summary>
            Radio button group for toggling radios inside one group.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.RadioButtonGroup.AddRadioButton(unvell.ReoGrid.CellTypes.RadioButtonCell)">
            <summary>
            Add radio button into this group.
            </summary>
            <param name="cell"></param>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.RadioButtonGroup.Contains(unvell.ReoGrid.CellTypes.RadioButtonCell)">
            <summary>
            Check whether specified radio is contained by this group.
            </summary>
            <param name="cell">radio cell body to be checked.</param>
            <returns>true if the radio cell body is contained by this group.</returns>
        </member>
        <member name="T:unvell.ReoGrid.CellTypes.RadioButtonCell">
            <summary>
            Representation for a radio button of cell body.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.RadioButtonCell.#ctor">
            <summary>
            Create instance of radio button cell.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.CellTypes.RadioButtonCell.RadioGroup">
            <summary>
            Radio groups for toggling other radios inside same group.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.CellTypes.RadioButtonCell.IsChecked">
            <summary>
            Get or set check status for radio button
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.RadioButtonCell.ToggleCheckStatus">
            <summary>
            Toggle check status of radio-button. (Only work when radio button not be added into any groups)
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.RadioButtonCell.OnContentPaint(unvell.ReoGrid.Rendering.CellDrawingContext)">
            <summary>
            Paint content of cell body.
            </summary>
            <param name="dc">Platform independency graphics context.</param>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.RadioButtonCell.Clone">
            <summary>
            Clone radio button from this object.
            </summary>
            <returns>New instance of radio button.</returns>
        </member>
        <member name="T:unvell.ReoGrid.CellTypes.ImageCell">
            <summary>
            Representation for an image of cell body
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.CellTypes.ImageCell.Image">
            <summary>
            Get or set the image to be displayed in cell
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.ImageCell.#ctor">
            <summary>
            Create image cell object.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.ImageCell.#ctor(System.Windows.Media.ImageSource)">
            <summary>
            Construct image cell-body to show a specified image
            </summary>
            <param name="image">Image to be displayed</param>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.ImageCell.#ctor(System.Windows.Media.ImageSource,unvell.ReoGrid.CellTypes.ImageCellViewMode)">
            <summary>
            Construct image cell-body to show a image by specified display-method
            </summary>
            <param name="image">Image to be displayed</param>
            <param name="viewMode">View mode decides how to display a image inside a cell</param>
        </member>
        <member name="P:unvell.ReoGrid.CellTypes.ImageCell.ViewMode">
            <summary>
            Set or get the view mode of this image cell
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.CellTypes.ImageCell.OnPaint(unvell.ReoGrid.Rendering.CellDrawingContext)">
            <summary>
            Render the image cell body.
            </summary>
            <param name="dc">Platform no-associated drawing context instance.</param>
        </member>
        <member name="T:unvell.ReoGrid.CellTypes.ImageCellViewMode">
            <summary>
            Image dispaly method in ImageCell-body
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.CellTypes.ImageCellViewMode.Stretch">
            <summary>
            Fill to cell boundary. (default)
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.CellTypes.ImageCellViewMode.Zoom">
            <summary>
            Lock aspect ratio to fit cell boundary.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.CellTypes.ImageCellViewMode.Clip">
            <summary>
            Keep original image size and clip to fill the cell.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.ReoGridControl">
            <summary>
            ReoGrid Spreadsheet Control
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridControl.CreateMemoryWorkbook">
            <summary>
            Create an instance of ReoGrid workbook in memory. <br/>
            The memory workbook is the non-GUI version of ReoGrid control, which can do almost all operations, 
            such as reading and saving from Excel file, RGF file, changing data, formulas, styles, borders and etc.
            </summary>
            <returns>Instance of memory workbook.</returns>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridControl.Save(System.String)">
            <summary>
            Save workbook into file
            </summary>
            <param name="path">Full file path to save workbook</param>
            <param name="fileFormat">Specified file format used to save workbook</param>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridControl.Save(System.String,unvell.ReoGrid.IO.FileFormat)">
            <summary>
            Save workbook into file
            </summary>
            <param name="path">Full file path to save workbook</param>
            <param name="fileFormat">Specified file format used to save workbook</param>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridControl.Save(System.String,unvell.ReoGrid.IO.FileFormat,System.Text.Encoding)">
            <summary>
            Save workbook into file
            </summary>
            <param name="path">Full file path to save workbook</param>
            <param name="fileFormat">Specified file format used to save workbook</param>
            <param name="encoding">Encoding used to read plain-text from resource. (Optional)</param>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridControl.Save(System.IO.Stream,unvell.ReoGrid.IO.FileFormat)">
            <summary>
            Save workbook into stream with specified format
            </summary>
            <param name="stream">Stream to output data of workbook</param>
            <param name="fileFormat">Specified file format used to save workbook</param>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridControl.Save(System.IO.Stream,unvell.ReoGrid.IO.FileFormat,System.Text.Encoding)">
            <summary>
            Save workbook into stream with specified format
            </summary>
            <param name="stream">Stream to output data of workbook</param>
            <param name="fileFormat">Specified file format used to save workbook</param>
            <param name="encoding">Encoding used to read plain-text from resource. (Optional)</param>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridControl.Load(System.String)">
            <summary>
            Load workbook from file by specified path.
            </summary>
            <param name="path">Path to open file and read data.</param>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridControl.Load(System.String,unvell.ReoGrid.IO.FileFormat)">
            <summary>
            Load workbook from file by specified path.
            </summary>
            <param name="path">Path to open file and read data.</param>
            <param name="fileFormat">Flag used to determine what format should be used to read data from file.</param>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridControl.Load(System.String,unvell.ReoGrid.IO.FileFormat,System.Text.Encoding)">
            <summary>
            Load workbook from file with specified format
            </summary>
            <param name="path">Path to open file and read data.</param>
            <param name="fileFormat">Flag used to determine what format should be used to read data from file.</param>
            <param name="encoding">Encoding used to read plain-text from resource. (Optional)</param>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridControl.Load(System.IO.Stream,unvell.ReoGrid.IO.FileFormat)">
            <summary>
            Load workbook from stream with specified format.
            </summary>
            <param name="stream">Stream to read data of workbook.</param>
            <param name="fileFormat">Flag used to determine what format should be used to read data from file.</param>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridControl.Load(System.IO.Stream,unvell.ReoGrid.IO.FileFormat,System.Text.Encoding)">
            <summary>
            Load workbook from stream with specified format.
            </summary>
            <param name="stream">Stream to read data of workbook.</param>
            <param name="fileFormat">Flag used to determine what format should be used to read data from file.</param>
            <param name="encoding">Encoding used to read plain-text data from specified stream.</param>
        </member>
        <member name="E:unvell.ReoGrid.ReoGridControl.WorkbookLoaded">
            <summary>
            Event raised when workbook loaded from stream or file.
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.ReoGridControl.WorkbookSaved">
            <summary>
            Event raised when workbook saved into stream or file.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReoGridControl.CurrentWorksheet">
            <summary>
            Get or set the current worksheet
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridControl.CreateWorksheet">
            <summary>
            Create new instance of worksheet with default available name. (e.g. Sheet1, Sheet2 ...)
            </summary>
            <returns>Instance of worksheet to be created.</returns>
            <remarks>This method creates a new worksheet, but doesn't add it into the collection of worksheet.
            Worksheet will only be available until adding into a workbook, by using these methods:
            <code>InsertWorksheet</code>, <code>Worksheets.Add</code> or <code>Worksheets.Insert</code>
            </remarks>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridControl.CreateWorksheet(System.String)">
            <summary>
            Create new instance of worksheet.
            </summary>
            <param name="name">name of new worksheet to be created. 
            If name is null, ReoGrid will find an available name automatically. e.g. 'Sheet1', 'Sheet2'...</param>
            <returns>instance of worksheet to be created</returns>
            <remarks>This method creates a new worksheet, but doesn't add it into the collection of worksheet.
            Worksheet will only be available until adding into a workbook, by using these methods:
            <code>InsertWorksheet</code>, <code>Worksheets.Add</code> or <code>Worksheets.Insert</code>
            </remarks>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridControl.AddWorksheet(unvell.ReoGrid.Worksheet)">
            <summary>
            Add specified worksheet into this workbook
            </summary>
            <param name="sheet">worksheet to be added</param>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridControl.NewWorksheet(System.String)">
            <summary>
            Create and append a new instance of worksheet into workbook.
            </summary>
            <param name="name">Optional name for new worksheet.</param>
            <returns>Instance of created new worksheet.</returns>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridControl.InsertWorksheet(System.Int32,unvell.ReoGrid.Worksheet)">
            <summary>
            Insert specified worksheet into this workbook
            </summary>
            <param name="index">position of zero-based number of worksheet used to insert specified worksheet</param>
            <param name="sheet">worksheet to be inserted</param>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridControl.RemoveWorksheet(System.Int32)">
            <summary>
            Remove worksheet from this workbook by specified index
            </summary>
            <param name="index">zero-based number of worksheet to be removed</param>
            <returns>true if specified worksheet can be found and removed successfully</returns>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridControl.RemoveWorksheet(unvell.ReoGrid.Worksheet)">
            <summary>
            Remove worksheet from this workbook
            </summary>
            <param name="sheet">worksheet to be removed</param>
            <returns>true if specified worksheet can be found and removed successfully</returns>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridControl.CopyWorksheet(System.Int32,System.Int32,System.String)">
            <summary>
            Create a cloned worksheet and put into specified position
            </summary>
            <param name="index">Index of source worksheet to be copied</param>
            <param name="newIndex">Target index used to insert the copied worksheet</param>
            <param name="newName">Name for new worksheet, set as null to use a default worksheet name e.g. Sheet1, Sheet2...</param>
            <returns>New instance of copid worksheet</returns>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridControl.CopyWorksheet(unvell.ReoGrid.Worksheet,System.Int32,System.String)">
            <summary>
            Create a cloned worksheet and put into specified position
            </summary>
            <param name="sheet">Source worksheet to be copied, the worksheet must be already added into this workbook</param>
            <param name="newIndex">Target index used to insert the copied worksheet</param>
            <param name="newName">Name for new worksheet, set as null to use a default worksheet name e.g. Sheet1, Sheet2...</param>
            <returns>New instance of copid worksheet</returns>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridControl.MoveWorksheet(System.Int32,System.Int32)">
            <summary>
            Move worksheet from a position to another position
            </summary>
            <param name="index">Worksheet in this position to be moved</param>
            <param name="newIndex">Target position moved to</param>
            <returns>Instance of moved worksheet</returns>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridControl.MoveWorksheet(unvell.ReoGrid.Worksheet,System.Int32)">
            <summary>
            Create a cloned worksheet and put into specified position
            </summary>
            <param name="sheet">Instance of worksheet to be moved, the worksheet must be already added into this workbook</param>
            <param name="newIndex">Target position moved to</param>
            <returns>Instance of moved worksheet</returns>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridControl.GetWorksheetIndex(unvell.ReoGrid.Worksheet)">
            <summary>
            Get index of specified worksheet from the collection in this workbook
            </summary>
            <param name="sheet">worksheet to be get</param>
            <returns>zero-based number of worksheet in this workbook's collection</returns>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridControl.GetWorksheetByName(System.String)">
            <summary>
            Find worksheet by specified name
            </summary>
            <param name="name">Name to find worksheet</param>
            <returns>Instance of worksheet that is found by specified name; otherwise return null</returns>
        </member>
        <member name="P:unvell.ReoGrid.ReoGridControl.Worksheets">
            <summary>
            Get the collection of worksheet.
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.ReoGridControl.CurrentWorksheetChanged">
            <summary>
            Event raised when current worksheet is changed
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.ReoGridControl.WorksheetCreated">
            <summary>
            Event raised when worksheet is created
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.ReoGridControl.WorksheetInserted">
            <summary>
            Event raised when worksheet is inserted into this workbook
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.ReoGridControl.WorksheetRemoved">
            <summary>
            Event raised when worksheet is removed from this workbook
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.ReoGridControl.WorksheetNameChanged">
            <summary>
            Event raised when the name of worksheet managed by this workbook is changed
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.ReoGridControl.WorksheetNameBackColorChanged">
            <summary>
            Event raised when background color of worksheet name is changed.
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.ReoGridControl.WorksheetNameTextColorChanged">
            <summary>
            Event raised when text color of worksheet name is changed.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReoGridControl.Readonly">
            <summary>
            Determine whether or not this workbook is read-only (Reserved v0.8.8)
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridControl.Reset">
            <summary>
            Reset control and workbook (remove all worksheets and put one new)
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReoGridControl.IsWorkbookEmpty">
            <summary>
            Check whether or not current workbook is empty (all worksheets don't have any cells)
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridControl.DoAction(unvell.ReoGrid.Worksheet,unvell.ReoGrid.Actions.BaseWorksheetAction)">
            <summary>Do specified action. 
            
            An action does the operation as well as undoes for worksheet.
            Actions performed by this method will be appended to action history stack 
            in order to undo, redo and repeat.
            
            There are built-in actions available for many base operations, such as:
              <code>SetCellDataAction</code> - set cell data
              <code>SetRangeDataAction</code> - set data into range
              <code>SetRangeBorderAction</code> - set border to specified range
              <code>SetRangeStyleAction</code> - set styles to specified range
              ...
              
            It is possible to make custom action by inherting BaseWorksheetAction.
            </summary>
            <example>
            ReoGrid uses ActionManager, unvell lightweight undo framework, 
            to implement the Do/Undo/Redo/Repeat method.
            
            To do action:
            <code>
              var action = new SetCellDataAction("B1", 10);
              workbook.DoAction(targetSheet, action);
            </code>
            
            To undo action:
            <code>
              workbook.Undo();
            </code>
            
            To redo action:
            <code>
            	workbook.Redo();
            </code>
            
            To repeat last action:
            <code>
            	workbook.RepeatLastAction(targetSheet, new ReoGridRange("B1:C3"));
            </code>
            
            It is possible to do multiple actions at same time:
            <code>
              var action1 = new SetRangeDataAction(...);
              var action2 = new SetRangeBorderAction(...);
              var action3 = new SetRangeStyleAction(...);
              
            	var actionGroup = new WorksheetActionGroup();
            	actionGroup.Actions.Add(action1);
            	actionGroup.Actions.Add(action2);
            	actionGroup.Actions.Add(action3);
            	
            	workbook.DoAction(targetSheet, actionGroup);
            </code>
            
            Actions added into action group will be performed by one time,
            they will be also undone by one time.
            </example>
            <seealso cref="T:unvell.Common.ActionGroup"/>
            <seealso cref="T:unvell.ReoGrid.Actions.BaseWorksheetAction"/>
            <seealso cref="T:unvell.ReoGrid.Actions.WorksheetActionGroup"/>
            <param name="sheet">worksheet of the target container to perform specified action</param>
            <param name="action">action to be performed</param>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridControl.Undo">
            <summary>
            Undo the last action.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridControl.Redo">
            <summary>
            Redo the last action.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridControl.RepeatLastAction(unvell.ReoGrid.RangePosition)">
            <summary>
            Repeat to do last action and apply to another specified range.
            </summary>
            <param name="range">The new range to be applied for the last action.</param>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridControl.RepeatLastAction(unvell.ReoGrid.Worksheet,unvell.ReoGrid.RangePosition)">
            <summary>
            Repeat to do last action and apply to another specified range and worksheet.
            </summary>
            <param name="worksheet">The target worksheet to perform the action.</param>
            <param name="range">The new range to be applied for the last action.</param>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridControl.CanUndo">
            <summary>
            Determine whether there is any actions can be undone.
            </summary>
            <returns>True if any actions can be undone</returns>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridControl.CanRedo">
            <summary>
            Determine whether there is any actions can be redid.
            </summary>
            <returns>True if any actions can be redid</returns>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridControl.ClearActionHistory">
            <summary>
            Clear all undo/redo actions from workbook action history.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridControl.ClearActionHistoryForWorksheet(unvell.ReoGrid.Worksheet)">
            <summary>
            Delete all actions that belongs to specified worksheet.
            </summary>
            <param name="sheet">Actions belongs to this worksheet will be deleted from workbook action histroy.</param>
        </member>
        <member name="E:unvell.ReoGrid.ReoGridControl.BeforeActionPerform">
            <summary>
            Event fired before action perform.
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.ReoGridControl.ActionPerformed">
            <summary>
            Event fired when any action performed.
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.ReoGridControl.Undid">
            <summary>
            Event fired when Undo operation performed by user.
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.ReoGridControl.Redid">
            <summary>
            Event fired when Reod operation performed by user.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridControl.SetSettings(unvell.ReoGrid.WorkbookSettings,System.Boolean)">
            <summary>
            Set specified workbook settings
            </summary>
            <param name="settings">Settings to be set</param>
            <param name="value">True to enable the settings, false to disable the settings</param>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridControl.GetSettings">
            <summary>
            Get current settings of workbook
            </summary>
            <returns>Workbook settings set</returns>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridControl.HasSettings(unvell.ReoGrid.WorkbookSettings)">
            <summary>
            Determine whether or not the specified workbook settings has been set
            </summary>
            <param name="settings">Settings to be checked</param>
            <returns>True if specified settings has been set</returns>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridControl.EnableSettings(unvell.ReoGrid.WorkbookSettings)">
            <summary>
            Enable specified settings for workbook.
            </summary>
            <param name="settings">Settings to be enabled.</param>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridControl.DisableSettings(unvell.ReoGrid.WorkbookSettings)">
            <summary>
            Disable specified settings for workbook.
            </summary>
            <param name="settings">Settings to be disabled.</param>
        </member>
        <member name="E:unvell.ReoGrid.ReoGridControl.SettingsChanged">
            <summary>
            Event raised when settings is changed
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReoGridControl.Script">
            <summary>
            Get or set script content
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridControl.RunScript">
            <summary>
            Run workbook script.
            </summary>
            <returns>Return value from script.</returns>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridControl.RunScript(System.String)">
            <summary>
            Run specified script by workbook.
            </summary>
            <param name="script">Script to be executed.</param>
            <returns>Return value from specified script.</returns>
        </member>
        <member name="E:unvell.ReoGrid.ReoGridControl.ExceptionHappened">
            <summary>
            Event raised when exception has been happened during internal operations.
            Usually the internal operations are raised by hot-keys pressed by end-user.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridControl.NotifyExceptionHappen(unvell.ReoGrid.Worksheet,System.Exception)">
            <summary>
            Notify that there are exceptions happen on any worksheet. 
            The event ExceptionHappened of workbook will be invoked.
            </summary>
            <param name="sheet">Worksheet where the exception happened.</param>
            <param name="ex">Exception to describe the details of error information.</param>
        </member>
        <member name="P:unvell.ReoGrid.ReoGridControl.CellsSelectionCursor">
            <summary>
            Get or set the mouse cursor on cells selection
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReoGridControl.FullRowSelectionCursor">
            <summary>
            Cursor symbol displayed when moving mouse over on row headers
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReoGridControl.FullColumnSelectionCursor">
            <summary>
            Cursor symbol displayed when moving mouse over on column headers
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReoGridControl.EntireSheetSelectionCursor">
            <summary>
            Get or set the mouse cursor of lead header part
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridControl.PickRange(System.Func{unvell.ReoGrid.Worksheet,unvell.ReoGrid.RangePosition,System.Boolean})">
            <summary>
            Start to pick a range from current worksheet.
            </summary>
            <param name="onPicked">Callback function invoked after range is picked.</param>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridControl.PickRange(System.Func{unvell.ReoGrid.Worksheet,unvell.ReoGrid.RangePosition,System.Boolean},System.Windows.Input.Cursor)">
            <summary>
            Start to pick a range from current worksheet.
            </summary>
            <param name="onPicked">Callback function invoked after range is picked.</param>
            <param name="pickerCursor">Cursor style during picking.</param>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridControl.StartPickRangeAndCopyStyle">
            <summary>
            Start to pick ranges and copy the styles to the picked range
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridControl.EndPickRange">
            <summary>
            End pick range operation
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReoGridControl.ControlInstance">
            <summary>
            Retrieve control instance of workbook.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReoGridControl.ControlStyle">
            <summary>
            Control Style Settings
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReoGridControl.SheetTabVisible">
            <summary>
            Show or hide the built-in sheet tab control.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReoGridControl.SheetTabWidth">
            <summary>
            Get or set the width of sheet tab control.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReoGridControl.SheetTabNewButtonVisible">
            <summary>
            Determines that whether or not to display the new button on sheet tab control.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridControl.ScrollCurrentWorksheet(System.Double,System.Double)">
            <summary>
            Scroll current active worksheet.
            </summary>
            <param name="offsetX">Scroll value on horizontal direction.</param>
            <param name="offsetY">Scroll value on vertical direction.</param>
        </member>
        <member name="E:unvell.ReoGrid.ReoGridControl.WorksheetScrolled">
            <summary>
            Event raised when current worksheet is scrolled.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridControl.RaiseWorksheetScrolledEvent(unvell.ReoGrid.Worksheet,System.Double,System.Double)">
            <summary>
            Raise the event of worksheet scrolled.
            </summary>
            <param name="worksheet">Instance of scrolled worksheet.</param>
            <param name="x">Scroll value on horizontal direction.</param>
            <param name="y">Scroll value on vertical direction.</param>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridControl.#ctor">
            <summary>
            Create ReoGrid spreadsheet control
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridControl.OnRenderSizeChanged(System.Windows.SizeChangedInfo)">
            <summary>
            Handle event on render size changed
            </summary>
            <param name="sizeInfo">size information</param>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridControl.OnRender(System.Windows.Media.DrawingContext)">
            <summary>
            Handle repaint event to draw component.
            </summary>
            <param name="dc">Platform independence drawing context.</param>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridControl.OnKeyDown(System.Windows.Input.KeyEventArgs)">
            <summary>
            Handle event when key down.
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridControl.OnTextInput(System.Windows.Input.TextCompositionEventArgs)">
            <summary>
            Handle event when text inputted
            </summary>
            <param name="e"></param>
        </member>
        <member name="P:unvell.ReoGrid.ReoGridControl.CellsContextMenu">
            <summary>
            Get or set the cells context menu
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReoGridControl.RowHeaderContextMenu">
            <summary>
            Get or set the row header context menu
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReoGridControl.ColumnHeaderContextMenu">
            <summary>
            Get or set the column header context menu
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReoGridControl.LeadHeaderContextMenu">
            <summary>
            Get or set the lead header context menu
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReoGridControl.LoadFromFile">
            <summary>
            Get or set filepath of startup template file
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.BorderPositions">
            <summary>
            Position of borders for a range or cell
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.BorderPositions.None">
            <summary>
            No border
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.BorderPositions.Top">
            <summary>
            Top border inside range or cell
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.BorderPositions.Bottom">
            <summary>
            Bottom border inside range or cell
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.BorderPositions.Left">
            <summary>
            Left side border inside range or cell
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.BorderPositions.Right">
            <summary>
            Right side border inside range or cell
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.BorderPositions.InsideHorizontal">
            <summary>
            Horizontal borders inside range or cell
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.BorderPositions.InsideVertical">
            <summary>
            Vertical borders inside range or cell
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.BorderPositions.Slash">
            <summary>
            Slash lines inside cell (Reserved)
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.BorderPositions.Backslash">
            <summary>
            Backslash lines inside cell (Reserved)
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.BorderPositions.LeftRight">
            <summary>
            Borders in left and right side in range or cell
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.BorderPositions.TopBottom">
            <summary>
            Borders in top and bottom in range or cell
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.BorderPositions.Outside">
            <summary>
            Borders around range or cell
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.BorderPositions.InsideAll">
            <summary>
            Horizontal and vertical borders inside range or cell
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.BorderPositions.All">
            <summary>
            All borders belong to range or cell
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.BorderPositions.X">
            <summary>
            Cross line in single cell (Both Slash and Backslash, Reserved)
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.BorderLineStyle">
            <summary>
            Line style of border.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.BorderLineStyle.None">
            <summary>
            None border
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.BorderLineStyle.Solid">
            <summary>
            Solid border
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.BorderLineStyle.Dotted">
            <summary>
            Dotted border
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.BorderLineStyle.Dashed">
            <summary>
            Dashed border
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.BorderLineStyle.DoubleLine">
            <summary>
            Double line border (not supported in WPF version)
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.BorderLineStyle.Dashed2">
            <summary>
            Dashed (style 2) border (not supported in WPF version)
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.BorderLineStyle.DashDot">
            <summary>
            Dashed (style 3) border
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.BorderLineStyle.DashDotDot">
            <summary>
            Dashed (style 4) border
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.BorderLineStyle.BoldDashDot">
            <summary>
            Bold dashed (style 2) border
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.BorderLineStyle.BoldDashDotDot">
            <summary>
            Bold dashed (style 3) border
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.BorderLineStyle.BoldDashed">
            <summary>
            Bold dashed border
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.BorderLineStyle.BoldDotted">
            <summary>
            Bold dotted border
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.BorderLineStyle.BoldSolid">
            <summary>
            Bold solid border
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.BorderLineStyle.BoldSolidStrong">
            <summary>
            Strong solid border (Bold x2)
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.RangeBorderStyle">
            <summary>
            Represents a border style of range or cell.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.RangeBorderStyle.Empty">
            <summary>
            No border
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.RangeBorderStyle.Style">
            <summary>
            The border style
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.RangeBorderStyle.Color">
            <summary>
            Color of border
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.RangeBorderStyle.IsEmpty">
            <summary>
            Determines whether this style is empty
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.RangeBorderStyle.Equals(System.Object)">
            <summary>
            Compare two border styles check whether they are same
            </summary>
            <param name="obj">Object to be compared</param>
            <returns>True if two object are same; otherwise return false.</returns>
        </member>
        <member name="M:unvell.ReoGrid.RangeBorderStyle.op_Equality(unvell.ReoGrid.RangeBorderStyle,System.Object)">
            <summary>
            Compare two styles and check whether or not they are same.
            </summary>
            <param name="s1">First style to be compared.</param>
            <param name="s2">Second style to be compared.</param>
            <returns>Return true if two styles are same; Otherwise return false.</returns>
        </member>
        <member name="M:unvell.ReoGrid.RangeBorderStyle.op_Inequality(unvell.ReoGrid.RangeBorderStyle,System.Object)">
            <summary>
            Compare two styles and check whether or not they are not same.
            </summary>
            <param name="s1">First style to be compared.</param>
            <param name="s2">Second style to be compared.</param>
            <returns>Return true if two styles are same; Otherwise return false.</returns>
        </member>
        <member name="M:unvell.ReoGrid.RangeBorderStyle.GetHashCode">
            <summary>
            Return the hashcode of this object.
            </summary>
            <returns>Hashcode calculated from this object.</returns>
        </member>
        <member name="M:unvell.ReoGrid.RangeBorderStyle.ToString">
            <summary>
            Convert style object into friendly description string.
            </summary>
            <returns></returns>
        </member>
        <member name="M:unvell.ReoGrid.RangeBorderStyle.#ctor(unvell.ReoGrid.Graphics.SolidColor,unvell.ReoGrid.BorderLineStyle)">
            <summary>
            Create range border style object with specified color and style.
            </summary>
            <param name="color">Color to display borders on worksheet.</param>
            <param name="style">Style to display borders on worksheet.</param>
        </member>
        <member name="F:unvell.ReoGrid.RangeBorderStyle.BlackSolid">
            <summary>
            Predefined border style of solid black border.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.RangeBorderStyle.BlackBoldSolid">
            <summary>
            Predefined border style of solid black border.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.RangeBorderStyle.GraySolid">
            <summary>
            Predefined border style of solid gray border.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.RangeBorderStyle.SilverSolid">
            <summary>
            Predefined border style of solid silver border.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.RangeBorderStyle.BlackDotted">
            <summary>
            Predefined border style of dotted black border.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.RangeBorderStyle.GrayDotted">
            <summary>
            Predefined border style of dotted gray border.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.RangeBorderStyle.BlackDash">
            <summary>
            Predefined border style of dashed black border.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.RangeBorderStyle.GrayDash">
            <summary>
            Predefined border style of dashed gray border.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.RangeBorderInfo">
            <summary>
            This class contains the position and style information of a segment of border for a range.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.RangeBorderInfo.Pos">
            <summary>
            Get or set the position of this border in a range.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.RangeBorderInfo.Style">
            <summary>
            Get or set the style of border in a range.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.RangeBorderInfo.#ctor(unvell.ReoGrid.BorderPositions,unvell.ReoGrid.RangeBorderStyle)">
            <summary>
            Create border information instance with specified position and style.
            </summary>
            <param name="pos">The position of border in a range.</param>
            <param name="style">The style of border in a range.</param>
        </member>
        <member name="T:unvell.ReoGrid.RangeBorderInfoSet">
            <summary>
            This class contains the information of all borders in specified range. 
            This class only be used as return value form <see cref="!:GetRangeBorders">GetRangeBorders</see> method.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.RangeBorderInfoSet.NonUniformPos">
            <summary>
            Borders at the positions are not same
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.RangeBorderInfoSet.IsNonUniform(unvell.ReoGrid.BorderPositions)">
            <summary>
            Indicates whether the borders to each cells in a specified range are not same 
            </summary>
            <param name="pos">border position in range</param>
            <returns>true if borders at position are not same</returns>
        </member>
        <member name="P:unvell.ReoGrid.RangeBorderInfoSet.Top">
            <summary>
            Border style at top of range
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.RangeBorderInfoSet.Right">
            <summary>
            Border style at right of range
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.RangeBorderInfoSet.Bottom">
            <summary>
            Border style at bottom of range
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.RangeBorderInfoSet.Left">
            <summary>
            Border  style at left of range
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.RangeBorderInfoSet.InsideHorizontal">
            <summary>
            Horizontal border style inside range
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.RangeBorderInfoSet.InsideVertical">
            <summary>
            Vertical border style inside range
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.RangeBorderInfoSet.Slash">
            <summary>
            Slash style inside range
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.RangeBorderInfoSet.Backslash">
            <summary>
            Backslash style inside range
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.CellBorderProperty">
            <summary>
            Represents border property for cell instance.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.CellBorderProperty.Left">
            <summary>
            Get or set left border style for cell.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.CellBorderProperty.Top">
            <summary>
            Get or set top border style for cell.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.CellBorderProperty.Right">
            <summary>
            Get or set right border style for cell.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.CellBorderProperty.Bottom">
            <summary>
            Get or set bottom border style for cell.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.CellBorderProperty.Outside">
            <summary>
            Get or set all outside border styles for cell.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.CellBorderProperty.All">
            <summary>
            Get or set all border styles for cell.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.RangeBorderProperty">
            <summary>
            Represents border property for range instance.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.RangeBorderProperty.Left">
            <summary>
            Get or set left border styles for range.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.RangeBorderProperty.Top">
            <summary>
            Get or set top border styles for range.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.RangeBorderProperty.Right">
            <summary>
            Get or set right border styles for range.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.RangeBorderProperty.Bottom">
            <summary>
            Get or set bottom border styles for range.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.RangeBorderProperty.Inside">
            <summary>
            Get or set all inside borders style for range.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.RangeBorderProperty.InsideHorizontal">
            <summary>
            Get or set all horizontal border styles for range.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.RangeBorderProperty.InsideVertical">
            <summary>
            Get or set all vertical border styles for range.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.RangeBorderProperty.Outside">
            <summary>
            Get or set all outside border styles for range.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.RangeBorderProperty.All">
            <summary>
            Get or set all inside border styles for range.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:unvell.ReoGrid.ReoGridCell" -->
        <member name="T:unvell.ReoGrid.CellElementFlag">
            <summary>
            Cell element flags
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.CellElementFlag.All">
            <summary>
            All elements
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.CellElementFlag.Data">
            <summary>
            Cell value
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.CellElementFlag.Formula">
            <summary>
            Cell formuals
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.CellElementFlag.Body">
            <summary>
            Cell body
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.CellElementFlag.DataFormat">
            <summary>
            Data format setting
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.CellElementFlag.Style">
            <summary>
            Styles
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.CellElementFlag.Border">
            <summary>
            Border around the cell
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.DataFormat.CellDataFormatFlag">
            <summary>
            Cell data format type
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.DataFormat.CellDataFormatFlag.General">
            <summary>
            Auto format type (compliant with Text and Number)
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.DataFormat.CellDataFormatFlag.Number">
            <summary>
            Number Type
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.DataFormat.CellDataFormatFlag.DateTime">
            <summary>
            Date and Time Type
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.DataFormat.CellDataFormatFlag.Percent">
            <summary>
            Percent Type
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.DataFormat.CellDataFormatFlag.Currency">
            <summary>
            Currency Type
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.DataFormat.CellDataFormatFlag.Text">
            <summary>
            String
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.DataFormat.CellDataFormatFlag.Custom">
            <summary>
            User custom data formatter
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.DataFormat.DataFormatterManager">
            <summary>
            Data Formatter Manager
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.DataFormat.DataFormatterManager.Instance">
            <summary>
            Instance for this class
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.DataFormat.DataFormatterManager.DataFormatters">
            <summary>
            Built-in data formatters
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.DataFormat.IDataFormatter">
            <summary>
            Data format provider interface
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.DataFormat.IDataFormatter.FormatCell(unvell.ReoGrid.Cell)">
            <summary>
            Format data stored in specified cell.
            </summary>
            <param name="cell">Instance of cell to be formatted.</param>
            <returns>Return non-empty string if formatting was performed successfully; Otherwise return null.</returns>
        </member>
        <member name="M:unvell.ReoGrid.DataFormat.IDataFormatter.PerformTestFormat">
            <summary>
            Indicate that whether or not to check the data type before format.
            </summary>
            <returns>True to perform test; Otherwise return false.</returns>
        </member>
        <member name="T:unvell.ReoGrid.DataFormat.GeneralDataFormatter">
            <summary>
            GeneralDataFormatter supports both Text and Numeric format.
            And format type can be switched after data changed by user inputing.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.DataFormat.NumberDataFormatter">
            <summary>
            Number Formatter used to format data as numeric format.
            Available also to format data with different negative styles.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.DataFormat.NumberDataFormatter.FormatCell(unvell.ReoGrid.Cell)">
            <summary>
            Format given cell
            </summary>
            <param name="cell">Instance of cell to be formatted</param>
            <returns></returns>
        </member>
        <member name="P:unvell.ReoGrid.DataFormat.NumberDataFormatter.TwoDecimalDigitsArgument">
            <summary>
            Predefined format argument with using separator and two decimal digits (e.g. 1,234.56)
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.DataFormat.NumberDataFormatter.NoDecimalDigitsArgument">
            <summary>
            Predefined format argument with using separator but without decimal digits (e.g. 1,234)
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.DataFormat.NumberDataFormatter.INumberFormatArgs">
            <summary>
            Represents an interface for all number formats.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.DataFormat.NumberDataFormatter.INumberFormatArgs.DecimalPlaces">
            <summary>
            Get or set the digis places for number.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.DataFormat.NumberDataFormatter.INumberFormatArgs.NegativeStyle">
            <summary>
            Get or set the negative number styles.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.DataFormat.NumberDataFormatter.INumberFormatArgs.UseSeparator">
            <summary>
            Determines that whether or not show the separators in numbers.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.DataFormat.NumberDataFormatter.NumberFormatArgs">
            <summary>
            Represents number format arguments.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.DataFormat.NumberDataFormatter.NumberFormatArgs.#ctor">
            <summary>
            Create number format arguments.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.DataFormat.NumberDataFormatter.NumberFormatArgs.DecimalPlaces">
            <summary>
            Number of decimal places.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.DataFormat.NumberDataFormatter.NumberFormatArgs.NegativeStyle">
            <summary>
            Determine the negative number style. (Minus, Red and Brackets)
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.DataFormat.NumberDataFormatter.NumberFormatArgs.UseSeparator">
            <summary>
            Determine whether to use a separator to split number every 3 digits.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.DataFormat.NumberDataFormatter.NumberFormatArgs.Equals(System.Object)">
            <summary>
            Compare to another argument instance of NumberFormatArgs.
            </summary>
            <param name="obj">Another instance to be compared.</param>
            <returns>true if two argument object are same.</returns>
        </member>
        <member name="M:unvell.ReoGrid.DataFormat.NumberDataFormatter.NumberFormatArgs.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <returns></returns>
        </member>
        <member name="T:unvell.ReoGrid.DataFormat.NumberDataFormatter.NumberNegativeStyle">
            <summary>
            Represents the negative number styles.
            </summary>
            <example>
            Default							:		-1234.56
            Minus								:		-1234.56
            Red									:		<span style='color:red;'>1,234.56</span>
            RedMinus						:		<span style='color:red;'>-1,234.56</span>
            Brackets						:		(1,234.56)
            RedBrackets					:		<span style='color:red;'>(1,234.56)</span>
            RedBracketsMinus		:		<span style='color:red;'>(-1,234.56)</span>
            JapaneseSankaku			:		 1,234.00
            JapaneseRedSankaku	:		<span style='color:red;'> 1,234.00</span>
            </example>
        </member>
        <member name="F:unvell.ReoGrid.DataFormat.NumberDataFormatter.NumberNegativeStyle.Default">
            <summary>
            Regular negative style. (e.g. -1234.56)
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.DataFormat.NumberDataFormatter.NumberNegativeStyle.Minus">
            <summary>
            Regular negative style. (e.g. -1234.56)
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.DataFormat.NumberDataFormatter.NumberNegativeStyle.Red">
            <summary>
            Negative number displayed as red without prefix symbol. (e.g. <span style='color:red;'>1234.56</span>)
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.DataFormat.NumberDataFormatter.NumberNegativeStyle.Brackets">
            <summary>
            Negative number surrounded by brackets. (e.g. (1234.56))
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.DataFormat.NumberDataFormatter.NumberNegativeStyle.RedMinus">
            <summary>
            Negative number displayed as red. Equals (Minus | Red) (e.g. <span style='color:red;'>-1234.56</span>)
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.DataFormat.NumberDataFormatter.NumberNegativeStyle.BracketsMinus">
            <summary>
            Negative number displayed with prefix symbol and brackets. Equals (Minus | Brackets) 
            (e.g. <span style='color:red;'>-1234.56</span>)
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.DataFormat.NumberDataFormatter.NumberNegativeStyle.RedBrackets">
            <summary>
            Negative number surrounded by brackets and displayed as red.
            Equals (Red | Brackets) e.g. <span style='color:red;'>(1234.56)</span>
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.DataFormat.NumberDataFormatter.NumberNegativeStyle.RedBracketsMinus">
            <summary>
            Negative number displayed as red with prefix symbol, surrounded by brackets.
            Equals (Minus | Red | Brackets). (e.g. <span style='color:red;'>(-1234.56)</span>)
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.DataFormat.NumberDataFormatter.NumberNegativeStyle.Prefix_Sankaku">
            <summary>
            Negative number with Sankaku symbol prefix. (Japanese negative number style e.g.  1,234.00)
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.DataFormat.NumberDataFormatter.NumberNegativeStyle.CustomSymbol">
            <summary>
            Set custom prefix and/or postfix for negative numbers. (Requires ReoGrid Pro)
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.DataFormat.NumberDataFormatter.PerformTestFormat">
            <summary>
            Determine whether or not to perform a test when cell is not be set to use current format.
            </summary>
            <returns>True to perform test; False to do not perform test.</returns>
        </member>
        <member name="T:unvell.ReoGrid.DataFormat.DateTimeDataFormatter">
            <summary>
            Datetime data formatter
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.DataFormat.DateTimeDataFormatter.BaseStartDate">
            <summary>
            Base start time used to calculcate the date from a number value
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.DataFormat.DateTimeDataFormatter.FormatCell(unvell.ReoGrid.Cell)">
            <summary>
            Format cell
            </summary>
            <param name="cell">cell to be formatted</param>
            <returns>Formatted text used to display as cell content</returns>
        </member>
        <member name="T:unvell.ReoGrid.DataFormat.DateTimeDataFormatter.DateTimeFormatArgs">
            <summary>
            Represents the argument that is used during format a cell as data time.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.DataFormat.DateTimeDataFormatter.DateTimeFormatArgs.Format">
            <summary>
            Get or set the date time pattern. (Standard .NET datetime pattern is supported, e.g.: yyyy/MM/dd)
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.DataFormat.DateTimeDataFormatter.DateTimeFormatArgs.CultureName">
            <summary>
            Get or set the culture name that is used to format datetime according to localization settings.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.DataFormat.DateTimeDataFormatter.DateTimeFormatArgs.Equals(System.Object)">
            <summary>
            Compare to another object, check whether or not two objects are same.
            </summary>
            <param name="obj">Another object to be compared.</param>
            <returns>True if two objects are same; Otherwise return false.</returns>
        </member>
        <member name="M:unvell.ReoGrid.DataFormat.DateTimeDataFormatter.DateTimeFormatArgs.GetHashCode">
            <summary>
            Get the hash code of this argument object.
            </summary>
            <returns>Hash code of argument object.</returns>
        </member>
        <member name="M:unvell.ReoGrid.DataFormat.DateTimeDataFormatter.PerformTestFormat">
            <summary>
            Determines whether or not to perform a test when target cell is not set as datetime format.
            </summary>
            <returns></returns>
        </member>
        <member name="T:unvell.ReoGrid.DataFormat.PercentDataFormatter">
            <summary>
            Percent data formatter
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.DataFormat.PercentDataFormatter.PerformTestFormat">
            <summary>
            Perform a format check
            </summary>
            <returns>true if the data is in this format</returns>
        </member>
        <member name="T:unvell.ReoGrid.DataFormat.CurrencyDataFormatter">
            <summary>
            Currency data formatter
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.DataFormat.CurrencyDataFormatter.FormatCell(unvell.ReoGrid.Cell)">
            <summary>
            Format specified cell
            </summary>
            <param name="cell">cell instance</param>
            <returns>true if cell has been formatted</returns>
        </member>
        <member name="T:unvell.ReoGrid.DataFormat.CurrencyDataFormatter.CurrencyFormatArgs">
            <summary>
            Represents arguments of currency data format.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.DataFormat.CurrencyDataFormatter.CurrencyFormatArgs.PrefixSymbol">
            <summary>
            Currency symbol that displayed before currency number.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.DataFormat.CurrencyDataFormatter.CurrencyFormatArgs.PostfixSymbol">
            <summary>
            Currency symbol that displayed after currency number.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.DataFormat.CurrencyDataFormatter.CurrencyFormatArgs.CultureEnglishName">
            <summary>
            Culture name in English. (e.g. en-US)
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.DataFormat.CurrencyDataFormatter.CurrencyFormatArgs.Equals(System.Object)">
            <summary>
            Check whether or not two objects are same.
            </summary>
            <param name="obj">Another object to be compared.</param>
            <returns>True if two objects are same; Otherwise return false.</returns>
        </member>
        <member name="M:unvell.ReoGrid.DataFormat.CurrencyDataFormatter.CurrencyFormatArgs.GetHashCode">
            <summary>
            Get hash code
            </summary>
            <returns></returns>
        </member>
        <member name="M:unvell.ReoGrid.DataFormat.CurrencyDataFormatter.PerformTestFormat">
            <summary>
            Determine whether or not to perform format test
            </summary>
            <returns>True to perform test; False to abort</returns>
        </member>
        <member name="T:unvell.ReoGrid.ReoGridHeader">
            <summary>
            Represents a base class for header instances of worksheet.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReoGridHeader.IsVisible">
            <summary>
            Get or set whether or not to make the header visible on worksheet.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReoGridHeader.Index">
            <summary>
            Zero-bsed number used to locate the header on worksheet.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReoGridHeader.Tag">
            <summary>
            Get or set user data.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.ReoGridColumnHeader">
            <summary>
            Represents a column header on worksheet.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.ColumnHeader">
            <summary>
            Represents a column header on worksheet.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ColumnHeader.Left">
            <summary>
            Get the left position of this column header. (in pixel)
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ColumnHeader.Width">
            <summary>
            Get or set the width of this column header. (in pixel)
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ColumnHeader.Index">
            <summary>
            Get the number of column. (index cannot be changed, it managed by grid control)
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ColumnHeader.Text">
            <summary>
            Get or set the text of column header.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ColumnHeader.Right">
            <summary>
            Get the right position of column header. (in pixel)
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ColumnHeader.Style">
            <summary>
            Get style set of column header, modify any style in this set will affect all cells on this column.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ColumnHeader.IsAutoWidth">
            <summary>
            Get or set whether or not to auto adjust the width of this column.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ColumnHeader.IsVisible">
            <summary>
            Get or set whether or not to hide this column.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ColumnHeader.IsHidden">
            <summary>
            Get or set the visibility for this column.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ColumnHeader.DefaultCellBody">
            <summary>
            Get or set the default cell body type for all cells on this column.
            If this value is not null, when an new instance of cells on this column is created,
            the cell will have a body automatically that is the instance of the type specified by this value.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ColumnHeader.TextColor">
            <summary>
            Get or set color for display the header text on spreadsheet.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.ColumnHeader.FitWidthToCells(System.Boolean)">
            <summary>
            Auto fit column width to largest cell on this column.
            </summary>
            <param name="byAction">Determines whether or not this operation 
            performed by doing action, which will provide the ability to undo this operation.</param>
        </member>
        <member name="P:unvell.ReoGrid.ColumnHeader.Body">
            <summary>
            Header body
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.ColumnHeader.WidthChanged">
            <summary>
            Event raised when width changed of this column.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.ReoGridRowHeader">
            <summary>
            Represents a row header instance of worksheet.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.RowHeader">
            <summary>
            Represents a row header instance of worksheet.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.RowHeader.Top">
            <summary>
            Get the top position of header. (in pixel)
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.RowHeader.Height">
            <summary>
            Get or set height of row. (in pixel)
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.RowHeader.Bottom">
            <summary>
            Get the bottom position of header. (in pixel)
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.RowHeader.Index">
            <summary>
            Get the number of row. (index cannot be changed, it managed by grid control)
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.RowHeader.Text">
            <summary>
            Get or set display text for the row header.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.RowHeader.TextColor">
            <summary>
            Get or set the color that is used to display the header text.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.RowHeader.Style">
            <summary>
            Get style set of row header, modify any style in this set will affect all cells on this row.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.RowHeader.IsAutoHeight">
            <summary>
            Get or set whether or not allow to automatically adjust the height in order to fit the largest cell.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.RowHeader.IsVisible">
            <summary>
            Get or set whether or not to hide this row.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.RowHeader.IsHidden">
            <summary>
            Get or set the visibility for this row.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.RowHeader.FitHeightToCells(System.Boolean)">
            <summary>
            Auto fit column width to largest cell on this column.
            </summary>
            <param name="byAction">Determines whether or not this operation 
            performed by doing action, which will provide the ability to undo this operation.</param>
        </member>
        <member name="E:unvell.ReoGrid.RowHeader.HeightChanged">
            <summary>
            Event raised when width changed of this column.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.RowOrColumn">
            <summary>
            Flag to decide which orientation will be handled
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.RowOrColumn.Row">
            <summary>
            Row orientation
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.RowOrColumn.Column">
            <summary>
            Column orientation
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.RowOrColumn.Both">
            <summary>
            Both row and column (some approaches do not work with 'Both')
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Outline.OutlineCollection`1">
            <summary>
            Outline Collection for both Row and Column Outline.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:unvell.ReoGrid.Outline.OutlineCollection`1.#ctor">
            <summary>
            Only allowed to create instance by ReoGridControl.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Outline.OutlineCollection`1.Reset">
            <summary>
            Clear all outlines, reset to default status.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Outline.OutlineCollection`1.IterateOutlines(System.Func{`0,System.Boolean})">
            <summary>
            Iterate over the all outlines
            </summary>
            <param name="iterator">iterator callback function</param>
        </member>
        <member name="M:unvell.ReoGrid.Outline.OutlineCollection`1.IterateReverseOutlines(System.Func{`0,System.Boolean})">
            <summary>
            Reverse iterate over the all outlines
            </summary>
            <param name="iterator"></param>
        </member>
        <member name="M:unvell.ReoGrid.Outline.OutlineCollection`1.HasSame(unvell.ReoGrid.Outline.IReoGridOutline,System.Collections.Generic.IList{unvell.ReoGrid.Outline.IReoGridOutline})">
            <summary>
            Check whether there is same outline exist
            </summary>
            <param name="target">Outline used to find</param>
            <param name="exclusions">Outline in this list will not be compare</param>
            <returns>true if there is another same as target</returns>
        </member>
        <member name="P:unvell.ReoGrid.Outline.OutlineCollection`1.HasOutlines">
            <summary>
            Determine whether any outlines existed in this collection.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Outline.OutlineCollection`1.OutlineCount">
            <summary>
            Get number of outlines.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Outline.IReoGridOutline">
            <summary>
            Represents the interface of row or column outline.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Outline.IReoGridOutline.Start">
            <summary>
            Start position of outline.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Outline.IReoGridOutline.Count">
            <summary>
            Number of rows or columns in this outline.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Outline.IReoGridOutline.End">
            <summary>
            End position of outline
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Outline.IReoGridOutline.Collapse">
            <summary>
            Collapse this outline. (Hide all the cells which are contained by this outline)
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Outline.IReoGridOutline.Expand">
            <summary>
            Expand this outline. (Show all the cells which are contained by this outline)
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Outline.IReoGridOutline.Collapsed">
            <summary>
            Determine whether current outline is collapsed.
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.Outline.IReoGridOutline.BeforeCollapse">
            <summary>
            Event is raised before this outline collapse.
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.Outline.IReoGridOutline.AfterCollapse">
            <summary>
            Event is raised after this outline collapse.
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.Outline.IReoGridOutline.BeforeExpand">
            <summary>
            Event is raised before this outline expanding.
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.Outline.IReoGridOutline.AfterExpand">
            <summary>
            Event is raised after this outline expanding.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Outline.OutlineGroup`1">
            <summary>
            Outline group for both Row and Column Outline.
            </summary>
            <typeparam name="T">Outline define type, must be IReoGridOutline</typeparam>
        </member>
        <member name="M:unvell.ReoGrid.Outline.OutlineGroup`1.#ctor">
            <summary>
            Only allowed to create instance by ReoGridControl.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Outline.OutlineGroup`1.NumberButtonBounds">
            <summary>
            Number Button Rectangle.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Outline.OutlineGroup`1.CollapseAll">
            <summary>
            Collapse all outlines inside this group.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Outline.OutlineGroup`1.ExpandAll">
            <summary>
            Expand all outlines inside this group.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Outline.ReoGridOutline">
            <summary>
            Outline instance for both Row and Column Outline.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Outline.ReoGridOutline.sheet">
            <summary>
            instance of ReoGridControl.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Outline.ReoGridOutline.Start">
            <summary>
            Outline start index. (either number of row or number of column)
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Outline.ReoGridOutline.Count">
            <summary>
            Outline number of count. (either number of rows or number of columns)
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Outline.ReoGridOutline.End">
            <summary>
            Outline end index. (either number of row or number of column)
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Outline.ReoGridOutline.InternalCollapsed">
            <summary>
            Internal flag to determine whether this outline is collapsed.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Outline.ReoGridOutline.Collapsed">
            <summary>
            Check whether current outline is collapsed.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Outline.ReoGridOutline.Contains(unvell.ReoGrid.Outline.ReoGridOutline)">
            <summary>
            Determine whether specified outline is contained entirely by this outline.
            </summary>
            <param name="outline">The outline to be tested.</param>
            <returns>True if another outline is contained by this outline; otherwise return false.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Outline.ReoGridOutline.Contains(System.Int32)">
            <summary>
            Determine whether specified index is contained by this outline.
            </summary>
            <param name="index">index to be tested.</param>
            <returns></returns>
        </member>
        <member name="M:unvell.ReoGrid.Outline.ReoGridOutline.IntersectWith(unvell.ReoGrid.Outline.ReoGridOutline)">
            <summary>
            Determine whether specified outline is intersected with this outline.
            </summary>
            <param name="outline">Outline to be tested.</param>
            <returns>True if the specified outline is intersected with this outline.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Outline.ReoGridOutline.IntersectWith(System.Int32,System.Int32)">
            <summary>
            Determine whether specified range is intersected with this outline.
            </summary>
            <param name="start">Start index. (either number of row or number of column)</param>
            <param name="count">Number of count. (either number of rows or number of columns)</param>
            <returns>True if the specified outline is intersected with this outline.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Outline.ReoGridOutline.Collapse">
            <summary>
            Collapse specified outline.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Outline.ReoGridOutline.Expand">
            <summary>
            Expand specified outline.
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.Outline.ReoGridOutline.BeforeCollapse">
            <summary>
            Event is raised before this outline collapse.
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.Outline.ReoGridOutline.AfterCollapse">
            <summary>
            Event is raised after this outline collapse.
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.Outline.ReoGridOutline.BeforeExpand">
            <summary>
            Event is raised before this outline expanding.
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.Outline.ReoGridOutline.AfterExpand">
            <summary>
            Event is raised after this outline expanding.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Outline.OutlineCollectionProperty`1">
            <summary>
            Outline collection property
            </summary>
            <typeparam name="T">Row or column outline instance type</typeparam>
        </member>
        <member name="M:unvell.ReoGrid.Outline.OutlineCollectionProperty`1.AddOutline(System.Int32,System.Int32)">
            <summary>
            Add outline on worksheet.
            </summary>
            <param name="start">Zero-based start position to add outline.</param>
            <param name="count">Number of rows or columns to be added into outline.</param>
            <returns>Instance of new outline.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Outline.OutlineCollectionProperty`1.RemoveOutline(System.Int32,System.Int32)">
            <summary>
            Remove outline from worksheet.
            </summary>
            <param name="start">Zero-based start position to add outline.</param>
            <param name="count">Number of rows or columns exist in the outline.</param>
            <returns>Instance of removed outline.</returns>
        </member>
        <member name="P:unvell.ReoGrid.Outline.OutlineCollectionProperty`1.Item(System.Int32,System.Int32)">
            <summary>
            Get outline by specified position. (start position and number of rows or columns)
            </summary>
            <param name="start">Zero-based start position to find outline.</param>
            <param name="count">Number of rows or columns that is contained in target outline.</param>
            <returns>Instance of outline</returns>
        </member>
        <member name="M:unvell.ReoGrid.Outline.OutlineCollectionProperty`1.GetEnumerator">
            <summary>
            Get enumerator of outline collection.
            </summary>
            <returns>Enumerator of outline collection.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Outline.OutlineCollectionProperty`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Get enumerator of outline collection.
            </summary>
            <returns>Enumerator of outline collection.</returns>
        </member>
        <member name="T:unvell.ReoGrid.Outline.RowOutlineCollection">
            <summary>
            Row outline collection.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Outline.ColumnOutlineCollection">
            <summary>
            Column outline collection.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Outline.RowOutline">
            <summary>
            Represents instance of row outline.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Outline.RowOutline.Collapse">
            <summary>
            Collapse outline
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Outline.RowOutline.Expand">
            <summary>
            Expand outline
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Outline.RowOutline.Row">
            <summary>
            Get or set the number of row (Same as Start property)
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Outline.RowOutline.Rows">
            <summary>
            Get or set the number of rows (Same as Count property)
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Outline.RowOutline.EndRow">
            <summary>
            Get the number of end row (Same as End property - 1)
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.Outline.RowOutline.BeforeCollapse">
            <summary>
            Event is raised before this outline collapse
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.Outline.RowOutline.AfterCollapse">
            <summary>
            Event is raised after this outline collapse
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.Outline.RowOutline.BeforeExpand">
            <summary>
            Event is raised before this outline expanding
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.Outline.RowOutline.AfterExpand">
            <summary>
            Event is raised after this outline expanding
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Outline.ColumnOutline">
            <summary>
            Represents instance of column outline.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Outline.ColumnOutline.Collapse">
            <summary>
            Collapse outline
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Outline.ColumnOutline.Expand">
            <summary>
            Expand outline
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Outline.ColumnOutline.Col">
            <summary>
            Get or set the number of column (Same as Start property)
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Outline.ColumnOutline.Cols">
            <summary>
            Get or set the number of columns (Same as Count property)
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Outline.ColumnOutline.EndCol">
            <summary>
            Get the number of end column (Same as End property)
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.Outline.ColumnOutline.BeforeCollapse">
            <summary>
            Event is raised before this outline collapse
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.Outline.ColumnOutline.AfterCollapse">
            <summary>
            Event is raised after this outline collapse
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.Outline.ColumnOutline.BeforeExpand">
            <summary>
            Event is raised before this outline expanding
            </summary>
        </member>
        <member name="E:unvell.ReoGrid.Outline.ColumnOutline.AfterExpand">
            <summary>
            Event is raised after this outline expanding
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Outline.OutlineEventArgs">
            <summary>
            Common outline event argument.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Outline.OutlineEventArgs.Outline">
            <summary>
            Outline instance for both row and column outline.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Outline.OutlineEventArgs.#ctor(unvell.ReoGrid.Outline.IReoGridOutline)">
            <summary>
            Create outline event argument with specified outline instance.
            </summary>
            <param name="outline">instance of either row or column outline</param>
        </member>
        <member name="T:unvell.ReoGrid.Outline.OutlineAddedEventArgs">
            <summary>
            Event raised when outline has been added into spreadsheet.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Outline.OutlineAddedEventArgs.#ctor(unvell.ReoGrid.Outline.ReoGridOutline)">
            <summary>
            Create outline event argument with specified outline instance.
            </summary>
            <param name="outline">instance of either row or column outline</param>
        </member>
        <member name="T:unvell.ReoGrid.Outline.OutlineRemovedEventArgs">
            <summary>
            Event raised when outline has been removed into spreadsheet.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Outline.OutlineRemovedEventArgs.#ctor(unvell.ReoGrid.Outline.IReoGridOutline)">
            <summary>
            Create outline event argument with specified outline instance.
            </summary>
            <param name="outline">instance of either row or column outline</param>
        </member>
        <member name="T:unvell.ReoGrid.Outline.BeforeOutlineCollapseEventArgs">
            <summary>
            Event raised before outline collapsing.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Outline.BeforeOutlineCollapseEventArgs.#ctor(unvell.ReoGrid.Outline.ReoGridOutline)">
            <summary>
            Create outline event argument with specified outline instance.
            </summary>
            <param name="outline">instance of either row or column outline</param>
        </member>
        <member name="P:unvell.ReoGrid.Outline.BeforeOutlineCollapseEventArgs.IsCancelled">
            <summary>
            Get or set whether or not to abort current operation.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Outline.BeforeOutlineExpandingEventArgs">
            <summary>
            Event raised before outline expanding.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Outline.BeforeOutlineExpandingEventArgs.#ctor(unvell.ReoGrid.Outline.ReoGridOutline)">
            <summary>
            Create event arguments instance.
            </summary>
            <param name="outline"></param>
        </member>
        <member name="P:unvell.ReoGrid.Outline.BeforeOutlineExpandingEventArgs.IsCancelled">
            <summary>
            Get or set whether or not to abort current operation.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Outline.AfterOutlineCollapseEventArgs">
            <summary>
            Event raised after outline collapsing.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Outline.AfterOutlineCollapseEventArgs.#ctor(unvell.ReoGrid.Outline.ReoGridOutline)">
            <summary>
            Create event arguments instance.
            </summary>
            <param name="outline">The outline has been collapsed.</param>
        </member>
        <member name="T:unvell.ReoGrid.Outline.AfterOutlineExpandingEventArgs">
            <summary>
            Event raised after outline expanding.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Outline.AfterOutlineExpandingEventArgs.#ctor(unvell.ReoGrid.Outline.ReoGridOutline)">
            <summary>
            Create event arguments instance.
            </summary>
            <param name="outline">The outline has been expanded.</param>
        </member>
        <member name="T:unvell.ReoGrid.PartialGridCopyFlag">
            <summary>
            Partial spreadsheet copy operation flag
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.PartialGridCopyFlag.All">
            <summary>
            All content will be processed
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.PartialGridCopyFlag.CellAll">
            <summary>
            Cell value and cell styles will be processed (CellData | CellFormula | CellFormat | CellStyle)
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.PartialGridCopyFlag.CellData">
            <summary>
            Copy cells data.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.PartialGridCopyFlag.CellFormula">
            <summary>
            Copy cells formula.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.PartialGridCopyFlag.CellFormat">
            <summary>
            Copy cells data format.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.PartialGridCopyFlag.CellStyle">
            <summary>
            Copy cells style.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.PartialGridCopyFlag.BorderAll">
            <summary>
            Copy all borders. (HBorder | VBorder)
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.PartialGridCopyFlag.HBorder">
            <summary>
            Only horizontal borders will be processed
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.PartialGridCopyFlag.VBorder">
            <summary>
            Only vertical borders will be processed
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.ExPartialGridCopyFlag.BorderOutsideOwner">
            <summary>
            Copy all borders that around the cells (ignores border's owner property)
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.PartialGrid">
            <summary>
            Partial grid contains the cells and borders, including the data and styles from 
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.PartialGrid.Rows">
            <summary>
            Number of rows in this partial grid
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.PartialGrid.Columns">
            <summary>
            Number of columns in this partial grid
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.PartialGrid.#ctor">
            <summary>
            Create an empty partial grid without and data, borders and styles
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.PartialGrid.#ctor(System.Int32,System.Int32)">
            <summary>
            Create an empty partial grid with specified capacity
            </summary>
            <param name="initRows">capacity of rows</param>
            <param name="initCols">capacity of cols</param>
        </member>
        <member name="M:unvell.ReoGrid.PartialGrid.#ctor(System.Object[0:,0:])">
            <summary>
            Create grid with specified data
            </summary>
            <param name="data">data to fill this partial grid</param>
        </member>
        <member name="M:unvell.ReoGrid.PartialGrid.Equals(System.Object)">
            <summary>
            Compare this partial grid to another object
            </summary>
            <param name="obj">object to be compared</param>
            <returns>true if the object is same as this partial grid, otherwise false</returns>
        </member>
        <member name="M:unvell.ReoGrid.PartialGrid.Equals(unvell.ReoGrid.PartialGrid,unvell.ReoGrid.PartialGridCopyFlag)">
            <summary>
            Compare this partial grid to another grid with specified comparison flag
            </summary>
            <param name="anotherPartialGrid">another partial grid to be compared</param>
            <param name="flag">comparison flag</param>
            <returns>true if two partial grid are same, otherwise return false</returns>
        </member>
        <member name="M:unvell.ReoGrid.PartialGrid.GetHashCode">
            <summary>
            Get hash code of this prtail grid object
            </summary>
            <returns>generated hash code</returns>
        </member>
        <member name="T:unvell.ReoGrid.ReoGridHorAlign">
            <summary>
            Cell horizontal alignment (default: General)
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.ReoGridHorAlign.General">
            <summary>
            General horizontal alignment (Spreadsheet decides the alignment automatically)
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.ReoGridHorAlign.Left">
            <summary>
            Left
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.ReoGridHorAlign.Center">
            <summary>
            Center
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.ReoGridHorAlign.Right">
            <summary>
            Right
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.ReoGridHorAlign.DistributedIndent">
            <summary>
            Distributed to fill the space of cell
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.ReoGridVerAlign">
            <summary>
            Cell vertical alignment (default: Middle)
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.ReoGridVerAlign.General">
            <summary>
            Default
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.ReoGridVerAlign.Top">
            <summary>
            Top
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.ReoGridVerAlign.Middle">
            <summary>
            Middle
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.ReoGridVerAlign.Bottom">
            <summary>
            Bottom
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.PlainStyleFlag">
            <summary>
            Key of cell style item
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.PlainStyleFlag.None">
            <summary>
            None style will be added or removed
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.PlainStyleFlag.FontName">
            <summary>
            Font name
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.PlainStyleFlag.FontSize">
            <summary>
            Font size
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.PlainStyleFlag.FontStyleBold">
            <summary>
            Font bold
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.PlainStyleFlag.FontStyleItalic">
            <summary>
            Font italic
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.PlainStyleFlag.FontStyleStrikethrough">
            <summary>
            Font strikethrough
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.PlainStyleFlag.FontStyleUnderline">
            <summary>
            Font underline
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.PlainStyleFlag.TextColor">
            <summary>
            Text color
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.PlainStyleFlag.BackColor">
            <summary>
            Background color
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.PlainStyleFlag.LineColor">
            <summary>
            Line color (Reserved)
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.PlainStyleFlag.LineStyle">
            <summary>
            Line style (Reserved)
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.PlainStyleFlag.LineWeight">
            <summary>
            Line weight (Reserved)
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.PlainStyleFlag.LineStartCap">
            <summary>
            Line start cap (Reserved)
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.PlainStyleFlag.LineEndCap">
            <summary>
            Line end cap (Reserved)
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.PlainStyleFlag.HorizontalAlign">
            <summary>
            Horizontal alignements
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.PlainStyleFlag.VerticalAlign">
            <summary>
            Vertical alignement
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.PlainStyleFlag.FillPatternColor">
            <summary>
            Background pattern color (not supported in WPF version)
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.PlainStyleFlag.FillPatternStyle">
            <summary>
            Background pattern style (not supported in WPF version)
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.PlainStyleFlag.TextWrap">
            <summary>
            Text wrap (word-break mode)
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.PlainStyleFlag.Indent">
            <summary>
            Padding
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.PlainStyleFlag.Padding">
            <summary>
            Padding
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.PlainStyleFlag.RotateAngle">
            <summary>
            Rotation angle for cell text (0.8.8 Reserved)
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.PlainStyleFlag.FontStyleAll">
            <summary>
            [Union flag] All flags of font style
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.PlainStyleFlag.FontAll">
            <summary>
            [Union flag] All font styles (name, size and style)
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.PlainStyleFlag.LineAll">
            <summary>
            [Union flag] All line styles (color, style, weight and caps)
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.PlainStyleFlag.LayoutAll">
            <summary>
            [Union flag] All layout styles (Text-wrap, padding and angle)
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.PlainStyleFlag.AlignAll">
            <summary>
            [Union flag] Both horizontal and vertical alignments
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.PlainStyleFlag.FillPattern">
            <summary>
            [Union flag] Background pattern (color and style)
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.PlainStyleFlag.BackAll">
            <summary>
            [Union flag] All background styles (color and pattern)
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.PlainStyleFlag.All">
            <summary>
            [Union flag] All styles
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.TextWrapMode">
            <summary>
            Text-wrap mode of cell
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.TextWrapMode.NoWrap">
            <summary>
            No break (default)
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.TextWrapMode.WordBreak">
            <summary>
            Normal word break
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.TextWrapMode.BreakAll">
            <summary>
            Break enabled for all characters
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.PaddingValue">
            <summary>
            Padding value struct
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.PaddingValue.Top">
            <summary>
            Get or set top padding
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.PaddingValue.Bottom">
            <summary>
            Get or set bottom padding
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.PaddingValue.Left">
            <summary>
            Get or set left padding
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.PaddingValue.Right">
            <summary>
            Get or set right padding
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.PaddingValue.#ctor(System.Double)">
            <summary>
            Create padding and set all values with same specified value.
            </summary>
            <param name="all">Value applied to all padding.</param>
        </member>
        <member name="M:unvell.ReoGrid.PaddingValue.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Create padding with every specified values. (in pixel)
            </summary>
            <param name="top">Top padding.</param>
            <param name="bottom">Bottom padding.</param>
            <param name="left">Left padding.</param>
            <param name="right">Right padding.</param>
        </member>
        <member name="F:unvell.ReoGrid.PaddingValue.Empty">
            <summary>
            Predefined empty padding value
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.PaddingValue.op_Equality(unvell.ReoGrid.PaddingValue,unvell.ReoGrid.PaddingValue)">
            <summary>
            Compare two padding values whether are same
            </summary>
            <param name="p1">Padding value 1 to be compared</param>
            <param name="p2">Padding value 2 to be compared</param>
            <returns>True if two padding values are same; otherwise return false</returns>
        </member>
        <member name="M:unvell.ReoGrid.PaddingValue.op_Inequality(unvell.ReoGrid.PaddingValue,unvell.ReoGrid.PaddingValue)">
            <summary>
            Compare two padding values whether are not same
            </summary>
            <param name="p1">Padding value 1 to be compared</param>
            <param name="p2">Padding value 2 to be compared</param>
            <returns>True if two padding values are not same; otherwise return false</returns>
        </member>
        <member name="M:unvell.ReoGrid.PaddingValue.Equals(System.Object)">
            <summary>
            Compare an object and check whether two padding value are same
            </summary>
            <param name="obj">Another object to be checked</param>
            <returns>True if two padding values are same; otherwise return false</returns>
        </member>
        <member name="M:unvell.ReoGrid.PaddingValue.GetHashCode">
            <summary>
            Get hash code of this object
            </summary>
            <returns>Hash code</returns>
        </member>
        <member name="T:unvell.ReoGrid.WorksheetRangeStyle">
            <summary>
            Styles of range or cells. By specifying PlainStyleFlag to determine 
            what styles should be used in this set.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.WorksheetRangeStyle.Flag">
            <summary>
            Get or set the styles flag that indicates what styles are contained in this style set
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.WorksheetRangeStyle.BackColor">
            <summary>
            Get or set background color 
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.WorksheetRangeStyle.FillPatternColor">
            <summary>
            Get or set backgrond pattern color.
            When set pattern color or pattern style, the background color should also be set.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.WorksheetRangeStyle.FillPatternStyle">
            <summary>
            Get or set background pattern style.
            When set pattern color or pattern style, the background color should also be set.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.WorksheetRangeStyle.TextColor">
            <summary>
            Get or set text color
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.WorksheetRangeStyle.FontName">
            <summary>
            Get or set font name
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.WorksheetRangeStyle.FontSize">
            <summary>
            Get or set font size
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.WorksheetRangeStyle.Bold">
            <summary>
            Get or set bold style
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.WorksheetRangeStyle.Italic">
            <summary>
            Get or set italic style
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.WorksheetRangeStyle.Strikethrough">
            <summary>
            Get or set strikethrough style
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.WorksheetRangeStyle.Underline">
            <summary>
            Get or set underline style
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.WorksheetRangeStyle.HAlign">
            <summary>
            Get or set horizontal alignment
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.WorksheetRangeStyle.VAlign">
            <summary>
            Get or set vertical alignment
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.WorksheetRangeStyle.TextWrapMode">
            <summary>
            Get or set text-wrap mode
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.WorksheetRangeStyle.Indent">
            <summary>
            Get or set text indent (0-65535)
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.WorksheetRangeStyle.Padding">
            <summary>
            Get or set padding of cell.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.WorksheetRangeStyle.#ctor">
            <summary>
            Create an empty style set.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.WorksheetRangeStyle.#ctor(unvell.ReoGrid.WorksheetRangeStyle)">
            <summary>
            Create style set by copying from another one.
            </summary>
            <param name="source">Another style set to be copied.</param>
        </member>
        <member name="M:unvell.ReoGrid.WorksheetRangeStyle.Clone(unvell.ReoGrid.WorksheetRangeStyle)">
            <summary>
            Clone style set from specified another style set.
            </summary>
            <param name="source">Another style to be cloned.</param>
            <returns>New cloned style set.</returns>
        </member>
        <member name="M:unvell.ReoGrid.WorksheetRangeStyle.CopyFrom(unvell.ReoGrid.WorksheetRangeStyle)">
            <summary>
            Copy styles from another specified one.
            </summary>
            <param name="s">Style to be copied.</param>
        </member>
        <member name="F:unvell.ReoGrid.WorksheetRangeStyle.Empty">
            <summary>
            Predefined empty style set.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.WorksheetRangeStyle.Equals(System.Object)">
            <summary>
            Check two styles and compare whether or not they are same.
            </summary>
            <param name="obj">Another style object compared to this object.</param>
            <returns>True if thay are same; otherwise return false.</returns>
        </member>
        <member name="M:unvell.ReoGrid.WorksheetRangeStyle.GetHashCode">
            <summary>
            Get hash code of this object.
            </summary>
            <returns>hash code</returns>
        </member>
        <member name="M:unvell.ReoGrid.WorksheetRangeStyle.HasStyle(unvell.ReoGrid.PlainStyleFlag)">
            <summary>
            Check whether this set of style contains specified style item.
            </summary>
            <param name="flag">Style item to be checked.</param>
            <returns>Ture if this set contains specified style item.</returns>
        </member>
        <member name="M:unvell.ReoGrid.WorksheetRangeStyle.HasAny(unvell.ReoGrid.PlainStyleFlag)">
            <summary>
            Check whether this set of style contains any of one of specified style items.
            </summary>
            <param name="flag">Style items to be checked.</param>
            <returns>True if this set contains any one of specified items.</returns>
        </member>
        <member name="T:unvell.ReoGrid.ReoGridRangeStyle">
            <summary>
            Obsoleted range style object, changed to ReoGridStyleObject.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.ReferenceStyle">
            <summary>
            Referenced style instance to cell of range
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReferenceStyle.Worksheet">
            <summary>
            Get worksheet instance
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.ReferenceStyle.op_Implicit(unvell.ReoGrid.ReferenceStyle)~unvell.ReoGrid.WorksheetRangeStyle">
            <summary>
            Convert style reference to style object.
            </summary>
            <param name="refStyle">Style reference to be converted.</param>
            <returns>Style object converted from style reference.</returns>
        </member>
        <member name="T:unvell.ReoGrid.ReferenceRangeStyle">
            <summary>
            Range reference to spreadsheet
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReferenceRangeStyle.BackColor">
            <summary>
            Get or set the background color to entire range
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReferenceRangeStyle.TextColor">
            <summary>
            Get or set the text color to entire range
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReferenceRangeStyle.FontName">
            <summary>
            Get or set the font name to entire range
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReferenceRangeStyle.FontSize">
            <summary>
            Get or set the font size to entire range
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReferenceRangeStyle.Bold">
            <summary>
            Get or set bold font style to entire range
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReferenceRangeStyle.Italic">
            <summary>
            Get or set italic font style to entire range
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReferenceRangeStyle.Underline">
            <summary>
            Get or set underline font style to entire range
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReferenceRangeStyle.Strikethrough">
            <summary>
            Get or set the strikethrough to entire range
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReferenceRangeStyle.HorizontalAlign">
            <summary>
            Get or set the horizontal alignment to entire range
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReferenceRangeStyle.VerticalAlign">
            <summary>
            Get or set the vertical alignment to entire range
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReferenceRangeStyle.Padding">
            <summary>
            Get or set the padding to entire range
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReferenceRangeStyle.TextWrap">
            <summary>
            Get or set the text-wrap style to entire range
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReferenceRangeStyle.Indent">
            <summary>
            Get or set the cell indent
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.ColumnHeaderStyle">
            <summary>
            Referenced style for column header
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.ColumnHeaderStyle.columnHeader">
            <summary>
            Column header instance
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ColumnHeaderStyle.Bold">
            <summary>
            Get or set horizontal alignment for all cells on this row
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ColumnHeaderStyle.Italic">
            <summary>
            Get or set horizontal alignment for all cells on this row
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ColumnHeaderStyle.Strikethrough">
            <summary>
            Get or set horizontal alignment for all cells on this row
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ColumnHeaderStyle.Underline">
            <summary>
            Get or set horizontal alignment for all cells on this row
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ColumnHeaderStyle.HorizontalAlign">
            <summary>
            Get or set horizontal alignment for all cells on this column
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ColumnHeaderStyle.VerticalAlign">
            <summary>
            Get or set horizontal alignment for all cells on this column
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ColumnHeaderStyle.Padding">
            <summary>
            Get or set padding for all cells on this column
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ColumnHeaderStyle.BackColor">
            <summary>
            Get or set background color for all cells on this column
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ColumnHeaderStyle.TextColor">
            <summary>
            Get or set background color for all cells on this column
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.RowHeaderStyle">
            <summary>
            Refereced style for row header
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.RowHeaderStyle.Bold">
            <summary>
            Get or set horizontal alignment for all cells on this row
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.RowHeaderStyle.Italic">
            <summary>
            Get or set horizontal alignment for all cells on this row
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.RowHeaderStyle.Strikethrough">
            <summary>
            Get or set horizontal alignment for all cells on this row
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.RowHeaderStyle.Underline">
            <summary>
            Get or set horizontal alignment for all cells on this row
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.RowHeaderStyle.HorizontalAlign">
            <summary>
            Get or set horizontal alignment for all cells on this row
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.RowHeaderStyle.VerticalAlign">
            <summary>
            Get or set horizontal alignment for all cells on this row
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.RowHeaderStyle.Padding">
            <summary>
            Get or set padding for all cells on this row
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.RowHeaderStyle.BackColor">
            <summary>
            Get or set background color for all cells on this row
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.RowHeaderStyle.TextColor">
            <summary>
            Get or set background color for all cells on this row
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.ReferenceCellStyle">
            <summary>
            Referenced cell style
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReferenceCellStyle.Cell">
            <summary>
            Referenced cell instance
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.ReferenceCellStyle.#ctor(unvell.ReoGrid.Cell)">
            <summary>
            Create referenced cell style
            </summary>
            <param name="sheet"></param>
            <param name="cell"></param>
        </member>
        <member name="P:unvell.ReoGrid.ReferenceCellStyle.BackColor">
            <summary>
            Get or set cell background color.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReferenceCellStyle.HAlign">
            <summary>
            Get or set the horizontal alignment for the cell content.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReferenceCellStyle.VAlign">
            <summary>
            Get or set the vertical alignment for the cell content.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReferenceCellStyle.TextColor">
            <summary>
            Get or set text color of cell.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReferenceCellStyle.FontName">
            <summary>
            Get or set font name of cell.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReferenceCellStyle.FontSize">
            <summary>
            Get or set font name of cell.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReferenceCellStyle.Bold">
            <summary>
            Determine whether or not the font style is bold.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReferenceCellStyle.Italic">
            <summary>
            Determine whether or not the font style is italic.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReferenceCellStyle.Strikethrough">
            <summary>
            Determine whether or not the font style has strikethrough.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReferenceCellStyle.Underline">
            <summary>
            Determine whether or not the font style has underline.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReferenceCellStyle.TextWrap">
            <summary>
            Get or set the cell text-wrap mode.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReferenceCellStyle.Indent">
            <summary>
            Get or set cell indent.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReferenceCellStyle.Padding">
            <summary>
            Get or set padding of cell layout.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.EndEditReason">
            <summary>
            Reason for ending of cell edit
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.EndEditReason.NormalFinish">
            <summary>
            User edit has done normally
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.EndEditReason.Cancel">
            <summary>
            User has cancelled edit operation
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.WorksheetSelectionMode">
            <summary>
            Represents selection mode for worksheet.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.WorksheetSelectionMode.None">
            <summary>
            Do not allow to select anything on worksheet.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.WorksheetSelectionMode.Cell">
            <summary>
            Only allow to select single cell.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.WorksheetSelectionMode.Range">
            <summary>
            Allow to select cell or ranges. (Default)
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.WorksheetSelectionMode.Row">
            <summary>
            Always to select one or more entire rows at a time.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.WorksheetSelectionMode.Column">
            <summary>
            Always to select one or more entire columns at a time.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.WorksheetSelectionMode.SingleRow">
            <summary>
            Allow to select only one row. (Reserved)
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.WorksheetSelectionMode.SingleColumn">
            <summary>
            Allow to select only one column. (Reserved)
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.WorksheetSelectionStyle">
            <summary>
            Represents selection style for worksheet.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.WorksheetSelectionStyle.None">
            <summary>
            No selection will be drawn.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.WorksheetSelectionStyle.Default">
            <summary>
            Default selection style.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.WorksheetSelectionStyle.FocusRect">
            <summary>
            Windows classic focus rectangle style.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.SelectionForwardDirection">
            <summary>
            Selection Forward Direction for worksheet. When user finished cell edit,
            or Enter key is pressed on worksheet, the focus cell moves to next cell at right column.
            By changing this direction to change the moving direction of focus cell.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.SelectionForwardDirection.Right">
            <summary>
            Move to cell at right column.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.SelectionForwardDirection.Down">
            <summary>
            Move to cell at below row.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.FocusPosStyle">
            <summary>
            Determine the style to show focus cell
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.FocusPosStyle.Default">
            <summary>
            Default style (cell with no background filled)
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.FocusPosStyle.None">
            <summary>
            Nothing specical on focus cell
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.OperationStatus">
            <summary>
            Behavior for spreadsheet operations
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.OperationStatus.Default">
            <summary>
            Change Selection Range, Edit cell, Move focus cell by keyboard and etc.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.OperationStatus.RangeSelect">
            <summary>
            Selecting focus range by dragging mouse.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.OperationStatus.AdjustRowHeight">
            <summary>
            Adjust row height or column width.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.OperationStatus.SelectionRangeMove">
            <summary>
            Move a selection range by dragging mouse on border of selection.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.OperationStatus.RangePicker">
            <summary>
            Picking a range during formula inputting.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.FreezePosition">
            <summary>
            Represents the activation area of frozen worksheet.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.FreezePosition.None">
            <summary>
            Do not freeze to any positions.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.FreezePosition.Left">
            <summary>
            Freeze to left .
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.FreezePosition.Top">
            <summary>
            Freeze to top.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.FreezePosition.Right">
            <summary>
            Freeze to right.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.FreezePosition.Bottom">
            <summary>
            Freeze to bottom.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.FreezePosition.LeftTop">
            <summary>
            Freeze to left and top.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.FreezePosition.LeftBottom">
            <summary>
            Freeze to left and bottom.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.FreezePosition.RightTop">
            <summary>
            Freeze to right and top.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.FreezePosition.RightBottom">
            <summary>
            Freeze to right and bottom.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.FreezeArea">
            <summary>
            Represents the frozen areas.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.FreezeArea.None">
            <summary>
            Do not freeze to any positions.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.FreezeArea.Left">
            <summary>
            Freeze to left.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.FreezeArea.Top">
            <summary>
            Freeze to top.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.FreezeArea.Right">
            <summary>
            Freeze to right.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.FreezeArea.Bottom">
            <summary>
            Freeze to bottom.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.FreezeArea.LeftTop">
            <summary>
            Freeze to left and top.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.FreezeArea.LeftBottom">
            <summary>
            Freeze to left and bottom.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.FreezeArea.RightTop">
            <summary>
            Freeze to right and top.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.FreezeArea.RightBottom">
            <summary>
            Freeze to right and bottom.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.ReoGridViewMode">
            <summary>
            View mode of current worksheet.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.ReoGridViewMode.Normal">
            <summary>
            Normal view
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.ReoGridViewMode.PageView">
            <summary>
            Page view
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.ReoGridViewMode.Custom">
            <summary>
            Custom view (Reserved)
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.WorksheetSettings">
            <summary>
            Worksheet Settings
            </summary>
            <remarks>Refer to: http://reogrid.net/document/settings </remarks>
        </member>
        <member name="F:unvell.ReoGrid.WorksheetSettings.None">
            <summary>
            None settings.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.WorksheetSettings.Default">
            <summary>
            Default settings.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.WorksheetSettings.Edit_Default">
            <summary>
            All default edit settings.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.WorksheetSettings.Edit_Readonly">
            <summary>
            Make worksheet read-only. Any changes are not allowed.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.WorksheetSettings.Edit_AutoFormatCell">
            <summary>
            Allow data format after text editing by user.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.WorksheetSettings.Edit_FriendlyPercentInput">
            <summary>
            Allow to put a '%' symbol at the end of text when start edit a cell that is set as percent data format.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.WorksheetSettings.Edit_AutoAdjustRowHeight">
            <summary>
            Allow automatically adjust row height to fit largest cells.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.WorksheetSettings.Edit_AutoExpandRowHeight">
            <summary>
            Allow automatically adjust row height to fit largest cells.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.WorksheetSettings.Edit_AllowAdjustRowHeight">
            <summary>
            Allow user adjusts row height by mouse.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.WorksheetSettings.Edit_AutoAdjustColumnWidth">
            <summary>
            Allow automatically adjust column width to fit largest cells.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.WorksheetSettings.Edit_AutoExpandColumnWidth">
            <summary>
            Allow automatically adjust column width to fit largest cells.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.WorksheetSettings.Edit_AllowAdjustColumnWidth">
            <summary>
            Allows user adjusts column width by mouse.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.WorksheetSettings.Edit_DragSelectionToMoveCells">
            <summary>
            Allow user drags and drops the selection to move cell content.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.WorksheetSettings.Edit_DragSelectionToFillSerial">
            <summary>
            Allow user drags and drops selection to fill data serial, reuse formulas or clear data. (Requires ReoGrid Pro)
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.WorksheetSettings.Behavior_Default">
            <summary>
            All behaivor settings.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:unvell.ReoGrid.WorksheetSettings.Behavior_DoubleClickToResizeHeader" -->
        <member name="F:unvell.ReoGrid.WorksheetSettings.Behavior_DoubleClickToFitRowHeight">
            <summary>
            Allow double click to make the row height fits to maximum text of cells.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.WorksheetSettings.Behavior_DoubleClickToFitColumnWidth">
            <summary>
            Allow double click to make the column width fits to maximum text of cells.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.WorksheetSettings.Behavior_MouseWheelToScroll">
            <summary>
            Allow to scroll spreadsheet by mouse wheeling.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.WorksheetSettings.Behavior_MouseWheelToZoom">
            <summary>
            Allow user zooms worksheet by wheeling mouse.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.WorksheetSettings.Behavior_ShortcutKeyToZoom">
            <summary>
            Allow user zooms worksheet by hotkeys. (ctrl + plus/minus)
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.WorksheetSettings.Behavior_AllowUserChangingPageBreaks">
            <summary>
            Allow user insert or adjust the page breaks by mouse.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.WorksheetSettings.Behavior_DragToMoveCells">
            <summary>
            Allow user to move selected cells by dragging mouse.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.WorksheetSettings.Behavior_ScrollToFocusCell">
            <summary>
            Allow always scroll worksheet automatically to make focus cell entirely visible.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.WorksheetSettings.View_Default">
            <summary>
            Default view settings (View_ShowHeaders | View_ShowGridLine | View_AllowShowOutlines)
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.WorksheetSettings.View_ShowColumnHeader">
            <summary>
            Show column header.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.WorksheetSettings.View_ShowRowHeader">
            <summary>
            Show row header.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.WorksheetSettings.View_ShowHeaders">
            <summary>
            Show column header and row header.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.WorksheetSettings.View_ShowHorizontalRuler">
            <summary>
            Show Horizontal Ruler. (Reserved)
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.WorksheetSettings.View_ShowVerticalRuler">
            <summary>
            Show Vertical Ruler. (Reserved)
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.WorksheetSettings.View_ShowRulers">
            <summary>
            Show rulers in horizontal and vertical direction. (Reserved)
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.WorksheetSettings.View_ShowGridLine">
            <summary>
            Show guide line.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.WorksheetSettings.View_ShowGuideLine">
            <summary>
            Show guide line.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.WorksheetSettings.View_AllowShowRowOutlines">
            <summary>
            Allow to show outlines for rows.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.WorksheetSettings.View_AllowShowColumnOutlines">
            <summary>
            Allow to show outlines for columns.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.WorksheetSettings.View_AllowShowOutlines">
            <summary>
            Allow to show outlines on both row and column.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.WorksheetSettings.View_ShowHiddenCellLine">
            <summary>
            Allow cell text be displayed overflow the boundary of cell.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.WorksheetSettings.View_AllowCellTextOverflow">
            <summary>
            Allow cell text be displayed overflow the boundary of cell.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.WorksheetSettings.View_ShowPageBreaks">
            <summary>
            Enable to show pages boundaries for printing areas.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.WorksheetSettings.View_AntialiasDrawing">
            <summary>
            Enable anti-alias drawing.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.WorksheetSettings.View_ShowFrozenLine">
            <summary>
            Allow to show a gray solid line at frozen cells.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.WorksheetSettings.Formula_Default">
            <summary>
            Default formula settings.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.WorksheetSettings.Formula_AutoUpdateReferenceCell">
            <summary>
            Allow to update formula reference cells automatically.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Data.AutoColumnFilter">
            <summary>
            Built-in auto column filter
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Data.AutoColumnFilter.Worksheet">
            <summary>
            Get instance of current attached worksheet.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Data.AutoColumnFilter.Columns">
            <summary>
            Get the columns of this filter.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Data.AutoColumnFilter.Apply">
            <summary>
            Apply filter to update worksheet.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Data.AutoColumnFilter.FilterColumnCollection">
            <summary>
            Collection of column filters
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Data.AutoColumnFilter.FilterColumnCollection.Item(System.Int32)">
            <summary>
            Get the column filter by specified index.
            </summary>
            <param name="index">number of column to get column filter.</param>
            <returns>instance of column filter, which contains the candidates list and selected items by user.</returns>
        </member>
        <member name="P:unvell.ReoGrid.Data.AutoColumnFilter.FilterColumnCollection.Item(System.String)">
            <summary>
            Get the column filter by specified address code of column (A, TZ, etc.)
            </summary>
            <param name="columnCode">the alphabet of address code used to locate a column in spreadsheet</param>
            <returns>instance of column filter, which contains the candidates list and selected items by user</returns>
        </member>
        <member name="M:unvell.ReoGrid.Data.AutoColumnFilter.FilterColumnCollection.GetEnumerator">
            <summary>
            Get all column filter header body from this filter.
            </summary>
            <returns></returns>
        </member>
        <member name="P:unvell.ReoGrid.Data.AutoColumnFilter.AutoColumnFilterBody.ColumnHeader">
            <summary>
            Column header instance
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Data.AutoColumnFilter.AutoColumnFilterBody.OnPaint(unvell.ReoGrid.Rendering.CellDrawingContext,unvell.ReoGrid.Graphics.Size)">
            <summary>
            Repaint filter header body
            </summary>
            <param name="dc">ReoGrid drawing context</param>
            <param name="headerSize">Header size</param>
        </member>
        <member name="M:unvell.ReoGrid.Data.AutoColumnFilter.AutoColumnFilterBody.OnMouseDown(unvell.ReoGrid.Graphics.Size,unvell.ReoGrid.Events.WorksheetMouseEventArgs)">
            <summary>
            Handling mouse-down process
            </summary>
            <param name="headerSize">Header size</param>
            <param name="e">Argument of mouse-down event</param>
            <returns>True if event has been handled; otherwise return false</returns>
        </member>
        <member name="M:unvell.ReoGrid.Data.AutoColumnFilter.AutoColumnFilterBody.OnMouseMove(unvell.ReoGrid.Graphics.Size,unvell.ReoGrid.Events.WorksheetMouseEventArgs)">
            <summary>
            Handling mouse-move process
            </summary>
            <param name="headerSize">Header size</param>
            <param name="e">Argument of mouse-move event</param>
            <returns>True if event has been handled, otherwise return false</returns>
        </member>
        <member name="P:unvell.ReoGrid.Data.AutoColumnFilter.AutoColumnFilterBody.IsSelectAll">
            <summary>
            Get or set whether or not this column is marked as SelectAll.
            The column is marked as SelectAll will be ignored during filter.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Data.AutoColumnFilter.AutoColumnFilterBody.SelectedTextItems">
            <summary>
            Collection of selected items
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Data.AutoColumnFilter.AutoColumnFilterBody.TextFilterCollection">
            <summary>
            Collection of selected items for column filter
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Data.AutoColumnFilter.AutoColumnFilterBody.TextFilterCollection.Item(System.String)">
            <summary>
            Check whether or not a specified item is selected by user.
            </summary>
            <param name="item">Item to be checked.</param>
            <returns>True if item is selected by user; Otherwise return false;</returns>
        </member>
        <member name="M:unvell.ReoGrid.Data.AutoColumnFilter.AutoColumnFilterBody.TextFilterCollection.GetEnumerator">
            <summary>
            Get the enumeration of items from this filter.
            </summary>
            <returns>Enumeration of items from this filter.</returns>
        </member>
        <member name="M:unvell.ReoGrid.Data.AutoColumnFilter.AutoColumnFilterBody.TextFilterCollection.Add(System.String)">
            <summary>
            Add selected item
            </summary>
            <param name="item">item to be added</param>
        </member>
        <member name="M:unvell.ReoGrid.Data.AutoColumnFilter.AutoColumnFilterBody.TextFilterCollection.Clear">
            <summary>
            Clear all selected items
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Data.AutoColumnFilter.AutoColumnFilterBody.TextFilterCollection.Contains(System.String)">
            <summary>
            Check whether the specified item is contained in selected items
            </summary>
            <param name="item">item to be checked</param>
            <returns>true if specified item has been contained in selected items, otherwise return false</returns>
        </member>
        <member name="M:unvell.ReoGrid.Data.AutoColumnFilter.AutoColumnFilterBody.TextFilterCollection.CopyTo(System.String[],System.Int32)">
            <summary>
            Copy all selected items into specified array
            </summary>
            <param name="array">array to be filled</param>
            <param name="arrayIndex">number of element start to copy</param>
        </member>
        <member name="P:unvell.ReoGrid.Data.AutoColumnFilter.AutoColumnFilterBody.TextFilterCollection.Count">
            <summary>
            Get number of selected items
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Data.AutoColumnFilter.AutoColumnFilterBody.TextFilterCollection.IsReadOnly">
            <summary>
            Check whether or not the collection of selection items is read-only
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Data.AutoColumnFilter.AutoColumnFilterBody.TextFilterCollection.Remove(System.String)">
            <summary>
            Remove specified item from selected items
            </summary>
            <param name="item">item to be removed</param>
            <returns>true if item exist and has been removed successfully</returns>
        </member>
        <member name="M:unvell.ReoGrid.Data.AutoColumnFilter.AutoColumnFilterBody.TextFilterCollection.AddRange(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Add entire specified array or enumerable list into selected items
            </summary>
            <param name="items">list, array or other enumerable collection to be added</param>
        </member>
        <member name="M:unvell.ReoGrid.Data.AutoColumnFilter.AutoColumnFilterBody.GetDistinctItems">
            <summary>
            Get distinct items from spreadsheet on current column
            </summary>
            <returns></returns>
        </member>
        <member name="M:unvell.ReoGrid.Data.AutoColumnFilter.AutoColumnFilterBody.OnDataChange(System.Int32,System.Int32)">
            <summary>
            Invoked when spreadsheet data changed on this column
            </summary>
            <param name="startRow">zero-based number of first row that data has been changed</param>
            <param name="endRow">zero-based number of last row that data has been changed</param>
        </member>
        <member name="E:unvell.ReoGrid.Data.AutoColumnFilter.FilterButtonPressed">
            <summary>
            Event raised when column filter button has been clicked
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Data.AutoColumnFilter.Attach(unvell.ReoGrid.Worksheet,unvell.ReoGrid.Data.AutoColumnFilterUI)">
            <summary>
            Attach filter to specified worksheet
            </summary>
            <param name="worksheet">instance of worksheet to be attached</param>
            <param name="uiFlag">Flags to decide which styles of GUI to be dispalyed (default is DropdownButtonAndPanel style)</param>
        </member>
        <member name="M:unvell.ReoGrid.Data.AutoColumnFilter.Detach">
            <summary>
            Detach filter from specified worksheet
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Data.AutoColumnFilterUI">
            <summary>
            Flag to create UI of column filter
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Data.AutoColumnFilterUI.NoGUI">
            <summary>
            Do not create any GUI 
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Data.AutoColumnFilterUI.DropdownButton">
            <summary>
            Only create a dropdown button on header
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Data.AutoColumnFilterUI.DropdownButtonAndPanel">
            <summary>
            Create both dropdown button and built-in panel
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Data.FilterButtonPressedEventArgs">
            <summary>
            Event raised when auto filter button was pressed by user
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Data.FilterButtonPressedEventArgs.ColumnHeader">
            <summary>
            Get the instance of column header
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Data.FilterButtonPressedEventArgs.IsCancelled">
            <summary>
            Set this flag to prevent open the built-in popup menu
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Data.FilterButtonPressedEventArgs.#ctor(unvell.ReoGrid.ColumnHeader)">
            <summary>
            Create filter button pressed event arguments with instance of column header
            </summary>
            <param name="columnHeader"></param>
        </member>
        <member name="T:unvell.ReoGrid.Data.IDataSource`1">
            <summary>
            Represents common data source.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Data.IDataSource`1.SerialCount">
            <summary>
            Get the number of available data serials of this source.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Data.IDataSource`1.Item(System.Int32)">
            <summary>
            Get data serial from specified position.
            </summary>
            <param name="index">Zero-based index to get data serial from this source.</param>
            <returns>Data serial object. Return null if given index is out of valid range.</returns>
        </member>
        <member name="E:unvell.ReoGrid.Data.IDataSource`1.DataChanged">
            <summary>
            This event will be raised when any data from the serial data range changed.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Data.IDataSerial">
            <summary>
            Represents data serial in data source.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Data.IDataSerial.Count">
            <summary>
            Get the number of items of this data serial.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Data.IDataSerial.Item(System.Int32)">
            <summary>
            Get data from specified position.
            </summary>
            <param name="index">Zero-based index position to get data from current serial.</param>
            <returns>Data in double. Return null if data cannot be converted to double or data not exist.</returns>
        </member>
        <member name="T:unvell.ReoGrid.Data.DictionaryRegularArray`1">
            <summary>
            Implementation of integer-indexed two-dimensional dictionary array.
            (up to 1048576 x 1048576 elements)
            </summary>
            <typeparam name="T">Any type as element in array</typeparam>
        </member>
        <member name="T:unvell.ReoGrid.Data.RegularTreeArray`1">
            <summary>
            Implementation of page-indexed two-dimensional regular array.
            (up to 1048576 x 32768 elements)
            </summary>
            <typeparam name="T">Any type as element in array</typeparam>
        </member>
        <member name="T:unvell.ReoGrid.Data.TreeArray`1">
            <summary>
            Implementation of page-indexed one-dimensional array.
            (up to 1048576 elements @ 16^5)
            </summary>
            <typeparam name="T">Any type as element in array</typeparam>
        </member>
        <member name="T:unvell.ReoGrid.Data.ArrayHelper">
            <summary>
            Generic Array Utility
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Data.ArrayHelper.QuickFind(System.Int32,System.Int32,System.Func{System.Int32,System.Int32})">
            <summary>
            Binary search for an element from an ordered array
            </summary>
            <param name="start">start position of range to be searched</param>
            <param name="end">end position of range to be searched</param>
            <param name="compare">delegate method is used to test whether an element is target</param>
            <returns>element as result will be returned</returns>
        </member>
        <member name="M:unvell.ReoGrid.Data.ArrayHelper.QuickFind(System.Int32,System.Int32,System.Int32,System.Func{System.Int32,System.Int32})">
            <summary>
            Binary search for an element from an ordered array
            </summary>
            <param name="split">first element as splitter to be tested</param>
            <param name="start">start position of range to be searched</param>
            <param name="end">end position of range to be searched</param>
            <param name="compare">delegate method is used to test whether an element is target</param>
            <returns>element as result will be returned</returns>
        </member>
        <member name="T:unvell.ReoGrid.IO.CSVFormatArgument">
            <summary>
            Arguments for loading and saving CSV format.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.IO.CSVFormatArgument.AutoSpread">
            <summary>
            Determines whether or not allow to expand worksheet to load more data from CSV file. (Default is True)
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.IO.CSVFormatArgument.BufferLines">
            <summary>
            Determines how many rows read from CSV file one time. (Default is CSVFormat.DEFAULT_READ_BUFFER_LINES = 512)
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.IO.CSVFormatArgument.SheetName">
            <summary>
            Determines the default worksheet name if CSV file loaded into a new workbook. (Default is "Sheet1")
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.IO.CSVFormatArgument.TargetRange">
            <summary>
            Determines where to start import CSV data on worksheet.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.IO.CSVFormatArgument.#ctor">
            <summary>
            Create the argument object instance.
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.IO.OpenXML.Schema.SharedStringItem.text">
            <summary>
            tag: t
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.IO.OpenXML.Schema.SharedStringItem.runs">
            <summary>
            tag: r
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.IO.FileFormat">
            <summary>
            File format flag
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.IO.FileFormat.ReoGridFormat">
            <summary>
            ReoGrid Format (RGF)
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.IO.FileFormat.CSV">
            <summary>
            CSV Plain-text format
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.IO.FileFormat.Excel2007">
            <summary>
            Excel 2007 (Office OpenXML-based format)
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.IO.FileFormat._Auto">
            <summary>
            Decide file format by extension automatically
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.IO.FileFormat._Custom">
            <summary>
            User-defined file format provider (Reserved)
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.IO.IFileFormatProvider">
            <summary>
            Interface of file format provider
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.IO.IFileFormatProvider.IsValidFormat(System.String)">
            <summary>
            Check whether specified filepath is valid file format to be processed.
            </summary>
            <param name="file">file path</param>
            <returns>true if specified file is valid format</returns>
        </member>
        <member name="M:unvell.ReoGrid.IO.IFileFormatProvider.Load(unvell.ReoGrid.IWorkbook,System.IO.Stream,System.Text.Encoding,System.Object)">
            <summary>
            Load spreadsheet from specified stream
            </summary>
            <param name="workbook">ReoGrid workbook to be loaded</param>
            <param name="stream">Stream to input serialized data of workbook</param>
            <param name="encoding">Encoding used to read plain-text file format</param>
            <param name="arg">Arguments of format provider</param>
        </member>
        <member name="M:unvell.ReoGrid.IO.IFileFormatProvider.Save(unvell.ReoGrid.IWorkbook,System.IO.Stream,System.Text.Encoding,System.Object)">
            <summary>
            Save spreadsheet to specified stream
            </summary>
            <param name="workbook">ReoGrid workbook to be saved</param>
            <param name="stream">Stream to output serialized data of workbook</param>
            <param name="encoding">Encoding used to write plain-text file format</param>
            <param name="arg">Arguments of format provider</param>
        </member>
        <member name="T:unvell.ReoGrid.IO.ReoGridFileFormatProvider">
            <summary>
            Represents the file format provider for saving and loading workbook and worksheets
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.IO.ReoGridFileFormatProvider.IsValidFormat(System.String)">
            <summary>
            Check whether or not the file is valid format of this provider
            </summary>
            <param name="file"></param>
            <returns></returns>
        </member>
        <member name="M:unvell.ReoGrid.IO.ReoGridFileFormatProvider.Load(unvell.ReoGrid.IWorkbook,System.IO.Stream,System.Text.Encoding,System.Object)">
            <summary>
            Load workbook from specified input stream
            </summary>
            <param name="workbook">Workbook to be loaded</param>
            <param name="stream">Input stream</param>
            <param name="encoding">Encoding used to read text-based stream, such as XML</param>
            <param name="arg">Provider custom parameters</param>
        </member>
        <member name="T:unvell.ReoGrid.IO.ReoGridFormatArgument">
            <summary>
            Class that contains some arguments for reading and saving RGF format.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.IO.ExcelFileFormatArgument">
            <summary>
            Class that contains some arguments for reading and saving Excel format.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.IO.RGHTMLExporter.Export(System.IO.Stream,unvell.ReoGrid.Worksheet,System.String,System.Boolean)">
            <summary>
            Export grid as html5 into specified stream
            </summary>
            <param name="s">Stream contains the exported HTML5 content</param>
            <param name="sheet">Instance of worksheet</param>
            <param name="pageTitle">Custom page title of HTML page</param>
            <param name="htmlHeader">True to export default HTML header tag; false to export table content only</param>
        </member>
        <member name="M:unvell.ReoGrid.IO.RGHTMLExporter.HtmlEncode(System.String)">
            <summary>
            HTML-encodes a string and returns the encoded string.
            </summary>
            <remarks>
            http://weblog.west-wind.com/posts/2009/Feb/05/Html-and-Uri-String-Encoding-without-SystemWeb
            </remarks>
            <param name="text">The text string to encode.</param>
            <returns>The HTML-encoded text.</returns>
        </member>
        <member name="T:unvell.ReoGrid.Rendering.BorderPainter">
            <summary>
            Draw borders at the specified location.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Rendering.BorderPainter.Instance">
            <summary>
            Get BorderPainter instance
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Rendering.BorderPainter.DrawLine(System.Windows.Media.DrawingContext,System.Double,System.Double,System.Double,System.Double,unvell.ReoGrid.RangeBorderStyle)">
            <summary>
            Draw border at specified location
            </summary>
            <param name="g">instance for graphics object</param>
            <param name="x">x coordinate of start point</param>
            <param name="y">y coordinate of start point</param>
            <param name="x2">x coordinate of end point</param>
            <param name="y2">y coordinate of end point</param>
            <param name="style">style instance of border</param>
        </member>
        <member name="M:unvell.ReoGrid.Rendering.BorderPainter.DrawLine(System.Windows.Media.DrawingContext,System.Double,System.Double,System.Double,System.Double,unvell.ReoGrid.BorderLineStyle,unvell.ReoGrid.Graphics.SolidColor,System.Windows.Media.Pen)">
            <summary>
            Draw border at specified position.
            </summary>
            <param name="g">Instance for graphics object.</param>
            <param name="x">X coordinate of start point.</param>
            <param name="y">Y coordinate of start point.</param>
            <param name="x2">X coordinate of end point.</param>
            <param name="y2">Y coordinate of end point.</param>
            <param name="style">Style flag of border.</param>
            <param name="color">Color of border.</param>
            <param name="bgPen">Fill pen used when drawing double outline.</param>
        </member>
        <member name="M:unvell.ReoGrid.Rendering.BorderPainter.Dispose">
            <summary>
            Release all cached objects.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Rendering.DrawMode">
            <summary>
            Drawing Mode for render grid control
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Rendering.DrawMode.View">
            <summary>
            View on screen
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Rendering.DrawMode.Preview">
            <summary>
            Print preview 
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.Rendering.DrawMode.Print">
            <summary>
            Print
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Rendering.DrawingContext">
            <summary>
            Represents the platform no-associated drawing context.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Rendering.DrawingContext.Worksheet">
            <summary>
            Get current instance of worksheet.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Rendering.DrawingContext.Graphics">
            <summary>
            Platform independent drawing context.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Rendering.DrawingContext.DrawMode">
            <summary>
            Draw mode that decides what kind of content will be drawn during this drawing event.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Rendering.CellDrawingContext">
            <summary>
            Drawing context for rendering cells.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Rendering.CellDrawingContext.Cell">
            <summary>
            Cell instance if enter a cell drawing event
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Rendering.CellDrawingContext.DrawCellText">
            <summary>
            Recall core renderer to draw cell text
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Rendering.CellDrawingContext.DrawCellBackground">
            <summary>
            Recall core renderer to draw cell background.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Views.CellsViewport.TryGetCellPositionToControl(unvell.ReoGrid.Views.IView,unvell.ReoGrid.CellPosition,unvell.ReoGrid.Graphics.Point@)">
            <summary>
            Transform position of specified cell into the position on control
            </summary>
            <param name="view">Source view of the specified cell position.</param>
            <param name="pos">Cell position to be converted.</param>
            <param name="p">Output point of the cell position related to grid control.</param>
            <returns>True if conversion is successful; Otherwise return false.</returns>
        </member>
        <member name="T:unvell.ReoGrid.Views.NormalViewportController">
            <summary>
            Standard view controller for normal scene of control
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Views.NormalViewportController.GetVisibleRegion(unvell.ReoGrid.Views.Viewport)">
            <summary>
            Update visible region for viewport. Visible region decides how many rows and columns 
            of cells (from...to) will be displayed.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Views.GridRegion.ToRange">
            <summary>
            Convert into range struct
            </summary>
            <returns></returns>
        </member>
        <member name="T:unvell.ReoGrid.Views.IFreezableViewportController">
            <summary>
            Interface for freezable ViewportController
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Views.IFreezableViewportController.Freeze">
            <summary>
            Freeze to specified cell and position.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Events.WorksheetEventArgs">
            <summary>
            Common worksheet event arguments 
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Events.WorksheetEventArgs.Worksheet">
            <summary>
            Instance of worksheet
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Events.WorksheetEventArgs.#ctor(unvell.ReoGrid.Worksheet)">
            <summary>
            Create common worksheet event arguments with specified instance of worksheet
            </summary>
            <param name="sheet">instance of worksheet related to the event</param>
        </member>
        <member name="T:unvell.ReoGrid.Events.WorkbookActionEventArgs">
            <summary>
            Arguments of event which will be fired when action is performed by worksheet
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Events.WorkbookActionEventArgs.Action">
            <summary>
            Action is performed
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Events.WorkbookActionEventArgs.#ctor(unvell.Common.IAction)">
            <summary>
            Create this event argument with specified action
            </summary>
            <param name="action">instance of action</param>
        </member>
        <member name="T:unvell.ReoGrid.Events.BeforeActionPerformEventArgs">
            <summary>
            Event argument for before action perform
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Events.BeforeActionPerformEventArgs.IsCancelled">
            <summary>
            Determine whehter to abort perform current action
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Events.BeforeActionPerformEventArgs.#ctor(unvell.Common.IAction)">
            <summary>
            Create event argument with specified action
            </summary>
            <param name="action">Action to be performed</param>
        </member>
        <member name="T:unvell.ReoGrid.Events.WorksheetCreatedEventArgs">
            <summary>
            Worksheet creating event argument
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Events.WorksheetCreatedEventArgs.#ctor(unvell.ReoGrid.Worksheet)">
            <summary>
            Create this event argument with specified instance of worksheet
            </summary>
            <param name="sheet">instance of worksheet</param>
        </member>
        <member name="T:unvell.ReoGrid.Events.WorksheetInsertedEventArgs">
            <summary>
            Worksheet inserting event argument
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Events.WorksheetInsertedEventArgs.Index">
            <summary>
            Zero-based number of sheet is inserted
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Events.WorksheetInsertedEventArgs.#ctor(unvell.ReoGrid.Worksheet)">
            <summary>
            Create this event argument with specified worksheet
            </summary>
            <param name="sheet">instance of worksheet</param>
        </member>
        <member name="T:unvell.ReoGrid.Events.WorksheetRemovedEventArgs">
            <summary>
            Worksheet removing event argument
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Events.WorksheetRemovedEventArgs.Index">
            <summary>
            Index of worksheet in workbook before removing
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Events.WorksheetRemovedEventArgs.#ctor(unvell.ReoGrid.Worksheet)">
            <summary>
            Create this event argument with specified worksheet
            </summary>
            <param name="sheet">instance of worksheet</param>
        </member>
        <member name="T:unvell.ReoGrid.Events.WorksheetNameChangingEventArgs">
            <summary>
            Worksheet's name changing event argument
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Events.WorksheetNameChangingEventArgs.NewName">
            <summary>
            Get or set the new name used to instead of the old name of worksheet
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Events.WorksheetNameChangingEventArgs.#ctor(unvell.ReoGrid.Worksheet,System.String)">
            <summary>
            Create this event argument with specified worksheet
            </summary>
            <param name="sheet">instance of worksheet</param>
            <param name="name">new name of worksheet</param>
        </member>
        <member name="T:unvell.ReoGrid.Events.CurrentWorksheetChangedEventArgs">
            <summary>
            Worksheet changing event argument
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Events.CurrentWorksheetChangedEventArgs.Index">
            <summary>
            Zero-based number of sheet has changed
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Events.CurrentWorksheetChangedEventArgs.#ctor(unvell.ReoGrid.Worksheet)">
            <summary>
            Create this event argument with specified worksheet
            </summary>
            <param name="sheet">instance of worksheet</param>
        </member>
        <member name="T:unvell.ReoGrid.Events.WorksheetScrolledEventArgs">
            <summary>
            Represents an event argument class for worksheet scrolling.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Events.WorksheetScrolledEventArgs.OffsetX">
            <summary>
            Scrolled horizontal value.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Events.WorksheetScrolledEventArgs.OffsetY">
            <summary>
            Scrolled vertical value.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Events.WorksheetScrolledEventArgs.#ctor(unvell.ReoGrid.Worksheet)">
            <summary>
            Create the instance of this event argument.
            </summary>
            <param name="worksheet">The worksheet where event happened.</param>
        </member>
        <member name="T:unvell.ReoGrid.Events.CellPosEventArgs">
            <summary>
            Position event argument on spreadsheet
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Events.CellPosEventArgs.Position">
            <summary>
            Zero-based two-dimensional coordinates to locate a cell on spreadsheet
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Events.CellPosEventArgs.#ctor(unvell.ReoGrid.CellPosition)">
            <summary>
            Construc this position event argument with specfieid position
            </summary>
            <param name="pos">zero-based two-dimensional coordinates on spreadsheet</param>
        </member>
        <member name="T:unvell.ReoGrid.Events.CellEventArgs">
            <summary>
            Event raised on action was performed for any cells
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Events.CellEventArgs.Cell">
            <summary>
            Get instance of current editing cell. This property may be null.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Events.CellEventArgs.#ctor(unvell.ReoGrid.Cell)">
            <summary>
            Create instance for CellEventArgs with specified cell.
            </summary>
            <param name="cell">Instance of current editing cell.</param>
        </member>
        <member name="T:unvell.ReoGrid.Events.WorksheetMouseEventArgs">
            <summary>
            ReoGrid common mouse event argument
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Events.WorksheetMouseEventArgs.Worksheet">
            <summary>
            Worksheet instance
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Events.WorksheetMouseEventArgs.Buttons">
            <summary>
            Pressed mouse buttons
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Events.WorksheetMouseEventArgs.RelativePosition">
            <summary>
            Event source associated mouse position
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Events.WorksheetMouseEventArgs.CursorPosition">
            <summary>
            Event source associated mouse position
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Events.WorksheetMouseEventArgs.AbsolutePosition">
            <summary>
            Event source unassociated mouse position (Position to control)
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Events.WorksheetMouseEventArgs.Clicks">
            <summary>
            Number of clicks
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Events.WorksheetMouseEventArgs.Delta">
            <summary>
            Delta value (only used in mouse wheel event)
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Events.WorksheetMouseEventArgs.Capture">
            <summary>
            Get or set whether to capture mouse from current event
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Events.WorksheetMouseEventArgs.CursorStyle">
            <summary>
            Get or set the cursor style during mouse over
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Events.WorksheetMouseEventArgs.#ctor(unvell.ReoGrid.Worksheet,unvell.ReoGrid.Graphics.Point,unvell.ReoGrid.Graphics.Point,unvell.ReoGrid.Interaction.MouseButtons,System.Int32)">
            <summary>
            Construct mouse event argument with specified parameters
            </summary>
            <param name="worksheet">worksheet instance</param>
            <param name="relativePosition">mouse relative position to current event owner</param>
            <param name="absolutePosition">mouse absolute position to spreadsheet control</param>
            <param name="buttons">pressed button flags</param>
            <param name="clicks">number of clicks</param>
        </member>
        <member name="T:unvell.ReoGrid.Events.CellMouseEventArgs">
            <summary>
            ReoGrid cell mouse event argument
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Events.CellMouseEventArgs.Cell">
            <summary>
            Event source instance of cell. Note: this property may be null if cell has no data and style attached. 
            Check this property and create cell instance by CellPosition property.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Events.CellMouseEventArgs.CellPosition">
            <summary>
            Zero-based cell position
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Events.CellMouseEventArgs.#ctor(unvell.ReoGrid.Worksheet,unvell.ReoGrid.CellPosition)">
            <summary>
            Create cell mouse event argument with specified parameters
            </summary>
            <param name="worksheet">worksheet instance</param>
            <param name="cellPosition">cell position</param>
        </member>
        <member name="M:unvell.ReoGrid.Events.CellMouseEventArgs.#ctor(unvell.ReoGrid.Worksheet,unvell.ReoGrid.CellPosition,unvell.ReoGrid.Graphics.Point,unvell.ReoGrid.Graphics.Point,unvell.ReoGrid.Interaction.MouseButtons,System.Int32)">
            <summary>
            Create cell mouse event argument with specified parameters
            </summary>
            <param name="worksheet">worksheet instance</param>
            <param name="cellPosition">cell position</param>
            <param name="relativePosition">relative mouse position (position in cell)</param>
            <param name="absolutePosition">absolute mouse position (position in spreadsheet)</param>
            <param name="buttons">pressed buttons</param>
            <param name="clicks">number of clicks</param>
        </member>
        <member name="M:unvell.ReoGrid.Events.CellMouseEventArgs.#ctor(unvell.ReoGrid.Worksheet,unvell.ReoGrid.Cell)">
            <summary>
            Create cell mouse event argument with specified parameters
            </summary>
            <param name="worksheet">worksheet instance</param>
            <param name="cell">cell instance</param>
        </member>
        <member name="M:unvell.ReoGrid.Events.CellMouseEventArgs.#ctor(unvell.ReoGrid.Worksheet,unvell.ReoGrid.Cell,unvell.ReoGrid.Graphics.Point,unvell.ReoGrid.Graphics.Point,unvell.ReoGrid.Interaction.MouseButtons,System.Int32)">
            <summary>
            Create cell mouse event argument with specified parameters
            </summary>
            <param name="worksheet">worksheet instance</param>
            <param name="cell">cell instance</param>
            <param name="relativePosition">relative mouse position (position in cell)</param>
            <param name="absolutePosition">absolute mouse position (position in spreadsheet)</param>
            <param name="buttons">pressed buttons</param>
            <param name="clicks">number of clicks</param>
        </member>
        <member name="M:unvell.ReoGrid.Events.CellMouseEventArgs.#ctor(unvell.ReoGrid.Worksheet,unvell.ReoGrid.Cell,unvell.ReoGrid.CellPosition,unvell.ReoGrid.Graphics.Point,unvell.ReoGrid.Graphics.Point,unvell.ReoGrid.Interaction.MouseButtons,System.Int32)">
            <summary>
            Create cell mouse event argument with specified parameters
            </summary>
            <param name="worksheet">worksheet instance</param>
            <param name="cell">cell instance</param>
            <param name="cellPosition">cell position</param>
            <param name="relativePosition">relative mouse position (position in cell)</param>
            <param name="absolutePosition">absolute mouse position (position in spreadsheet)</param>
            <param name="buttons">pressed buttons</param>
            <param name="clicks">number of clicks</param>
        </member>
        <member name="T:unvell.ReoGrid.Events.WorksheetKeyEventArgs">
            <summary>
            Common key event argument
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Events.CellKeyDownEventArgs">
            <summary>
            Common key event argument for cells
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Events.CellKeyDownEventArgs.Cell">
            <summary>
            Cell of event source
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Events.CellKeyDownEventArgs.CellPosition">
            <summary>
            Position of cell of event source
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Events.BeforeCellKeyDownEventArgs">
            <summary>
            Event raised when user presses any key inside spreadsheet before built-in operations
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Events.BeforeCellKeyDownEventArgs.IsCancelled">
            <summary>
            Determines whether or not should to cancel the following operations of this event.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Events.AfterCellKeyDownEventArgs">
            <summary>
            Event raised when user presses any key inside spreadsheet after built-in operations
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Events.CellAfterEditEventArgs">
            <summary>
            Event raised after cell editing. Set 'NewData' property to a
            new value to change the data instead of edited value.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Events.CellAfterEditEventArgs.NewData">
            <summary>
            Set the data to new value instead of edited value.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Events.CellAfterEditEventArgs.EndReason">
            <summary>
            Reason of edit operation ending. Set this property to restore 
            the data to the value of before editing.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Events.CellAfterEditEventArgs.DataFormat">
            <summary>
            When new data has been inputed, ReoGrid choose one formatter to 
            try to format the data. Set this property to force change the 
            formatter for the new data.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Events.CellAfterEditEventArgs.#ctor(unvell.ReoGrid.Cell)">
            <summary>
            Create instance for CellAfterEditEventArgs
            </summary>
            <param name="cell">Cell edited by user</param>
        </member>
        <member name="T:unvell.ReoGrid.Events.CellBeforeEditEventArgs">
            <summary>
            Event raised before cell enter edit mode. Set 'IsCancelled' property force to stop default edit operation.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Events.CellBeforeEditEventArgs.IsCancelled">
            <summary>
            Edit operation whether should be aborted.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Events.CellBeforeEditEventArgs.EditText">
            <summary>
            Text will display in the input field, this text could be changed.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Events.CellBeforeEditEventArgs.#ctor(unvell.ReoGrid.Cell)">
            <summary>
            Create instance for CellBeforeEditEventArgs with specified cell.
            </summary>
            <param name="cell">Instance of cell will be edited by user.</param>
        </member>
        <member name="T:unvell.ReoGrid.Events.CellEditTextChangingEventArgs">
            <summary>
            Cell edit text.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Events.CellEditTextChangingEventArgs.Text">
            <summary>
            Get or set the inputting text. Set new text to replace the text of user inputted.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Events.CellEditTextChangingEventArgs.#ctor(unvell.ReoGrid.Cell)">
            <summary>
            Create event argument with specified cell.
            </summary>
            <param name="cell">instance of cell</param>
        </member>
        <member name="T:unvell.ReoGrid.Events.CellEditCharInputEventArgs">
            <summary>
            Event raised when unicode char was inputted during cell editing,
            replace the <code>InputChar</code> property to alter the input character.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Events.CellEditCharInputEventArgs.InputChar">
            <summary>
            Get or set the input character.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Events.CellEditCharInputEventArgs.CaretPositionInLine">
            <summary>
            Get position of current editing text.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Events.CellEditCharInputEventArgs.LineIndex">
            <summary>
            Get line index of current editing text.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Events.CellEditCharInputEventArgs.InputText">
            <summary>
            Get current edit text inputted by user.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Events.WorksheetRowsEventArgs">
            <summary>
            Base argument for events when worksheet row changed.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Events.WorksheetRowsEventArgs.Row">
            <summary>
            Zero-based row index number.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Events.WorksheetRowsEventArgs.Count">
            <summary>
            Number of rows changed.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Events.WorksheetRowsEventArgs.#ctor(System.Int32,System.Int32)">
            <summary>
            Create instance for RowEventArgs with specified row index number.
            </summary>
            <param name="row">Zero-based row index number.</param>
        </member>
        <member name="T:unvell.ReoGrid.Events.RowsInsertedEventArgs">
            <summary>
            Argument for event when row inserted into worksheet.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Events.RowsDeletedEventArgs">
            <summary>
            Event raised when rows deleted from spreadsheet
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Events.RowsDeletedEventArgs.#ctor(System.Int32,System.Int32)">
            <summary>
            Create instance for RowEventArgs with specified row index number.
            </summary>
            <param name="row">zero-based number of row start to delete</param>
            <param name="count">number of rows to be deleted</param>
        </member>
        <member name="T:unvell.ReoGrid.Events.RowsHeightChangedEventArgs">
            <summary>
            Argument for event that will be raised when columns width is changed.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Events.RowsHeightChangedEventArgs.Height">
            <summary>
            The new height that has been changed for rows.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Events.WorksheetColumnsEventArgs">
            <summary>
            Event raised when an action of column header was performed.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Events.WorksheetColumnsEventArgs.Index">
            <summary>
            Zero-based number to insert columns
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Events.WorksheetColumnsEventArgs.Count">
            <summary>
            Indicates that how many columns has been inserted or appended
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Events.WorksheetColumnsEventArgs.#ctor(System.Int32,System.Int32)">
            <summary>
            Create instead for ColumnEventArgs with specified column header number.
            </summary>
            <param name="index">Column index number.</param>
            <param name="count">Column count.</param>
        </member>
        <member name="T:unvell.ReoGrid.Events.ColumnsInsertedEventArgs">
            <summary>
            Event raised when new column was inserted into a spreadsheet
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Events.ColumnsInsertedEventArgs.#ctor(System.Int32,System.Int32)">
            <summary>
            Create column inserted event argument
            </summary>
            <param name="index">Zero-based number of column start to insert</param>
            <param name="count">Number of columns to be inserted.</param>
        </member>
        <member name="T:unvell.ReoGrid.Events.ColumnsDeletedEventArgs">
            <summary>
            Event raised when columns deleted from spreadsheet
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Events.ColumnsDeletedEventArgs.#ctor(System.Int32,System.Int32)">
            <summary>
            Create column deleted event argument
            </summary>
            <param name="index">number of column start to delete</param>
            <param name="count">number of columns to be deleted</param>
        </member>
        <member name="T:unvell.ReoGrid.Events.ColumnsWidthChangedEventArgs">
            <summary>
            Argument for event that will be raised when columns width is changed.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Events.ColumnsWidthChangedEventArgs.Width">
            <summary>
            The new width changed for columns.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Events.BorderAddedEventArgs">
            <summary>
            Event raised on border added to a range.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Events.BorderAddedEventArgs.Pos">
            <summary>
            Position of border added.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Events.BorderAddedEventArgs.Style">
            <summary>
            Style of border added.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Events.BorderAddedEventArgs.#ctor(unvell.ReoGrid.RangePosition,unvell.ReoGrid.BorderPositions,unvell.ReoGrid.RangeBorderStyle)">
            <summary>
            Create instance for BorderAddedEventArgs with specified range, 
            position of border and style of border.
            </summary>
            <param name="range"></param>
            <param name="pos"></param>
            <param name="style"></param>
        </member>
        <member name="T:unvell.ReoGrid.Events.BorderRemovedEventArgs">
            <summary>
            Event raised on border removed from a range.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Events.BorderRemovedEventArgs.Pos">
            <summary>
            Position of border removed
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Events.BorderRemovedEventArgs.#ctor(unvell.ReoGrid.RangePosition,unvell.ReoGrid.BorderPositions)">
            <summary>
            Create instance for BorderRemovedEventArgs with specified range and
            position of border.
            </summary>
            <param name="range"></param>
            <param name="pos"></param>
        </member>
        <member name="T:unvell.ReoGrid.Events.FileLoadedEventArgs">
            <summary>
            Event raised on grid loaded from a stream.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Events.FileLoadedEventArgs.Filename">
            <summary>
            Full path of file. Available only grid was loaded from a file stream.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Events.FileLoadedEventArgs.#ctor(System.String)">
            <summary>
            Create instance for FileSavedEventArgs with specified file path.
            </summary>
            <param name="filename">Full path of file</param>
        </member>
        <member name="T:unvell.ReoGrid.Events.FileSavedEventArgs">
            <summary>
            Event raised on grid saved to a stream.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Events.FileSavedEventArgs.Filename">
            <summary>
            Full path of file. Available only grid be saved into a file stream.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Events.FileSavedEventArgs.#ctor(System.String)">
            <summary>
            Create instance for FileSavedEventArgs with specified file path.
            </summary>
            <param name="filename">Full path of file</param>
        </member>
        <member name="T:unvell.ReoGrid.Events.ExceptionHappenEventArgs">
            <summary>
            Event raised when any exceptions happen during built-in operations of worksheet.
            Such as Range copy/cut/move via built-in hotkeys.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Events.ExceptionHappenEventArgs.Exception">
            <summary>
            Get or set the exception instance.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Events.ExceptionHappenEventArgs.#ctor(unvell.ReoGrid.Worksheet,System.Exception)">
            <summary>
            Create exception instance.
            </summary>
            <param name="sheet">Worksheet instance.</param>
            <param name="exception">Exception instance.</param>
        </member>
        <member name="T:unvell.ReoGrid.Events.SelectionMoveForwardEventArgs">
            <summary>
            Event raised when selection will move to another position. 
            ReoGrid automatically move the selection to 'Right' or 'Down' according
            to 'SelectionForwardDirection' property of control. 
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Events.SelectionMoveForwardEventArgs.IsCancelled">
            <summary>
            Decide whether to cancel current operation
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Events.SelectionMoveForwardEventArgs.#ctor">
            <summary>
            Create instance for SelectionMoveForwardEventArgs with specified 
            position.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Events.BeforeSelectionChangeEventArgs">
            <summary>
            Argument class for event of BeforeSelectionChange
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Events.BeforeSelectionChangeEventArgs.SelectionStart">
            <summary>
            Get or set selection start position
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Events.BeforeSelectionChangeEventArgs.SelectionEnd">
            <summary>
            Get or set selection end position
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Events.BeforeSelectionChangeEventArgs.StartRow">
            <summary>
            Get or set the start row of selection
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Events.BeforeSelectionChangeEventArgs.StartCol">
            <summary>
            Get or set this start column of selection
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Events.BeforeSelectionChangeEventArgs.EndRow">
            <summary>
            Get or set the end row of selection
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Events.BeforeSelectionChangeEventArgs.EndCol">
            <summary>
            Get or set the end column of selection
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Events.BeforeSelectionChangeEventArgs.#ctor(unvell.ReoGrid.CellPosition,unvell.ReoGrid.CellPosition)">
            <summary>
            Create this argument by specified selection start and end position
            </summary>
            <param name="selectionStart">The start position of selection</param>
            <param name="selectionEnd">The end position of selection</param>
        </member>
        <member name="T:unvell.ReoGrid.Events.RangeEventArgs">
            <summary>
            Event raised on action was performed for range
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Events.RangeEventArgs.Range">
            <summary>
            Range of action performed
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Events.RangeEventArgs.#ctor(unvell.ReoGrid.RangePosition)">
            <summary>
            Create instance for RangeEventArgs with specified range.
            </summary>
            <param name="range">Range of action performed</param>
        </member>
        <member name="T:unvell.ReoGrid.Events.BeforeRangeOperationEventArgs">
            <summary>
            Event raised when operation to be performed to range, this class has
            the property 'IsCancelled' it used to notify grid control to abort
            current operation.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Events.BeforeRangeOperationEventArgs.IsCancelled">
            <summary>
            Get or set the flag that be used to notify the grid 
            whether to abort current operation
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Events.BeforeRangeOperationEventArgs.#ctor(unvell.ReoGrid.RangePosition)">
            <summary>
            Create instance of this class with specified range position
            </summary>
            <param name="range">Target range where performs the operation of this event</param>
        </member>
        <member name="T:unvell.ReoGrid.Events.CopyOrMoveRangeEventArgs">
            <summary>
            Event argument for copying or moving range by dragging mouse
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Events.CopyOrMoveRangeEventArgs.FromRange">
            <summary>
            Source range
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Events.CopyOrMoveRangeEventArgs.ToRange">
            <summary>
            Target range
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Events.CopyOrMoveRangeEventArgs.#ctor(unvell.ReoGrid.RangePosition,unvell.ReoGrid.RangePosition)">
            <summary>
            Create event argument instance
            </summary>
            <param name="fromRange">Source range</param>
            <param name="toRange">Target range</param>
        </member>
        <member name="T:unvell.ReoGrid.Events.BeforeCopyOrMoveRangeEventArgs">
            <summary>
            Event argument before copying or moving range by dragging mouse
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Events.BeforeCopyOrMoveRangeEventArgs.IsCancelled">
            <summary>
            Cancelled flag used to notify control that abort the copy or move operation
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Events.BeforeCopyOrMoveRangeEventArgs.#ctor(unvell.ReoGrid.RangePosition,unvell.ReoGrid.RangePosition)">
            <summary>
            Create event argument instance
            </summary>
            <param name="fromRange">Source range</param>
            <param name="toRange">Target range</param>
        </member>
        <member name="T:unvell.ReoGrid.Events.RangeOperationErrorEventArgs">
            <summary>
            Event raised when any errors happened during range operation
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Events.RangeOperationErrorEventArgs.Exception">
            <summary>
            The exception if happened during range operation
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Events.RangeOperationErrorEventArgs.#ctor(unvell.ReoGrid.RangePosition,System.Exception)">
            <summary>
            Construct instance with specified range
            </summary>
            <param name="range">Target range</param>
            <param name="ex">Additional exception associated to the range</param>
        </member>
        <member name="T:unvell.ReoGrid.Events.SettingsChangedEventArgs">
            <summary>
            Event raised when control's settings has been changed
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Events.SettingsChangedEventArgs.AddedSettings">
            <summary>
            The setting flags what have been added
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Events.SettingsChangedEventArgs.RemovedSettings">
            <summary>
            The setting flags what have been removed
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.Events.NamedRangeEventArgs">
            <summary>
            Common named range event argument
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Events.NamedRangeEventArgs.Name">
            <summary>
            Name of range
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Events.NamedRangeEventArgs.#ctor(unvell.ReoGrid.RangePosition,System.String)">
            <summary>
            Create named range event argument with specified parameters
            </summary>
            <param name="range">range as operation target</param>
            <param name="name">name of range</param>
        </member>
        <member name="T:unvell.ReoGrid.Events.NamedRangeAddedEventArgs">
            <summary>
            Event raised when named range has been added into spreadsheet
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Events.NamedRangeAddedEventArgs.NamedRange">
            <summary>
            Named range instance
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Events.NamedRangeAddedEventArgs.#ctor(unvell.ReoGrid.NamedRange)">
            <summary>
            Create event argument instance with named range instance
            </summary>
            <param name="namedRange">named range instance</param>
        </member>
        <member name="M:unvell.ReoGrid.Events.NamedRangeAddedEventArgs.#ctor(unvell.ReoGrid.RangePosition,System.String)">
            <summary>
            Create event argument instance with specified parameters
            </summary>
            <param name="range">spreadsheet range definition</param>
            <param name="name">the name of added range</param>
        </member>
        <member name="T:unvell.ReoGrid.Events.NamedRangeUndefinedEventArgs">
            <summary>
            Event raised when named range has been deleted from spreadsheet
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Events.NamedRangeUndefinedEventArgs.#ctor(unvell.ReoGrid.RangePosition,System.String)">
            <summary>
            Construct event argument with specified parameters
            </summary>
            <param name="range">spreadsheet range definition</param>
            <param name="name">the name of deleted range</param>
        </member>
        <member name="T:unvell.ReoGrid.Events.DrawingEventArgs">
            <summary>
            Represents common event argument of drawing objects.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Events.DrawingEventArgs.Context">
            <summary>
            Get the platform no-associated drawing context instance.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.Events.DrawingEventArgs.Bounds">
            <summary>
            Get the bounds of target rendering region.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.ReoGridException">
            <summary>
            Common exception of ReoGrid component
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridException.#ctor(System.String)">
            <summary>
            Create common exception with specified exception message
            </summary>
            <param name="msg">message used to describe the exception</param>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridException.#ctor(System.String,System.Exception)">
            <summary>
            Create common exception with specified message and inner exception
            </summary>
            <param name="msg">message used to describe the exception</param>
            <param name="innerException">inner exception</param>
        </member>
        <member name="T:unvell.ReoGrid.WorkbookLoadException">
            <summary>
            Exception is thrown when any errors happened during loading spreadsheet from a stream.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.WorkbookLoadException.#ctor(System.String)">
            <summary>
            Create exception instance
            </summary>
            <param name="msg">Additional message to describe the exception</param>
        </member>
        <member name="M:unvell.ReoGrid.WorkbookLoadException.#ctor(System.String,System.Exception)">
            <summary>
            Create exception instance
            </summary>
            <param name="msg">Addtional message to describe the exception</param>
            <param name="ex">Addtional original exception</param>
        </member>
        <member name="T:unvell.ReoGrid.WorkbookException">
            <summary>
            Common workbook exception
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.WorkbookException.#ctor(System.String)">
            <summary>
            Create common workbook exception with specified message
            </summary>
            <param name="msg">message to describe this exception</param>
        </member>
        <member name="M:unvell.ReoGrid.WorkbookException.#ctor(System.String,System.Exception)">
            <summary>
            Create common workbook exception with specified message
            </summary>
            <param name="msg">message to describe this exception</param>
            <param name="ex">inner exception</param>
        </member>
        <member name="T:unvell.ReoGrid.WorksheetException">
            <summary>
            Common worksheet exception
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.WorksheetException.Worksheet">
            <summary>
            worksheet of exception
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.WorksheetException.#ctor(System.String)">
            <summary>
            Create this exception with specified message
            </summary>
            <param name="msg">additional message to describe this exception</param>
        </member>
        <member name="M:unvell.ReoGrid.WorksheetException.#ctor(unvell.ReoGrid.Worksheet,System.String)">
            <summary>
            Create this exception with specified worksheet and message
            </summary>
            <param name="Worksheet">worksheet where exception happened</param>
            <param name="msg">additional message to describe this exception</param>
        </member>
        <member name="T:unvell.ReoGrid.FreezeUnsupportedException">
            <summary>
            Exception is thrown when current viewport controller does not support the freeze functionality.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.InvalidAddressException">
            <summary>
            Excepiton is thrown when an address is passed into a method which is described in the incorrect format, 
            or the address is out of valid range of spreadsheet.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.InvalidReferenceException">
            <summary>
            Exception is thrown when an reference as string neither is an valid address nor a registered name to locate a range.
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.ReferenceObjectNotAssociatedException">
            <summary>
            Exception will be thrown when a reference object lost its owner object.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.ReferenceObjectNotAssociatedException.#ctor(System.String)">
            <summary>
            Construct this exception with specified message
            </summary>
            <param name="msg">additional message to describe this exception</param>
        </member>
        <member name="T:unvell.ReoGrid.InvalidWorksheetNameException">
            <summary>
            Exception thrown when an invalid name specified for worksheet
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.InvalidWorksheetNameException.#ctor(unvell.ReoGrid.Worksheet,System.String)">
            <summary>
            Create this exception with specified worksheet and message
            </summary>
            <param name="worksheet">worksheet where exception happened</param>
            <param name="msg">additional message to describe this exception</param>
        </member>
        <member name="T:unvell.ReoGrid.WorksheetNotFoundException">
            <summary>
            Exception caused when specified worksheet cannot be found
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.WorksheetNotFoundException.#ctor(System.String)">
            <summary>
            Create exception with additional message.
            </summary>
            <param name="msg">Additional message to describe this exception.</param>
        </member>
        <member name="T:unvell.ReoGrid.ReoGridCellException">
            <summary>
            Cell operations exception 
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.ReoGridCellException.Pos">
            <summary>
            Position of the cell where the exception happens
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridCellException.#ctor(unvell.ReoGrid.CellPosition)">
            <summary>
            Create cell operations exception with specified cell position information
            </summary>
            <param name="pos">cell position information</param>
        </member>
        <member name="T:unvell.ReoGrid.RangeException">
            <summary>
            Common range exception
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.RangeException.Range">
            <summary>
            Get or set the range that is caused this exception
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.RangeException.#ctor(unvell.ReoGrid.RangePosition)">
            <summary>
            Create this exception by given range that is caused this exception happen
            </summary>
            <param name="range">Target range</param>
        </member>
        <member name="M:unvell.ReoGrid.RangeException.#ctor(unvell.ReoGrid.RangePosition,System.String)">
            <summary>
            Create this exception by given range and additional message
            </summary>
            <param name="msg">Additional message used to describe this exception</param>
            <param name="range">The range is caused this exception happen</param>
        </member>
        <member name="T:unvell.ReoGrid.RangeIntersectionException">
            <summary>
            The range to be processed intersected with another merged cell will
            cause this exception happen. Often caused when attempt to merged/move/change
            a range that contains any cells belonging to some merged cell.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.RangeIntersectionException.#ctor(unvell.ReoGrid.RangePosition)">
            <summary>
            Create instance of this exception with given range.
            </summary>
            <param name="range">Intersected another range</param>
        </member>
        <member name="M:unvell.ReoGrid.RangeIntersectionException.#ctor(unvell.ReoGrid.RangePosition,System.String)">
            <summary>
            Create instance of this exception with given range and additional message.
            </summary>
            <param name="range">Intersected another range.</param>
        </member>
        <member name="T:unvell.ReoGrid.InvalidRangeException">
            <summary>
            Event thrown when range is invalid to do specified operations
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.InvalidRangeException.#ctor(unvell.ReoGrid.RangePosition)">
            <summary>
            Create instance of this exception with given range
            </summary>
            <param name="range">Target range to do specified operations</param>
        </member>
        <member name="T:unvell.ReoGrid.RangeTooSmallException">
            <summary>
            Event thrown when range is too small to do specified operations
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.RangeTooSmallException.#ctor(unvell.ReoGrid.RangePosition)">
            <summary>
            Create instance of this exception with given range
            </summary>
            <param name="range">Target range to do specified operations</param>
        </member>
        <member name="T:unvell.ReoGrid.ReferenceRangeNotAssociatedException">
            <summary>
            This exception will be thrown when a reference range lost its reference 
            to the instance of grid control.
            
            ReferenceRange should be always created from grid control.
            If the grid control it associated has been disposed, the ReferenceRanges 
            should be also disposed and created again from the grid.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.ReferenceRangeNotAssociatedException.#ctor(unvell.ReoGrid.RangePosition)">
            <summary>
            Create exception instance with specified worksheet range.
            </summary>
            <param name="range">Range information.</param>
        </member>
        <member name="T:unvell.ReoGrid.NamedRangeNotFoundException">
            <summary>
            Event thrown when attempt to reference a non-existed named range
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.NamedRangeNotFoundException.Name">
            <summary>
            Get or set the name of range
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.NamedRangeNotFoundException.#ctor(System.String)">
            <summary>
            Create instance of this exception with additional message
            </summary>
            <param name="msg">Additional message used to describe this exception</param>
        </member>
        <member name="T:unvell.ReoGrid.NamedRangeAlreadyDefinedException">
            <summary>
            Event thrown when attempt to define a named range with existed name 
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.NamedRangeAlreadyDefinedException.#ctor">
            <summary>
            Create instance of this exception
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.NamedRangeAlreadyDefinedException.#ctor(System.String)">
            <summary>
            Create instance of this exception with additional message
            </summary>
            <param name="name">Name for range</param>
        </member>
        <member name="T:unvell.ReoGrid.InvalidNamedRangeException">
            <summary>
            Event thrown when attempt to define named range with an invalid name
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.InvalidNamedRangeException.Name">
            <summary>
            Get or set the name of range
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.InvalidNamedRangeException.#ctor(System.String)">
            <summary>
            Create this exception with given invalid name
            </summary>
            <param name="name">The name used to define named range</param>
        </member>
        <member name="T:unvell.ReoGrid.CircularReferenceException">
            <summary>
            This exception caused when a formula has a reference that causes a circular reference problem
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.CircularReferenceException.#ctor">
            <summary>
            Create the instance of this exception
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.OutlineException">
            <summary>
            Exception raised when any exception happen during outline operations
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.OutlineException.Start">
            <summary>
            Zero-based start position of row or column in the outline
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.OutlineException.Count">
            <summary>
            Number of rows or columns in the outline
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.OutlineException.End">
            <summary>
            Zero-based end position of row or column in the outline
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.OutlineException.#ctor(System.String)">
            <summary>
            Create the instance of exception by additional message
            </summary>
            <param name="msg">Additional message to describe this exception</param>
        </member>
        <member name="T:unvell.ReoGrid.OutlineIntersectedException">
            <summary>
            Exception thrown when attempt to create an outline that is intersected with other existed outlines. 
            The outlines cannot be intersected each other, they can only be either contained by each other, 
            or be added at different positions.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.OutlineIntersectedException.#ctor">
            <summary>
            Create the instance of exception
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.OutlineAlreadyDefinedException">
            <summary>
            Exception thrown when adding an outline at specified position, but another outline has already exist at same position.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.OutlineAlreadyDefinedException.#ctor">
            <summary>
            Create the instance of exception
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.OutlineNotFoundException">
            <summary>
            Exception thrown when performing an action to an outline but the outline cannot be found at specified position.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.OutlineNotFoundException.#ctor(System.Int32,System.String)">
            <summary>
            Create the instance of exception
            </summary>
            <param name="start"></param>
            <param name="msg"></param>
        </member>
        <member name="T:unvell.ReoGrid.OutlineOutOfRangeException">
            <summary>
            Exception thrown when adding an outline at specified position, but the position is out of available range of worksheet.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.OutlineOutOfRangeException.#ctor(System.Int32,System.Int32,System.String)">
            <summary>
            Create instance of exception.
            </summary>
            <param name="start">Start position of outline to be added.</param>
            <param name="count">Number of rows or columns of outline to be added.</param>
            <param name="msg">Additional message to describe this exception.</param>
        </member>
        <member name="T:unvell.ReoGrid.OutlineTooMuchException">
            <summary>
            This exception is thrown when there is already maximum available outlines added into
            grid control. ReoGrid supports maximum 9 outlines in either row or column direction.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.OutlineTooMuchException.#ctor">
            <summary>
            Create the instance of exception
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.OperationOnReadonlyCellException">
            <summary>
            Exception happens when operation applied on a range that contains read-only cells.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.OperationOnReadonlyCellException.#ctor(System.String)">
            <summary>
            Create exception with additional message.
            </summary>
            <param name="msg">The additional message to describe this exception.</param>
        </member>
        <member name="T:unvell.ReoGrid.CellDataReadonlyException">
            <summary>
            Exception will be thrown when attempt modify the data of cell which is set to readonly.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.CellDataReadonlyException.CellPos">
            <summary>
            Get cell position. (zero-based number of row and column)
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.CellDataReadonlyException.#ctor(unvell.ReoGrid.CellPosition)">
            <summary>
            Create exception with specified cell position.
            </summary>
            <param name="pos">Cell position on worksheet.</param>
        </member>
        <member name="T:unvell.ReoGrid.RangeContainsReadonlyCellsException">
            <summary>
            Exception happens when operation applied on a range that contains read-only cells.
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.RangeContainsReadonlyCellsException.Range">
            <summary>
            Range that operation applied on.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.RangeContainsReadonlyCellsException.#ctor(unvell.ReoGrid.RangePosition,System.String)">
            <summary>
            Create exception with additional message.
            </summary>
            <param name="msg">The additional message to describe this exception.</param>
        </member>
        <member name="T:unvell.ReoGrid.CannotCreateCellBodyException">
            <summary>
            Exception will be thrown when the cell body cannot be created for a cell automatically.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.CannotCreateCellBodyException.#ctor(System.String)">
            <summary>
            Create exception with additional message.
            </summary>
            <param name="msg">Additional message to describe this exception.</param>
        </member>
        <member name="M:unvell.ReoGrid.CannotCreateCellBodyException.#ctor(System.String,System.Exception)">
            <summary>
            Create exception with additional message and inner exception.
            </summary>
            <param name="msg">Additional message to describe this exception.</param>
            <param name="inner">Inner exception that happens in dependency method calls.</param>
        </member>
        <member name="T:unvell.ReoGrid.ReoGridPrintException">
            <summary>
            Common print exception
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridPrintException.#ctor(System.String)">
            <summary>
            Create common print exception with specified message
            </summary>
            <param name="msg">message of exception</param>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridPrintException.#ctor(System.String,System.Exception)">
            <summary>
            Create common print exception with specified message and previous exception
            </summary>
            <param name="msg">message of exception</param>
            <param name="innerEx">previous or inner exception</param>
        </member>
        <member name="T:unvell.ReoGrid.NoPrintableContentException">
            <summary>
            Exception cause when print command received, but there is no valid content
            to be printed out from the spreadsheet. Check whether the PrintRange set to
            a region where not contain any valid cells if this exception happened.
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.NoPrintableContentException.#ctor">
            <summary>
            Create no printable content exception
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.NoPrintableContentException.#ctor(System.String)">
            <summary>
            Create no printable cotent exception with a message
            </summary>
            <param name="msg">message of exception</param>
        </member>
        <member name="T:unvell.ReoGrid.PageBreakNotFoundException">
            <summary>
            Exception cause when specified page break cannot be found
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.PageBreakNotFoundException.Index">
            <summary>
            Zero-based number of index to find specified page break
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.PageBreakNotFoundException.#ctor(System.Int32)">
            <summary>
            Create excpetion with specified number of page break
            </summary>
            <param name="index">zero-based number of page break that cannot be found</param>
        </member>
        <member name="M:unvell.ReoGrid.PageBreakNotFoundException.#ctor(System.String,System.Int32)">
            <summary>
            Create exception with specified message and target index
            </summary>
            <param name="msg">message of exception</param>
            <param name="index">zero-based number of page break that cannot be found</param>
        </member>
        <member name="T:unvell.ReoGrid.PageBreakCannotRemoveException">
            <summary>
            Exception for page-break index cannot be removed
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.PageBreakCannotRemoveException.Index">
            <summary>
            Get or set page-break index
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.PageBreakCannotRemoveException.#ctor(System.Int32)">
            <summary>
            Create exception instance
            </summary>
            <param name="index">Number of page-break index</param>
        </member>
        <member name="M:unvell.ReoGrid.PageBreakCannotRemoveException.#ctor(System.String,System.Int32)">
            <summary>
            Create exception instance
            </summary>
            <param name="msg">Addtional message to describe the message</param>
            <param name="index">Page-break index to be removed</param>
        </member>
        <member name="T:unvell.ReoGrid.ReoGridIOException">
            <summary>
            ReoGrid common I/O exception
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridIOException.#ctor(System.String)">
            <summary>
            Create exception instance by specified message
            </summary>
            <param name="msg">Additional message to describe this exception</param>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridIOException.#ctor(System.String,System.Exception)">
            <summary>
            Create exception instance by specified message and original exception object
            </summary>
            <param name="msg">Additional message to describe this exception</param>
            <param name="innerEx">Original exception happened inside loading process</param>
        </member>
        <member name="T:unvell.ReoGrid.ReoGridLoadException">
            <summary>
            Loading exception
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridLoadException.#ctor(System.String)">
            <summary>
            Create this exception with specified message
            </summary>
            <param name="msg">Addtional message to describe the exception</param>
        </member>
        <member name="M:unvell.ReoGrid.ReoGridLoadException.#ctor(System.String,System.Exception)">
            <summary>
            Create this exception with specified message
            </summary>
            <param name="msg">Addtional message to describe the exception</param>
            <param name="innerEx">Inner exception where original exception happened</param>
        </member>
        <member name="T:unvell.ReoGrid.FileFormatNotSupportException">
            <summary>
            File format not supported exception
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.FileFormatNotSupportException.#ctor">
            <summary>
            Create exception instance
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.FileFormatNotSupportException.#ctor(System.String)">
            <summary>
            Create exception instance by specified message
            </summary>
            <param name="msg">Additional message to describe this exception</param>
        </member>
        <member name="M:unvell.ReoGrid.FileFormatNotSupportException.#ctor(System.String,System.Exception)">
            <summary>
            Create exception instance by specified message
            </summary>
            <param name="msg">Additional message to describe this exception</param>
            <param name="innerEx">Inner exception where original exception happened</param>
        </member>
        <member name="M:unvell.ReoGrid.GenericExtends.Has(unvell.ReoGrid.PlainStyleFlag,unvell.ReoGrid.PlainStyleFlag)">
            <summary>
            Check whether the style flags contains the specified flags
            </summary>
            <param name="flag">flags container to be checked from</param>
            <param name="target">target flags to be checked to</param>
            <returns>true if style flags contains the specified flags</returns>
        </member>
        <member name="M:unvell.ReoGrid.GenericExtends.HasAny(unvell.ReoGrid.PlainStyleFlag,unvell.ReoGrid.PlainStyleFlag)">
            <summary>
            Check whether the style flags contains the any one of specified flags
            </summary>
            <param name="flag">flags container to be checked from</param>
            <param name="target">target flags to be checked to</param>
            <returns>true if style flags contains the any one of specified flags</returns>
        </member>
        <member name="M:unvell.ReoGrid.GenericExtends.Set(unvell.ReoGrid.PlainStyleFlag,unvell.ReoGrid.PlainStyleFlag)">
            <summary>
            Set style flags
            </summary>
            <param name="flag">flags container to save the value after set</param>
            <param name="target">target flags to be set</param>
        </member>
        <member name="M:unvell.ReoGrid.GenericExtends.Unset(unvell.ReoGrid.PlainStyleFlag,unvell.ReoGrid.PlainStyleFlag)">
            <summary>
            Remove flags from style flags
            </summary>
            <param name="flag">flags container to be removed from</param>
            <param name="target">target flags to be removed</param>
        </member>
        <member name="M:unvell.ReoGrid.GenericExtends.Has(unvell.ReoGrid.BorderPositions,unvell.ReoGrid.BorderPositions)">
            <summary>
            Check whether specified border position contains another position
            </summary>
            <param name="pos">border position container to be checked from</param>
            <param name="target">target border position to be checked</param>
            <returns>true if border position flags contains the specified flags</returns>
        </member>
        <member name="M:unvell.ReoGrid.GenericExtends.HasAny(unvell.ReoGrid.BorderPositions,unvell.ReoGrid.BorderPositions)">
            <summary>
            Check whether the border position contains any one of specified positions
            </summary>
            <param name="pos">border position container to be checked from</param>
            <param name="target">target border position to be checked</param>
            <returns>true if border position flags contains the specified flags</returns>
        </member>
        <member name="M:unvell.ReoGrid.GenericExtends.Has(unvell.ReoGrid.WorksheetSettings,unvell.ReoGrid.WorksheetSettings)">
            <summary>
            Check whether the settings flags contains specified setting flags
            </summary>
            <param name="settings">the setting flags container to be checked from</param>
            <param name="target">the target setting flags to be checked</param>
            <returns>true if the settings flags contains specified setting flags</returns>
        </member>
        <member name="M:unvell.ReoGrid.GenericExtends.HasAny(unvell.ReoGrid.WorksheetSettings,unvell.ReoGrid.WorksheetSettings)">
            <summary>
            Check whether the settings flags contains any one of specified setting flags
            </summary>
            <param name="settings">the setting flags container to be checked from</param>
            <param name="target">the target setting flags to be checked</param>
            <returns>true if the settings flags contains any one of setting flags</returns>
        </member>
        <member name="M:unvell.ReoGrid.GenericExtends.Add(unvell.ReoGrid.WorksheetSettings,unvell.ReoGrid.WorksheetSettings)">
            <summary>
            Set setting flags
            </summary>
            <param name="settings">setting flags used to save the specified flags</param>
            <param name="target">target flags to be set</param>
            <returns>changed setting flags</returns>
        </member>
        <member name="M:unvell.ReoGrid.GenericExtends.Remove(unvell.ReoGrid.WorksheetSettings,unvell.ReoGrid.WorksheetSettings)">
            <summary>
            Remove setting flags
            </summary>
            <param name="settings">setting flags used to remove the specified flags</param>
            <param name="target">target flags to be removed</param>
            <returns>changed setting flags</returns>
        </member>
        <member name="M:unvell.ReoGrid.GenericExtends.Has(unvell.ReoGrid.WorkbookSettings,unvell.ReoGrid.WorkbookSettings)">
            <summary>
            Check whether the settings flags contains specified setting flags
            </summary>
            <param name="settings">the setting flags container to be checked from</param>
            <param name="target">the target setting flags to be checked</param>
            <returns>true if the settings flags contains specified setting flags</returns>
        </member>
        <member name="M:unvell.ReoGrid.GenericExtends.HasAny(unvell.ReoGrid.WorkbookSettings,unvell.ReoGrid.WorkbookSettings)">
            <summary>
            Check whether the settings flags contains any one of specified setting flags
            </summary>
            <param name="settings">the setting flags container to be checked from</param>
            <param name="target">the target setting flags to be checked</param>
            <returns>true if the settings flags contains any one of setting flags</returns>
        </member>
        <member name="M:unvell.ReoGrid.GenericExtends.Add(unvell.ReoGrid.WorkbookSettings,unvell.ReoGrid.WorkbookSettings)">
            <summary>
            Set setting flags
            </summary>
            <param name="settings">setting flags used to save the specified flags</param>
            <param name="target">target flags to be set</param>
            <returns>changed setting flags</returns>
        </member>
        <member name="M:unvell.ReoGrid.GenericExtends.Remove(unvell.ReoGrid.WorkbookSettings,unvell.ReoGrid.WorkbookSettings)">
            <summary>
            Remove setting flags
            </summary>
            <param name="settings">setting flags used to remove the specified flags</param>
            <param name="target">target flags to be removed</param>
            <returns>changed setting flags</returns>
        </member>
        <member name="M:unvell.ReoGrid.GenericExtends.DictionaryEquals``2(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IDictionary{``0,``1})">
            <summary>
            Comparing 2 Generic Dictionary Instances
            quoted from LukeH
            http://stackoverflow.com/questions/3928822/comparing-2-dictionarystring-string-instances
            </summary>
        </member>
        <member name="P:unvell.ReoGrid.WPF.SheetTabControl.AllowDragToMove">
            <summary>
            Determine whether or not allow to move tab by dragging mouse
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.RGUtility.GetAlphaChar(System.Int64)">
            <summary>
            Get alphabet of number (eg. A is 1 and 30 is AD)
            </summary>
            <param name="a">number to be converted</param>
            <returns>alphabet of number</returns>
        </member>
        <member name="M:unvell.ReoGrid.RGUtility.GetNumberOfChar(System.String)">
            <summary>
            Get number of alphabet from string (eg. A is 1 and AD is 30)
            </summary>
            <param name="address">alphabet to be converted</param>
            <returns>number of alphabet</returns>
        </member>
        <member name="M:unvell.ReoGrid.RGUtility.IsValidAddress(System.String)">
            <summary>
            Check whether specified string is an valid address to locate cell or range 
            </summary>
            <param name="address">address for cell or range</param>
        </member>
        <member name="M:unvell.ReoGrid.RGUtility.IsValidName(System.String)">
            <summary>
            Chck whether specified string is valid name to define a range
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:unvell.ReoGrid.RGUtility.ParseTabbedString(System.String)">
            <summary>
            Parse tabbed string into regular array
            </summary>
            <param name="str">string to be parsed</param>
            <returns>parsed regular array</returns>
        </member>
        <member name="M:unvell.ReoGrid.RGUtility.ToAddress(System.Int32,System.Int32,System.Int32)">
            <summary>
            Convert position or range into address string
            </summary>
            <param name="row">Zero-based index number of row</param>
            <param name="col">Zero-based index number of column</param>
            <param name="absNum">Determine that which R1C1 format should be used.<br/>
            <ul>
            <li>1: [Absolute Row][Absolute Col] R1C1</li>
            <li>2: [Absolute Row][Relative Col] R1C[1]</li>
            <li>3: [Relative Row][Absolute Col] R[1]C1</li>
            <li>4: [Relative Row][Relative Col] R[1]C[1]</li>
            </ul>
            </param>
            <returns>position or range in address string</returns>
        </member>
        <member name="M:unvell.ReoGrid.RGUtility.ToAddress(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Convert position or range into address string
            </summary>
            <param name="row">Zero-based index number of row</param>
            <param name="col">Zero-based index number of column</param>
            <param name="a1style">true to use A1 style; false use the R1C1 style</param>
            <returns>position or range in address string</returns>
        </member>
        <member name="M:unvell.ReoGrid.RGUtility.ToAddress(System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Convert position or range into address string
            </summary>
            <param name="row">Zero-based index number of row</param>
            <param name="col">Zero-based index number of column</param>
            <param name="absNum">Determine that which R1C1 format should be used.<br/>
            <ul>
            <li>1: [Absolute Row][Absolute Col] R1C1</li>
            <li>2: [Absolute Row][Relative Col] R1C[1]</li>
            <li>3: [Relative Row][Absolute Col] R[1]C1</li>
            <li>4: [Relative Row][Relative Col] R[1]C[1]</li>
            </ul>
            </param>
            <param name="a1style">true to use A1 style; false use the R1C1 style</param>
            <returns>position or range in address string</returns>
        </member>
        <member name="M:unvell.ReoGrid.RGUtility.ToAddress(System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Convert position or range into address string
            </summary>
            <param name="row">Zero-based index number of row</param>
            <param name="col">Zero-based index number of column</param>
            <param name="rows">Zero-based number of rows</param>
            <param name="cols">Zero-based number of columns</param>
            <param name="a1style">true to use A1 style; false use the R1C1 style</param>
            <returns>position or range in address string</returns>
        </member>
        <member name="M:unvell.ReoGrid.RGUtility.ToAddress(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Convert position or range into address stringConvert position or range into address string
            </summary>
            <param name="row">Zero-based index number of row</param>
            <param name="col">Zero-based index number of column</param>
            <param name="rows">Zero-based number of rows</param>
            <param name="cols">Zero-based number of columns</param>
            <param name="absNum">Determine that which R1C1 format should be used.<br/>
            <ul>
            <li>1: [Absolute Row][Absolute Col] R1C1</li>
            <li>2: [Absolute Row][Relative Col] R1C[1]</li>
            <li>3: [Relative Row][Absolute Col] R[1]C1</li>
            <li>4: [Relative Row][Relative Col] R[1]C[1]</li>
            </ul>
            </param>
            <param name="a1style">true to use A1 style; false use the R1C1 style</param>
            <returns>position or range in address string</returns>
        </member>
        <member name="M:unvell.ReoGrid.RGUtility.ToSingleAddressIfPossible(unvell.ReoGrid.Worksheet,unvell.ReoGrid.RangePosition)">
            <summary>
            Convert range address into cell address style if the range is a merged cell (A1:A1 => A1)
            </summary>
            <param name="sheet">Worksheet instance used to check whther or not the range is a merged cell</param>
            <param name="range">Range to be converted</param>
            <returns>Single cell address if convert is successful; otherwise return the range address</returns>
        </member>
        <member name="T:unvell.ReoGrid.Script.RSUtility">
            <summary>
            Utility for ReoGrid script extension
            </summary>
        </member>
        <member name="M:unvell.ReoGrid.Script.RSUtility.GetRangeFromValue(unvell.ReoGrid.Worksheet,System.Object)">
            <summary>
            Get range information from script value
            </summary>
            <param name="sheet">worksheet instance</param>
            <param name="arg">script object to be converted</param>
            <returns></returns>
        </member>
        <member name="M:unvell.ReoGrid.Script.RSUtility.GetRangeFromArgs(unvell.ReoGrid.Worksheet,System.Object[])">
            <summary>
            Get range information from script value
            </summary>
            <param name="sheet">worksheet instance</param>
            <param name="args">script value to be converted</param>
            <returns></returns>
        </member>
        <member name="T:unvell.ReoGrid.ReoGridSettings">
            <summary>
            Obsoleted control settings, changed to WorkbookSettings and WorksheetSettings
            </summary>
        </member>
        <member name="T:unvell.ReoGrid.WorkbookSettings">
            <summary>
            Workbook Control Settings
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.WorkbookSettings.None">
            <summary>
            None
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.WorkbookSettings.Default">
            <summary>
            Default Settings
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.WorkbookSettings.Behaivor_Default">
            <summary>
            Default behaivor settings
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.WorkbookSettings.View_Default">
            <summary>
            Default View Settings 
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.WorkbookSettings.View_ShowSheetTabControl">
            <summary>
            Determine whether or not to show sheet tab control
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.WorkbookSettings.View_ShowScrolls">
            <summary>
            Determine whether or not to show horizontal and vertical scroll bars
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.WorkbookSettings.View_ShowHorScroll">
            <summary>
            Determine whether or not to show horizontal scroll bar
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.WorkbookSettings.View_ShowVerScroll">
            <summary>
            Determine whether or not to show vertical scroll bar
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.WorkbookSettings.Script_Default">
            <summary>
            Default settings of script
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.WorkbookSettings.Script_AutoRunOnload">
            <summary>
            Whether to run script if grid loaded from file which contains script
            </summary>
        </member>
        <member name="F:unvell.ReoGrid.WorkbookSettings.Script_PromptBeforeAutoRun">
            <summary>
            Confirm to user that whether allowed to run script if the script is loaded from a file
            </summary>
        </member>
        <member name="P:unvell.Common.ActionManager.UndoStack">
            <summary>
            Get collection of undo action list
            </summary>
        </member>
        <member name="P:unvell.Common.ActionManager.RedoStack">
            <summary>
            Get collection of redo action list
            </summary>
        </member>
        <member name="M:unvell.Common.ActionManager.Do(unvell.Common.IAction,System.Boolean,System.Boolean)">
            <summary>
            Do specified action.
            </summary>
            <param name="action">Action to be performed</param>
            <param name="perform">True to perform immediately, false to add into stack only</param>
            <param name="isCanUndo">Specifies that whether the action can be undone, 
            sometimes an action might not necessary to be undone even it implements the 
            IUndoable interface.</param>
        </member>
        <member name="M:unvell.Common.ActionManager.Reset">
            <summary>
            Clear current action stack.
            </summary>
        </member>
        <member name="T:unvell.Common.ActionEventArgs">
            <summary>
            Action event argument.
            </summary>
        </member>
        <member name="P:unvell.Common.ActionEventArgs.Action">
            <summary>
            The action is currently performing.
            </summary>
        </member>
        <member name="P:unvell.Common.ActionEventArgs.Behavior">
            <summary>
            The behavior of current action performing. (one of do/undo/redo)
            </summary>
        </member>
        <member name="P:unvell.Common.ActionEventArgs.Cancel">
            <summary>
            Get or set the Cancel flag to decide whether or not to cancel this operation.
            </summary>
        </member>
        <member name="M:unvell.Common.ActionEventArgs.#ctor(unvell.Common.IAction,unvell.Common.ActionBehavior)">
            <summary>
            Construct an argument with specified action and behavior flag.
            </summary>
            <param name="action">action is currently performing.</param>
            <param name="behavior">behavior flag of current operation.</param>
        </member>
        <member name="T:unvell.Common.ActionBehavior">
            <summary>
            Behavior flag for argument of ActionPerformmed event.
            </summary>
        </member>
        <member name="F:unvell.Common.ActionBehavior.Do">
            <summary>
            Do action (action is firstly done)
            </summary>
        </member>
        <member name="F:unvell.Common.ActionBehavior.Redo">
            <summary>
            Redo action (action is redone by ActionManager)
            </summary>
        </member>
        <member name="F:unvell.Common.ActionBehavior.Undo">
            <summary>
            Undo action (action is undone by ActionManager)
            </summary>
        </member>
        <member name="T:unvell.Common.IAction">
            <summary>
            Represents action interface.
            </summary>
        </member>
        <member name="M:unvell.Common.IAction.Do">
            <summary>
            Do this action.
            </summary>
        </member>
        <member name="M:unvell.Common.IAction.GetName">
            <summary>
            Get the friendly name of this action.
            </summary>
            <returns>Get friendly name of action.</returns>
        </member>
        <member name="T:unvell.Common.IUndoableAction">
            <summary>
            Undoable action interface.
            </summary>
        </member>
        <member name="M:unvell.Common.IUndoableAction.Undo">
            <summary>
            Undo this action.
            </summary>
        </member>
        <member name="M:unvell.Common.IUndoableAction.Redo">
            <summary>
            Redo this action.
            </summary>
        </member>
        <member name="T:unvell.Common.ActionGroup">
            <summary>
            Action group is used to perform several actions together during one time operation,
            For example there is two actions:
            <ol>
            <li>expend spreadsheet action</li>
            <li>copy data action</li>
            </ol>
            Sometimes it is necessary to perform these two actions together, they are should undo 
            together, in this case, create an ActionGroup and add them into the group, then invoke
            the 'DoAction' method of 'ActionManager' by passing this action group object.
            </summary>
        </member>
        <member name="P:unvell.Common.ActionGroup.Actions">
            <summary>
            Action list stored in this group.
            </summary>
        </member>
        <member name="M:unvell.Common.ActionGroup.#ctor(System.String,System.Collections.Generic.List{unvell.Common.IAction})">
            <summary>
            Construct action group by specified name, and the collection of action to perform together.
            </summary>
            <param name="name">Friendly name of this group.</param>
            <param name="actions">Collection of action to be performed.</param>
        </member>
        <member name="M:unvell.Common.ActionGroup.#ctor(System.String)">
            <summary>
            Construct action group by specified name, and the collection of action to perform together.
            </summary>
            <param name="name">Friendly name of this group.</param>
        </member>
        <member name="M:unvell.Common.ActionGroup.Do">
            <summary>
            Do this action group. (Do all actions that are contained in this group)
            </summary>
        </member>
        <member name="M:unvell.Common.ActionGroup.Undo">
            <summary>
            Undo this action group. (Undo all actions that are contained in this group)
            </summary>
        </member>
        <member name="M:unvell.Common.ActionGroup.Redo">
            <summary>
            Redo this action group. (Redo all actions that are contained in this group)
            </summary>
        </member>
        <member name="M:unvell.Common.ActionGroup.GetName">
            <summary>
            Get the friendly name of this action group.
            </summary>
            <returns>Friendly name of this action.</returns>
        </member>
        <member name="M:unvell.Common.ActionGroup.ToString">
            <summary>
            Convert this action group object into string for displaying.
            </summary>
            <returns></returns>
        </member>
        <member name="T:unvell.Common.ActionException">
            <summary>
            Represents action exception. This exception will be thrown when errors happened during do/undo/redo an action.
            </summary>
        </member>
        <member name="M:unvell.Common.ActionException.#ctor(System.String)">
            <summary>
            Construct an action exception with specified message.
            </summary>
            <param name="msg">Message to describe this exception.</param>
        </member>
        <member name="M:unvell.Common.ActionException.#ctor(unvell.Common.IAction,System.String)">
            <summary>
            Construct an action exception with specified action and message.
            </summary>
            <param name="action">Action which causes this exception when do/undo/redo.</param>
            <param name="msg">Message to describe this exception.</param>
        </member>
        <member name="T:unvell.Common.LogLevel">
            <summary>
            Log level
            </summary>
        </member>
        <member name="F:unvell.Common.LogLevel.All">
            <summary>
            All logs
            </summary>
        </member>
        <member name="F:unvell.Common.LogLevel.Trace">
            <summary>
            Trace log
            </summary>
        </member>
        <member name="F:unvell.Common.LogLevel.Debug">
            <summary>
            Debug log
            </summary>
        </member>
        <member name="F:unvell.Common.LogLevel.Info">
            <summary>
            Info log
            </summary>
        </member>
        <member name="F:unvell.Common.LogLevel.Warn">
            <summary>
            Warning log
            </summary>
        </member>
        <member name="F:unvell.Common.LogLevel.Error">
            <summary>
            Error log
            </summary>
        </member>
        <member name="F:unvell.Common.LogLevel.Fatal">
            <summary>
            Fatal error log
            </summary>
        </member>
        <member name="T:unvell.Common.ILogWritter">
            <summary>
            Log writter
            </summary>
        </member>
        <member name="M:unvell.Common.ILogWritter.Log(System.String,System.String)">
            <summary>
            Output log message
            </summary>
            <param name="cat">category name</param>
            <param name="msg">message to be output</param>
        </member>
        <member name="T:unvell.Common.Logger">
            <summary>
            Common logger component
            </summary>
        </member>
        <member name="M:unvell.Common.Logger.RegisterWritter(unvell.Common.ILogWritter)">
            <summary>
            Add an output target
            </summary>
            <param name="writter">writer to be registered</param>
        </member>
        <member name="M:unvell.Common.Logger.Off">
            <summary>
            Turn off log output
            </summary>
        </member>
        <member name="M:unvell.Common.Logger.On">
            <summary>
            Turn on log output
            </summary>
        </member>
        <member name="M:unvell.Common.Logger.Log(System.String,System.String,System.Object[])">
            <summary>
            Output message to log writters
            </summary>
            <param name="cat">category name</param>
            <param name="format">format of log message</param>
            <param name="args">arguments for format</param>
        </member>
        <member name="M:unvell.Common.Logger.Log(System.String,System.String)">
            <summary>
            Output message to log writters
            </summary>
            <param name="cat">category name</param>
            <param name="msg">log message to be output</param>
        </member>
        <member name="M:unvell.Common.Logger.WriteLog(System.String,System.String)">
            <summary>
            Output message to log writters
            </summary>
            <param name="cat">category name</param>
            <param name="msg">log message to be output</param>
        </member>
        <member name="M:unvell.Common.TextFormatHelper.EncodeBool(System.Boolean,System.Boolean)">
            <summary>
            Encode a boolean value into string and compare to the default value, 
            if the value is the same as default value then return null (noting output to xml).
            </summary>
            <param name="p">boolean value to be encoded</param>
            <param name="def">default boolean value used to compare whether the value is same as default</param>
            <returns>encoded string of boolean value</returns>
        </member>
        <member name="T:unvell.Common.Toolkit">
            <summary>
            Common Toolkit
            </summary>
        </member>
        <member name="M:unvell.Common.Toolkit.IsKeyDown(unvell.Common.Win32Lib.Win32.VKey)">
            <summary>
            Check whether or not the specified key is pressed.
            </summary>
            <param name="vkey">Windows virtual key.</param>
            <returns>true if pressed, otherwise false if not pressed.</returns>
        </member>
        <member name="F:unvell.Common.Toolkit.FontSizeList">
            <summary>
            Default font size list.
            </summary>
        </member>
        <member name="T:unvell.Common.Win32Lib.Win32.WMessages">
            <summary>
            Virtual Messages
            </summary>
        </member>
        <member name="M:unvell.Common.Win32Lib.Win32.GetParent(System.IntPtr)">
            <summary>
            Retrieves a handle to the specified window's parent or owner.
            To retrieve a handle to a specified ancestor, use the GetAncestor function.
            </summary>
            <param name="hwnd">A handle to the window whose parent window handle is to be retrieved.</param>
            <returns>If the window is a child window, the return value is a handle to the parent window. 
            If the window is a top-level window with the WS_POPUP style, the return value is a handle to the owner window.
            If the function fails, the return value is NULL. To get extended error information, call GetLastError.
            This function typically fails for one of the following reasons:
            <ul><li>The window is a top-level window that is unowned or does not have the WS_POPUP style.</li>
            <li>The owner window has WS_POPUP style.</li></ul></returns>
            <seealso cref="M:unvell.Common.Win32Lib.Win32.GetAncestor(System.IntPtr,System.UInt32)"/>
        </member>
        <member name="M:unvell.Common.Win32Lib.Win32.GetAncestor(System.IntPtr,System.UInt32)">
            <summary>
            Retrieves the handle to the ancestor of the specified window.
            </summary>
            <param name="hwnd">A handle to the window whose ancestor is to be retrieved. 
            If this parameter is the desktop window, the function returns NULL.</param>
            <param name="gaFlags">The ancestor to be retrieved. This parameter can be one of the GAFlag enum.</param>
            <returns></returns>
        </member>
        <member name="M:unvell.Common.Win32Lib.Win32.GetWindow(System.IntPtr,System.UInt32)">
            <summary>
            Retrieves a handle to a window that has the specified relationship (Z-Order or owner) to the specified window.
            </summary>
            <param name="hwnd">A handle to a window.
            The window handle retrieved is relative to this window, based on the value of the uCmd parameter.</param>
            <param name="wCMD">The relationship between the specified window and the window whose handle is to be retrieved.
            This parameter can be one of the following values.</param>
            <returns></returns>
        </member>
        <member name="F:unvell.Common.Win32Lib.Win32.ShowWindowCmd.SW_HIDE">
            <summary>
            Hides the window and activates another window.
            </summary>
        </member>
        <member name="F:unvell.Common.Win32Lib.Win32.ShowWindowCmd.SW_MAXIMIZE">
            <summary>
            Maximizes the specified window.
            </summary>
        </member>
        <member name="F:unvell.Common.Win32Lib.Win32.ShowWindowCmd.SW_MINIMIZE">
            <summary>
            Minimizes the specified window and activates the next top-level window in the z-order.
            </summary>
        </member>
        <member name="F:unvell.Common.Win32Lib.Win32.ShowWindowCmd.SW_RESTORE">
            <summary>
            Activates and displays the window. If the window is minimized or maximized, the system restores it to its original size and position.
            An application should specify this flag when restoring a minimized window.
            </summary>
        </member>
        <member name="F:unvell.Common.Win32Lib.Win32.ShowWindowCmd.SW_SHOW">
            <summary>
            Activates the window and displays it in its current size and position.
            </summary>
        </member>
        <member name="F:unvell.Common.Win32Lib.Win32.ShowWindowCmd.SW_SHOWMAXIMIZED">
            <summary>
            Activates the window and displays it as a maximized window.
            </summary>
        </member>
        <member name="F:unvell.Common.Win32Lib.Win32.ShowWindowCmd.SW_SHOWMINIMIZED">
            <summary>
            Activates the window and displays it as a minimized window.
            </summary>
        </member>
        <member name="F:unvell.Common.Win32Lib.Win32.ShowWindowCmd.SW_SHOWMINNOACTIVE">
            <summary>
            Displays the window as a minimized window.
            This value is similar to SW_SHOWMINIMIZED, except the window is not activated.
            </summary>
        </member>
        <member name="F:unvell.Common.Win32Lib.Win32.ShowWindowCmd.SW_SHOWNA">
            <summary>
            Displays the window in its current size and position.
            This value is similar to SW_SHOW, except the window is not activated.
            </summary>
        </member>
        <member name="F:unvell.Common.Win32Lib.Win32.ShowWindowCmd.SW_SHOWNOACTIVATE">
            <summary>
            Displays a window in its most recent size and position.
            This value is similar to SW_SHOWNORMAL, except the window is not activated.
            </summary>
        </member>
        <member name="F:unvell.Common.Win32Lib.Win32.ShowWindowCmd.SW_SHOWNORMAL">
            <summary>
            Activates and displays a window. If the window is minimized or maximized, 
            the system restores it to its original size and position. 
            An application should specify this flag when displaying the window for the first time.
            </summary>
        </member>
        <member name="M:unvell.Common.Win32Lib.Win32.GetWindowPlacement(System.IntPtr,unvell.Common.Win32Lib.Win32.WindowPlacement@)">
            <summary>
            Retrieves the show state and the restored, minimized, and maximized positions of the specified window.
            </summary>
            <param name="hWnd">A handle to the window.</param>
            <param name="lpwndpl">A pointer to the WINDOWPLACEMENT structure that receives the show state and position information. 
            Before calling GetWindowPlacement, set the length member to sizeof(WINDOWPLACEMENT).
            GetWindowPlacement fails if lpwndpl-> length is not set correctly.</param>
            <returns>If the function succeeds, the return value is true.
            If the function fails, the return value is false. To get extended error information, call GetLastError.</returns>
        </member>
        <member name="T:unvell.Common.Win32Lib.Win32.WindowPlacement">
            <summary>
            Contains information about the placement of a window on the screen.
            </summary>
        </member>
        <member name="F:unvell.Common.Win32Lib.Win32.WindowPlacement.length">
            <summary>
            The length of the structure, in bytes. Before calling the GetWindowPlacement or SetWindowPlacement functions, set this member to sizeof(WINDOWPLACEMENT).
            GetWindowPlacement and SetWindowPlacement fail if this member is not set correctly.
            </summary>
        </member>
        <member name="F:unvell.Common.Win32Lib.Win32.WindowPlacement.flags">
            <summary>
            The flags that control the position of the minimized window and the method by which the window is restored. This member can be one or more of the following values.
            Value	Meaning 
            WPF_ASYNCWINDOWPLACEMENT	0x0004	If the calling thread and the thread that owns the window are attached to different input queues, the system posts the request to the thread that owns the window. This prevents the calling thread from blocking its execution while other threads process the request.
            WPF_RESTORETOMAXIMIZED		0x0002	The restored window will be maximized, regardless of whether it was maximized before it was minimized. This setting is only valid the next time the window is restored. It does not change the default restoration behavior.
            																	This flag is only valid when the SW_SHOWMINIMIZED value is specified for the showCmd member.
            WPF_SETMINPOSITION				0x0001	The coordinates of the minimized window may be specified.
            																	This flag must be specified if the coordinates are set in the ptMinPosition member.
            </summary>
        </member>
        <member name="F:unvell.Common.Win32Lib.Win32.WindowPlacement.showCmd">
            <summary>
            The current show state of the window. This member can be one of the following values.
            </summary>
        </member>
        <member name="F:unvell.Common.Win32Lib.Win32.WindowPlacement.ptMinPosition">
            <summary>
            The coordinates of the window's upper-left corner when the window is minimized.
            </summary>
        </member>
        <member name="F:unvell.Common.Win32Lib.Win32.WindowPlacement.ptMaxPosition">
            <summary>
            The coordinates of the window's upper-left corner when the window is maximized.
            </summary>
        </member>
        <member name="F:unvell.Common.Win32Lib.Win32.WindowPlacement.rcNormalPosition">
            <summary>
            The window's coordinates when the window is in the restored position.
            </summary>
        </member>
        <member name="M:unvell.Common.Win32Lib.Win32.GetWindowRgn(System.IntPtr,System.Drawing.Region@)">
            <summary>
            The GetWindowRgn function obtains a copy of the window region of a window.
            The window region of a window is set by calling the SetWindowRgn function. 
            The window region determines the area within the window where the system
            permits drawing. The system does not display any portion of a window that
            lies outside of the window region
            </summary>
            <param name="hWnd">Handle to the window whose window region is to be obtained.</param>
            <param name="hRgn">Handle to the region which will be modified to represent the window region.</param>
            <returns>The return value specifies the type of the region that the function obtains. It can be one of the following values.
            NULLREGION - The region is empty.
            SIMPLEREGION - The region is a single rectangle.
            COMPLEXREGION - The region is more than one rectangle.
            ERROR - The specified window does not have a region, 
            				or an error occurred while attempting to return the region.</returns>
        </member>
        <member name="F:unvell.Common.Win32Lib.Win32.GAFlag.GA_PARENT">
            <summary>
            Retrieves the parent window. This does not include the owner, as it does with the GetParent function.
            </summary>
        </member>
        <member name="F:unvell.Common.Win32Lib.Win32.GAFlag.GA_ROOT">
            <summary>
            Retrieves the root window by walking the chain of parent windows.
            </summary>
        </member>
        <member name="F:unvell.Common.Win32Lib.Win32.GAFlag.GA_ROOTOWNER">
            <summary>
            Retrieves the owned root window by walking the chain of parent and owner windows returned by GetParent.
            </summary>
        </member>
        <member name="M:unvell.Common.Win32Lib.Win32.DwmGetWindowAttribute(System.IntPtr,System.Int32,System.Drawing.Rectangle@,System.Int32)">
            <summary>
            Retrieves the current value of a specified attribute applied to a window.
            </summary>
            <param name="hwnd"></param>
            <param name="dwAttribute"></param>
            <param name="pvAttribute"></param>
            <param name="cbAttribute"></param>
            <returns></returns>
        </member>
        <member name="T:unvell.Common.Win32Lib.Win32.DwmWindowAttribute">
            <summary>
            Flags used by the DwmGetWindowAttribute and DwmSetWindowAttribute
            functions to specify window attributes for non-client rendering.
            </summary>
        </member>
        <member name="F:unvell.Common.Win32Lib.Win32.DwmWindowAttribute.DWMWA_NCRENDERING_ENABLED">
            <summary>
            Use with DwmGetWindowAttribute. Discovers whether non-client rendering is enabled. 
            The retrieved value is of type BOOL. TRUE if non-client rendering is enabled; 
            otherwise, FALSE.
            </summary>
        </member>
        <member name="F:unvell.Common.Win32Lib.Win32.DwmWindowAttribute.DWMWA_NCRENDERING_POLICY">
            <summary>
            Use with DwmSetWindowAttribute. Sets the non-client rendering policy. 
            The pvAttribute parameter points to a value from the DWMNCRENDERINGPOLICY enumeration.
            </summary>
        </member>
        <member name="F:unvell.Common.Win32Lib.Win32.DwmWindowAttribute.DWMWA_TRANSITIONS_FORCEDISABLED">
            <summary>
            Use with DwmSetWindowAttribute. Enables or forcibly disables DWM transitions. 
            The pvAttribute parameter points to a value of TRUE to disable transitions or FALSE to enable transitions.
            </summary>
        </member>
        <member name="F:unvell.Common.Win32Lib.Win32.DwmWindowAttribute.DWMWA_ALLOW_NCPAINT">
            <summary>
            Use with DwmSetWindowAttribute. Enables content rendered in the non-client area to be visible on the frame drawn by DWM. 
            The pvAttribute parameter points to a value of TRUE to enable content rendered in the non-client area to be visible on the frame; otherwise, it points to FALSE.
            </summary>
        </member>
        <member name="F:unvell.Common.Win32Lib.Win32.DwmWindowAttribute.DWMWA_CAPTION_BUTTON_BOUNDS">
            <summary>
            Use with DwmGetWindowAttribute. Retrieves the bounds of the caption button area in the window-relative space. 
            The retrieved value is of type RECT.
            </summary>
        </member>
        <member name="F:unvell.Common.Win32Lib.Win32.DwmWindowAttribute.DWMWA_NONCLIENT_RTL_LAYOUT">
            <summary>
            Use with DwmSetWindowAttribute. Specifies whether non-client content is right-to-left (RTL) mirrored. 
            The pvAttribute parameter points to a value of TRUE if the non-client content is right-to-left (RTL) mirrored; otherwise, it points to FALSE.
            </summary>
        </member>
        <member name="F:unvell.Common.Win32Lib.Win32.DwmWindowAttribute.DWMWA_FORCE_ICONIC_REPRESENTATION">
            <summary>
            Use with DwmSetWindowAttribute. Forces the window to display an iconic thumbnail or 
            peek representation (a static bitmap), even if a live or snapshot representation of the window is available. 
            This value normally is set during a window's creation and not changed throughout the window's lifetime. 
            Some scenarios, however, might require the value to change over time. 
            The pvAttribute parameter points to a value of TRUE to require a iconic thumbnail or peek representation; 
            otherwise, it points to FALSE.
            </summary>
        </member>
        <member name="F:unvell.Common.Win32Lib.Win32.DwmWindowAttribute.DWMWA_FLIP3D_POLICY">
            <summary>
            Use with DwmSetWindowAttribute. Sets how Flip3D treats the window. 
            The pvAttribute parameter points to a value from the DWMFLIP3DWINDOWPOLICY enumeration.
            </summary>
        </member>
        <member name="F:unvell.Common.Win32Lib.Win32.DwmWindowAttribute.DWMWA_EXTENDED_FRAME_BOUNDS">
            <summary>
            Use with DwmGetWindowAttribute. Retrieves the extended frame bounds rectangle in screen space. 
            The retrieved value is of type RECT.
            </summary>
        </member>
        <member name="F:unvell.Common.Win32Lib.Win32.DwmWindowAttribute.DWMWA_HAS_ICONIC_BITMAP">
            <summary>
            Use with DwmSetWindowAttribute. The window will provide a bitmap for use by DWM as an iconic thumbnail or 
            peek representation (a static bitmap) for the window. DWMWA_HAS_ICONIC_BITMAP can be specified 
            with DWMWA_FORCE_ICONIC_REPRESENTATION. DWMWA_HAS_ICONIC_BITMAP normally is set during a window's 
            creation and not changed throughout the window's lifetime. Some scenarios, however, might require 
            the value to change over time. The pvAttribute parameter points to a value of TRUE to inform DWM that 
            the window will provide an iconic thumbnail or peek representation; otherwise, it points to FALSE.
            Windows Vista and earlier:  This value is not supported.
            </summary>
        </member>
        <member name="F:unvell.Common.Win32Lib.Win32.DwmWindowAttribute.DWMWA_DISALLOW_PEEK">
            <summary>
            Use with DwmSetWindowAttribute. Do not show peek preview for the window. The peek view shows a 
            full-sized preview of the window when the mouse hovers over the window's thumbnail in the taskbar. 
            If this attribute is set, hovering the mouse pointer over the window's thumbnail 
            dismisses peek (in case another window in the group has a peek preview showing). 
            The pvAttribute parameter points to a value of TRUE to prevent peek functionality or FALSE to allow it.
            Windows Vista and earlier:  This value is not supported.
            </summary>
        </member>
        <member name="F:unvell.Common.Win32Lib.Win32.DwmWindowAttribute.DWMWA_EXCLUDED_FROM_PEEK">
            <summary>
            Use with DwmSetWindowAttribute. Prevents a window from fading to a glass sheet when peek is invoked. 
            The pvAttribute parameter points to a value of TRUE to prevent the window from fading during another
            window's peek or FALSE for normal behavior.
            Windows Vista and earlier:  This value is not supported.
            </summary>
        </member>
        <member name="F:unvell.Common.Win32Lib.Win32.DwmWindowAttribute.DWMWA_CLOAK">
            <summary>
            Do not use.
            </summary>
        </member>
        <member name="F:unvell.Common.Win32Lib.Win32.DwmWindowAttribute.DWMWA_CLOAKED">
            <summary>
            Use with DwmGetWindowAttribute. If the window is cloaked, provides one of the following values 
            explaining why:
            Name									Value			Meaning
            DWM_CLOAKED_APP				0x0000001	The window was cloaked by its owner application.
            DWM_CLOAKED_SHELL			0x0000002	The window was cloaked by the Shell.
            DWM_CLOAKED_INHERITED	0x0000004	The cloak value was inherited from its owner window.
            Windows 7 and earlier:  This value is not supported.
            </summary>
        </member>
        <member name="F:unvell.Common.Win32Lib.Win32.DwmWindowAttribute.DWMWA_FREEZE_REPRESENTATION">
            <summary>
            Use with DwmSetWindowAttribute. Freeze the window's thumbnail image with its current visuals. 
            Do no further live updates on the thumbnail image to match the window's contents.
            Windows 7 and earlier:  This value is not supported.
            </summary>
        </member>
        <member name="F:unvell.Common.Win32Lib.Win32.DwmWindowAttribute.DWMWA_LAST">
            <summary>
            The maximum recognized DWMWINDOWATTRIBUTE value, used for validation purposes.
            </summary>
        </member>
        <member name="M:unvell.Common.Win32Lib.Win32.GetVersionEx(unvell.Common.Win32Lib.Win32.OSVersionInfo@)">
            <summary>
            Retrieves information about the current operating system.
            </summary>
            <param name="lpVersionInfo">version info</param>
            <returns>true if execution is successful</returns>
        </member>
        <member name="T:unvell.Common.Win32Lib.Win32.OSVersionInfo">
            <summary>
            Contains operating system version information.
            The information includes major and minor version numbers, 
            a build number, a platform identifier, and descriptive text about the 
            operating system. This structure is used with the GetVersionEx function.
            To obtain additional version information, use the OSVERSIONINFOEX 
            structure with GetVersionEx instead.
            </summary>
        </member>
        <member name="F:unvell.Common.Win32Lib.Win32.OSVersionInfo.dwOSVersionInfoSize">
            <summary>
            The size of this data structure, in bytes. 
            Set this member to sizeof(OSVERSIONINFO).
            </summary>
        </member>
        <member name="F:unvell.Common.Win32Lib.Win32.OSVersionInfo.dwMajorVersion">
            <summary>
            The major version number of the operating system. 
            For more information, see Remarks.
            </summary>
        </member>
        <member name="F:unvell.Common.Win32Lib.Win32.OSVersionInfo.dwMinorVersion">
            <summary>
            The minor version number of the operating system. 
            For more information, see Remarks.
            </summary>
        </member>
        <member name="F:unvell.Common.Win32Lib.Win32.OSVersionInfo.dwBuildNumber">
            <summary>
            The build number of the operating system.
            </summary>
        </member>
        <member name="F:unvell.Common.Win32Lib.Win32.OSVersionInfo.dwPlatformId">
            <summary>
            The operating system platform. This member can be the following value.
            VER_PLATFORM_WIN32_NT = 2 : The operating system is Windows 7,
            Windows Server 2008, Windows Vista, Windows Server 2003, Windows XP,
            or Windows 2000.
            </summary>
        </member>
        <member name="F:unvell.Common.Win32Lib.Win32.OSVersionInfo.szCSDVersion">
            <summary>
            A null-terminated string, such as "Service Pack 3", that indicates
            the latest Service Pack installed on the system. 
            If no Service Pack has been installed, the string is empty.
            </summary>
        </member>
        <member name="F:unvell.Common.Win32Lib.Win32.Modifiers.MOD_ALT">
            <summary>
            Either ALT key must be held down.
            </summary>
        </member>
        <member name="F:unvell.Common.Win32Lib.Win32.Modifiers.MOD_CONTROL">
            <summary>
            Either CTRL key must be held down.
            </summary>
        </member>
        <member name="F:unvell.Common.Win32Lib.Win32.Modifiers.MOD_SHIFT">
            <summary>
            Either SHIFT key must be held down.
            </summary>
        </member>
        <member name="F:unvell.Common.Win32Lib.Win32.Modifiers.MOD_WIN">
            <summary>
            Either WINDOWS key was held down. These keys are labeled with the Windows logo. 
            Keyboard shortcuts that involve the WINDOWS key are reserved for use by the operating system.
            </summary>
        </member>
        <member name="F:unvell.Common.Win32Lib.Win32.Modifiers.MOD_NOREPEAT">
            <summary>
            Changes the hotkey behavior so that the keyboard auto-repeat does not yield multiple hotkey notifications.
            </summary>
            
            <remarks>Windows Vista and Windows XP/2000:  This flag is not supported.</remarks>
        </member>
        <member name="T:Ionic.Crc.CRC32">
            <summary>
              Computes a CRC-32. The CRC-32 algorithm is parameterized - you
              can set the polynomial and enable or disable bit
              reversal. This can be used for GZIP, BZip2, or ZIP.
            </summary>
            <remarks>
              This type is used internally by DotNetZip; it is generally not used
              directly by applications wishing to create, read, or manipulate zip
              archive files.
            </remarks>
        </member>
        <member name="P:Ionic.Crc.CRC32.TotalBytesRead">
            <summary>
              Indicates the total number of bytes applied to the CRC.
            </summary>
        </member>
        <member name="P:Ionic.Crc.CRC32.Crc32Result">
            <summary>
            Indicates the current CRC for all blocks slurped in.
            </summary>
        </member>
        <member name="M:Ionic.Crc.CRC32.GetCrc32(System.IO.Stream)">
            <summary>
            Returns the CRC32 for the specified stream.
            </summary>
            <param name="input">The stream over which to calculate the CRC32</param>
            <returns>the CRC32 calculation</returns>
        </member>
        <member name="M:Ionic.Crc.CRC32.GetCrc32AndCopy(System.IO.Stream,System.IO.Stream)">
            <summary>
            Returns the CRC32 for the specified stream, and writes the input into the
            output stream.
            </summary>
            <param name="input">The stream over which to calculate the CRC32</param>
            <param name="output">The stream into which to deflate the input</param>
            <returns>the CRC32 calculation</returns>
        </member>
        <member name="M:Ionic.Crc.CRC32.ComputeCrc32(System.Int32,System.Byte)">
            <summary>
              Get the CRC32 for the given (word,byte) combo.  This is a
              computation defined by PKzip for PKZIP 2.0 (weak) encryption.
            </summary>
            <param name="W">The word to start with.</param>
            <param name="B">The byte to combine it with.</param>
            <returns>The CRC-ized result.</returns>
        </member>
        <member name="M:Ionic.Crc.CRC32.SlurpBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update the value for the running CRC32 using the given block of bytes.
            This is useful when using the CRC32() class in a Stream.
            </summary>
            <param name="block">block of bytes to slurp</param>
            <param name="offset">starting point in the block</param>
            <param name="count">how many bytes within the block to slurp</param>
        </member>
        <member name="M:Ionic.Crc.CRC32.UpdateCRC(System.Byte)">
            <summary>
              Process one byte in the CRC.
            </summary>
            <param name = "b">the byte to include into the CRC .  </param>
        </member>
        <member name="M:Ionic.Crc.CRC32.UpdateCRC(System.Byte,System.Int32)">
            <summary>
              Process a run of N identical bytes into the CRC.
            </summary>
            <remarks>
              <para>
                This method serves as an optimization for updating the CRC when a
                run of identical bytes is found. Rather than passing in a buffer of
                length n, containing all identical bytes b, this method accepts the
                byte value and the length of the (virtual) buffer - the length of
                the run.
              </para>
            </remarks>
            <param name = "b">the byte to include into the CRC.  </param>
            <param name = "n">the number of times that byte should be repeated. </param>
        </member>
        <member name="M:Ionic.Crc.CRC32.Combine(System.Int32,System.Int32)">
            <summary>
              Combines the given CRC32 value with the current running total.
            </summary>
            <remarks>
              This is useful when using a divide-and-conquer approach to
              calculating a CRC.  Multiple threads can each calculate a
              CRC32 on a segment of the data, and then combine the
              individual CRC32 values at the end.
            </remarks>
            <param name="crc">the crc value to be combined with this one</param>
            <param name="length">the length of data the CRC value was calculated on</param>
        </member>
        <member name="M:Ionic.Crc.CRC32.#ctor">
            <summary>
              Create an instance of the CRC32 class using the default settings: no
              bit reversal, and a polynomial of 0xEDB88320.
            </summary>
        </member>
        <member name="M:Ionic.Crc.CRC32.#ctor(System.Boolean)">
            <summary>
              Create an instance of the CRC32 class, specifying whether to reverse
              data bits or not.
            </summary>
            <param name='reverseBits'>
              specify true if the instance should reverse data bits.
            </param>
            <remarks>
              <para>
                In the CRC-32 used by BZip2, the bits are reversed. Therefore if you
                want a CRC32 with compatibility with BZip2, you should pass true
                here. In the CRC-32 used by GZIP and PKZIP, the bits are not
                reversed; Therefore if you want a CRC32 with compatibility with
                those, you should pass false.
              </para>
            </remarks>
        </member>
        <member name="M:Ionic.Crc.CRC32.#ctor(System.Int32,System.Boolean)">
             <summary>
               Create an instance of the CRC32 class, specifying the polynomial and
               whether to reverse data bits or not.
             </summary>
             <param name='polynomial'>
               The polynomial to use for the CRC, expressed in the reversed (LSB)
               format: the highest ordered bit in the polynomial value is the
               coefficient of the 0th power; the second-highest order bit is the
               coefficient of the 1 power, and so on. Expressed this way, the
               polynomial for the CRC-32C used in IEEE 802.3, is 0xEDB88320.
             </param>
             <param name='reverseBits'>
               specify true if the instance should reverse data bits.
             </param>
            
             <remarks>
               <para>
                 In the CRC-32 used by BZip2, the bits are reversed. Therefore if you
                 want a CRC32 with compatibility with BZip2, you should pass true
                 here for the <c>reverseBits</c> parameter. In the CRC-32 used by
                 GZIP and PKZIP, the bits are not reversed; Therefore if you want a
                 CRC32 with compatibility with those, you should pass false for the
                 <c>reverseBits</c> parameter.
               </para>
             </remarks>
        </member>
        <member name="M:Ionic.Crc.CRC32.Reset">
            <summary>
              Reset the CRC-32 class - clear the CRC "remainder register."
            </summary>
            <remarks>
              <para>
                Use this when employing a single instance of this class to compute
                multiple, distinct CRCs on multiple, distinct data blocks.
              </para>
            </remarks>
        </member>
        <member name="T:Ionic.Crc.CrcCalculatorStream">
             <summary>
             A Stream that calculates a CRC32 (a checksum) on all bytes read,
             or on all bytes written.
             </summary>
            
             <remarks>
             <para>
             This class can be used to verify the CRC of a ZipEntry when
             reading from a stream, or to calculate a CRC when writing to a
             stream.  The stream should be used to either read, or write, but
             not both.  If you intermix reads and writes, the results are not
             defined.
             </para>
            
             <para>
             This class is intended primarily for use internally by the
             DotNetZip library.
             </para>
             </remarks>
        </member>
        <member name="M:Ionic.Crc.CrcCalculatorStream.#ctor(System.IO.Stream)">
            <summary>
            The default constructor.
            </summary>
            <remarks>
              <para>
                Instances returned from this constructor will leave the underlying
                stream open upon Close().  The stream uses the default CRC32
                algorithm, which implies a polynomial of 0xEDB88320.
              </para>
            </remarks>
            <param name="stream">The underlying stream</param>
        </member>
        <member name="M:Ionic.Crc.CrcCalculatorStream.#ctor(System.IO.Stream,System.Boolean)">
            <summary>
              The constructor allows the caller to specify how to handle the
              underlying stream at close.
            </summary>
            <remarks>
              <para>
                The stream uses the default CRC32 algorithm, which implies a
                polynomial of 0xEDB88320.
              </para>
            </remarks>
            <param name="stream">The underlying stream</param>
            <param name="leaveOpen">true to leave the underlying stream
            open upon close of the <c>CrcCalculatorStream</c>; false otherwise.</param>
        </member>
        <member name="M:Ionic.Crc.CrcCalculatorStream.#ctor(System.IO.Stream,System.Int64)">
            <summary>
              A constructor allowing the specification of the length of the stream
              to read.
            </summary>
            <remarks>
              <para>
                The stream uses the default CRC32 algorithm, which implies a
                polynomial of 0xEDB88320.
              </para>
              <para>
                Instances returned from this constructor will leave the underlying
                stream open upon Close().
              </para>
            </remarks>
            <param name="stream">The underlying stream</param>
            <param name="length">The length of the stream to slurp</param>
        </member>
        <member name="M:Ionic.Crc.CrcCalculatorStream.#ctor(System.IO.Stream,System.Int64,System.Boolean)">
            <summary>
              A constructor allowing the specification of the length of the stream
              to read, as well as whether to keep the underlying stream open upon
              Close().
            </summary>
            <remarks>
              <para>
                The stream uses the default CRC32 algorithm, which implies a
                polynomial of 0xEDB88320.
              </para>
            </remarks>
            <param name="stream">The underlying stream</param>
            <param name="length">The length of the stream to slurp</param>
            <param name="leaveOpen">true to leave the underlying stream
            open upon close of the <c>CrcCalculatorStream</c>; false otherwise.</param>
        </member>
        <member name="M:Ionic.Crc.CrcCalculatorStream.#ctor(System.IO.Stream,System.Int64,System.Boolean,Ionic.Crc.CRC32)">
            <summary>
              A constructor allowing the specification of the length of the stream
              to read, as well as whether to keep the underlying stream open upon
              Close(), and the CRC32 instance to use.
            </summary>
            <remarks>
              <para>
                The stream uses the specified CRC32 instance, which allows the
                application to specify how the CRC gets calculated.
              </para>
            </remarks>
            <param name="stream">The underlying stream</param>
            <param name="length">The length of the stream to slurp</param>
            <param name="leaveOpen">true to leave the underlying stream
            open upon close of the <c>CrcCalculatorStream</c>; false otherwise.</param>
            <param name="crc32">the CRC32 instance to use to calculate the CRC32</param>
        </member>
        <member name="P:Ionic.Crc.CrcCalculatorStream.TotalBytesSlurped">
             <summary>
               Gets the total number of bytes run through the CRC32 calculator.
             </summary>
            
             <remarks>
               This is either the total number of bytes read, or the total number of
               bytes written, depending on the direction of this stream.
             </remarks>
        </member>
        <member name="P:Ionic.Crc.CrcCalculatorStream.Crc">
            <summary>
              Provides the current CRC for all blocks slurped in.
            </summary>
            <remarks>
              <para>
                The running total of the CRC is kept as data is written or read
                through the stream.  read this property after all reads or writes to
                get an accurate CRC for the entire stream.
              </para>
            </remarks>
        </member>
        <member name="P:Ionic.Crc.CrcCalculatorStream.LeaveOpen">
            <summary>
              Indicates whether the underlying stream will be left open when the
              <c>CrcCalculatorStream</c> is Closed.
            </summary>
            <remarks>
              <para>
                Set this at any point before calling <see cref="M:Ionic.Crc.CrcCalculatorStream.Close"/>.
              </para>
            </remarks>
        </member>
        <member name="M:Ionic.Crc.CrcCalculatorStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read from the stream
            </summary>
            <param name="buffer">the buffer to read</param>
            <param name="offset">the offset at which to start</param>
            <param name="count">the number of bytes to read</param>
            <returns>the number of bytes actually read</returns>
        </member>
        <member name="M:Ionic.Crc.CrcCalculatorStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Write to the stream.
            </summary>
            <param name="buffer">the buffer from which to write</param>
            <param name="offset">the offset at which to start writing</param>
            <param name="count">the number of bytes to write</param>
        </member>
        <member name="P:Ionic.Crc.CrcCalculatorStream.CanRead">
            <summary>
            Indicates whether the stream supports reading.
            </summary>
        </member>
        <member name="P:Ionic.Crc.CrcCalculatorStream.CanSeek">
            <summary>
              Indicates whether the stream supports seeking.
            </summary>
            <remarks>
              <para>
                Always returns false.
              </para>
            </remarks>
        </member>
        <member name="P:Ionic.Crc.CrcCalculatorStream.CanWrite">
            <summary>
            Indicates whether the stream supports writing.
            </summary>
        </member>
        <member name="M:Ionic.Crc.CrcCalculatorStream.Flush">
            <summary>
            Flush the stream.
            </summary>
        </member>
        <member name="P:Ionic.Crc.CrcCalculatorStream.Length">
            <summary>
              Returns the length of the underlying stream.
            </summary>
        </member>
        <member name="P:Ionic.Crc.CrcCalculatorStream.Position">
            <summary>
              The getter for this property returns the total bytes read.
              If you use the setter, it will throw
            <see cref="T:System.NotSupportedException"/>.
            </summary>
        </member>
        <member name="M:Ionic.Crc.CrcCalculatorStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Seeking is not supported on this stream. This method always throws
            <see cref="T:System.NotSupportedException"/>
            </summary>
            <param name="offset">N/A</param>
            <param name="origin">N/A</param>
            <returns>N/A</returns>
        </member>
        <member name="M:Ionic.Crc.CrcCalculatorStream.SetLength(System.Int64)">
            <summary>
            This method always throws
            <see cref="T:System.NotSupportedException"/>
            </summary>
            <param name="value">N/A</param>
        </member>
        <member name="M:Ionic.Crc.CrcCalculatorStream.Close">
            <summary>
            Closes the stream.
            </summary>
        </member>
        <member name="T:Ionic.Zlib.DeflateStream">
             <summary>
             A class for compressing and decompressing streams using the Deflate algorithm.
             </summary>
            
             <remarks>
            
             <para>
               The DeflateStream is a <see
               href="http://en.wikipedia.org/wiki/Decorator_pattern">Decorator</see> on a <see
               cref="T:System.IO.Stream"/>.  It adds DEFLATE compression or decompression to any
               stream.
             </para>
            
             <para>
               Using this stream, applications can compress or decompress data via stream
               <c>Read</c> and <c>Write</c> operations.  Either compresssion or decompression
               can occur through either reading or writing. The compression format used is
               DEFLATE, which is documented in <see
               href="http://www.ietf.org/rfc/rfc1951.txt">IETF RFC 1951</see>, "DEFLATE
               Compressed Data Format Specification version 1.3.".
             </para>
            
             <para>
               This class is similar to <see cref="!:ZlibStream"/>, except that
               <c>ZlibStream</c> adds the <see href="http://www.ietf.org/rfc/rfc1950.txt">RFC
               1950 - ZLIB</see> framing bytes to a compressed stream when compressing, or
               expects the RFC1950 framing bytes when decompressing. The <c>DeflateStream</c>
               does not.
             </para>
            
             </remarks>
            
             <seealso cref="!:ZlibStream" />
             <seealso cref="T:Ionic.Zlib.GZipStream" />
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode)">
             <summary>
               Create a DeflateStream using the specified CompressionMode.
             </summary>
            
             <remarks>
               When mode is <c>CompressionMode.Compress</c>, the DeflateStream will use
               the default compression level. The "captive" stream will be closed when
               the DeflateStream is closed.
             </remarks>
            
             <example>
             This example uses a DeflateStream to compress data from a file, and writes
             the compressed data to another file.
             <code>
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(fileToCompress + ".deflated"))
                 {
                     using (Stream compressor = new DeflateStream(raw, CompressionMode.Compress))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n;
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code>
            
             <code lang="VB">
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(fileToCompress &amp; ".deflated")
                     Using compressor As Stream = New DeflateStream(raw, CompressionMode.Compress)
                         Dim buffer As Byte() = New Byte(4096) {}
                         Dim n As Integer = -1
                         Do While (n &lt;&gt; 0)
                             If (n &gt; 0) Then
                                 compressor.Write(buffer, 0, n)
                             End If
                             n = input.Read(buffer, 0, buffer.Length)
                         Loop
                     End Using
                 End Using
             End Using
             </code>
             </example>
             <param name="stream">The stream which will be read or written.</param>
             <param name="mode">Indicates whether the DeflateStream will compress or decompress.</param>
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode,Ionic.Zlib.CompressionLevel)">
             <summary>
             Create a DeflateStream using the specified CompressionMode and the specified CompressionLevel.
             </summary>
            
             <remarks>
            
             <para>
               When mode is <c>CompressionMode.Decompress</c>, the level parameter is
               ignored.  The "captive" stream will be closed when the DeflateStream is
               closed.
             </para>
            
             </remarks>
            
             <example>
            
               This example uses a DeflateStream to compress data from a file, and writes
               the compressed data to another file.
            
             <code>
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(fileToCompress + ".deflated"))
                 {
                     using (Stream compressor = new DeflateStream(raw,
                                                                  CompressionMode.Compress,
                                                                  CompressionLevel.BestCompression))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n= -1;
                         while (n != 0)
                         {
                             if (n &gt; 0)
                                 compressor.Write(buffer, 0, n);
                             n= input.Read(buffer, 0, buffer.Length);
                         }
                     }
                 }
             }
             </code>
            
             <code lang="VB">
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(fileToCompress &amp; ".deflated")
                     Using compressor As Stream = New DeflateStream(raw, CompressionMode.Compress, CompressionLevel.BestCompression)
                         Dim buffer As Byte() = New Byte(4096) {}
                         Dim n As Integer = -1
                         Do While (n &lt;&gt; 0)
                             If (n &gt; 0) Then
                                 compressor.Write(buffer, 0, n)
                             End If
                             n = input.Read(buffer, 0, buffer.Length)
                         Loop
                     End Using
                 End Using
             End Using
             </code>
             </example>
             <param name="stream">The stream to be read or written while deflating or inflating.</param>
             <param name="mode">Indicates whether the <c>DeflateStream</c> will compress or decompress.</param>
             <param name="level">A tuning knob to trade speed for effectiveness.</param>
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode,System.Boolean)">
             <summary>
               Create a <c>DeflateStream</c> using the specified
               <c>CompressionMode</c>, and explicitly specify whether the
               stream should be left open after Deflation or Inflation.
             </summary>
            
             <remarks>
            
             <para>
               This constructor allows the application to request that the captive stream
               remain open after the deflation or inflation occurs.  By default, after
               <c>Close()</c> is called on the stream, the captive stream is also
               closed. In some cases this is not desired, for example if the stream is a
               memory stream that will be re-read after compression.  Specify true for
               the <paramref name="leaveOpen"/> parameter to leave the stream open.
             </para>
            
             <para>
               The <c>DeflateStream</c> will use the default compression level.
             </para>
            
             <para>
               See the other overloads of this constructor for example code.
             </para>
             </remarks>
            
             <param name="stream">
               The stream which will be read or written. This is called the
               "captive" stream in other places in this documentation.
             </param>
            
             <param name="mode">
               Indicates whether the <c>DeflateStream</c> will compress or decompress.
             </param>
            
             <param name="leaveOpen">true if the application would like the stream to
             remain open after inflation/deflation.</param>
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode,Ionic.Zlib.CompressionLevel,System.Boolean)">
             <summary>
               Create a <c>DeflateStream</c> using the specified <c>CompressionMode</c>
               and the specified <c>CompressionLevel</c>, and explicitly specify whether
               the stream should be left open after Deflation or Inflation.
             </summary>
            
             <remarks>
            
             <para>
               When mode is <c>CompressionMode.Decompress</c>, the level parameter is ignored.
             </para>
            
             <para>
               This constructor allows the application to request that the captive stream
               remain open after the deflation or inflation occurs.  By default, after
               <c>Close()</c> is called on the stream, the captive stream is also
               closed. In some cases this is not desired, for example if the stream is a
               <see cref="T:System.IO.MemoryStream"/> that will be re-read after
               compression.  Specify true for the <paramref name="leaveOpen"/> parameter
               to leave the stream open.
             </para>
            
             </remarks>
            
             <example>
            
               This example shows how to use a <c>DeflateStream</c> to compress data from
               a file, and store the compressed data into another file.
            
             <code>
             using (var output = System.IO.File.Create(fileToCompress + ".deflated"))
             {
                 using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
                 {
                     using (Stream compressor = new DeflateStream(output, CompressionMode.Compress, CompressionLevel.BestCompression, true))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n= -1;
                         while (n != 0)
                         {
                             if (n &gt; 0)
                                 compressor.Write(buffer, 0, n);
                             n= input.Read(buffer, 0, buffer.Length);
                         }
                     }
                 }
                 // can write additional data to the output stream here
             }
             </code>
            
             <code lang="VB">
             Using output As FileStream = File.Create(fileToCompress &amp; ".deflated")
                 Using input As Stream = File.OpenRead(fileToCompress)
                     Using compressor As Stream = New DeflateStream(output, CompressionMode.Compress, CompressionLevel.BestCompression, True)
                         Dim buffer As Byte() = New Byte(4096) {}
                         Dim n As Integer = -1
                         Do While (n &lt;&gt; 0)
                             If (n &gt; 0) Then
                                 compressor.Write(buffer, 0, n)
                             End If
                             n = input.Read(buffer, 0, buffer.Length)
                         Loop
                     End Using
                 End Using
                 ' can write additional data to the output stream here.
             End Using
             </code>
             </example>
             <param name="stream">The stream which will be read or written.</param>
             <param name="mode">Indicates whether the DeflateStream will compress or decompress.</param>
             <param name="leaveOpen">true if the application would like the stream to remain open after inflation/deflation.</param>
             <param name="level">A tuning knob to trade speed for effectiveness.</param>
        </member>
        <member name="P:Ionic.Zlib.DeflateStream.FlushMode">
            <summary>
            This property sets the flush behavior on the stream.
            </summary>
            <remarks> See the ZLIB documentation for the meaning of the flush behavior.
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.DeflateStream.BufferSize">
             <summary>
               The size of the working buffer for the compression codec.
             </summary>
            
             <remarks>
             <para>
               The working buffer is used for all stream operations.  The default size is
               1024 bytes.  The minimum size is 128 bytes. You may get better performance
               with a larger buffer.  Then again, you might not.  You would have to test
               it.
             </para>
            
             <para>
               Set this before the first call to <c>Read()</c> or <c>Write()</c> on the
               stream. If you try to set it afterwards, it will throw.
             </para>
             </remarks>
        </member>
        <member name="P:Ionic.Zlib.DeflateStream.Strategy">
             <summary>
               The ZLIB strategy to be used during compression.
             </summary>
            
             <remarks>
               By tweaking this parameter, you may be able to optimize the compression for
               data with particular characteristics.
             </remarks>
        </member>
        <member name="P:Ionic.Zlib.DeflateStream.TotalIn">
            <summary> Returns the total number of bytes input so far.</summary>
        </member>
        <member name="P:Ionic.Zlib.DeflateStream.TotalOut">
            <summary> Returns the total number of bytes output so far.</summary>
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.Dispose(System.Boolean)">
            <summary>
              Dispose the stream.
            </summary>
            <remarks>
              <para>
                This may or may not result in a <c>Close()</c> call on the captive
                stream.  See the constructors that have a <c>leaveOpen</c> parameter
                for more information.
              </para>
              <para>
                Application code won't call this code directly.  This method may be
                invoked in two distinct scenarios.  If disposing == true, the method
                has been called directly or indirectly by a user's code, for example
                via the public Dispose() method. In this case, both managed and
                unmanaged resources can be referenced and disposed.  If disposing ==
                false, the method has been called by the runtime from inside the
                object finalizer and this method should not reference other objects;
                in that case only unmanaged resources must be referenced or
                disposed.
              </para>
            </remarks>
            <param name="disposing">
              true if the Dispose method was invoked by user code.
            </param>
        </member>
        <member name="P:Ionic.Zlib.DeflateStream.CanRead">
            <summary>
            Indicates whether the stream can be read.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports reading.
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.DeflateStream.CanSeek">
            <summary>
            Indicates whether the stream supports Seek operations.
            </summary>
            <remarks>
            Always returns false.
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.DeflateStream.CanWrite">
            <summary>
            Indicates whether the stream can be written.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports writing.
            </remarks>
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.Flush">
            <summary>
            Flush the stream.
            </summary>
        </member>
        <member name="P:Ionic.Zlib.DeflateStream.Length">
            <summary>
            Reading this property always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
        </member>
        <member name="P:Ionic.Zlib.DeflateStream.Position">
             <summary>
             The position of the stream pointer.
             </summary>
            
             <remarks>
               Setting this property always throws a <see
               cref="T:System.NotImplementedException"/>. Reading will return the total bytes
               written out, if used in writing, or the total bytes read in, if used in
               reading.  The count may refer to compressed bytes or uncompressed bytes,
               depending on how you've used the stream.
             </remarks>
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.Read(System.Byte[],System.Int32,System.Int32)">
             <summary>
             Read data from the stream.
             </summary>
             <remarks>
            
             <para>
               If you wish to use the <c>DeflateStream</c> to compress data while
               reading, you can create a <c>DeflateStream</c> with
               <c>CompressionMode.Compress</c>, providing an uncompressed data stream.
               Then call Read() on that <c>DeflateStream</c>, and the data read will be
               compressed as you read.  If you wish to use the <c>DeflateStream</c> to
               decompress data while reading, you can create a <c>DeflateStream</c> with
               <c>CompressionMode.Decompress</c>, providing a readable compressed data
               stream.  Then call Read() on that <c>DeflateStream</c>, and the data read
               will be decompressed as you read.
             </para>
            
             <para>
               A <c>DeflateStream</c> can be used for <c>Read()</c> or <c>Write()</c>, but not both.
             </para>
            
             </remarks>
             <param name="buffer">The buffer into which the read data should be placed.</param>
             <param name="offset">the offset within that data array to put the first byte read.</param>
             <param name="count">the number of bytes to read.</param>
             <returns>the number of bytes actually read</returns>
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Calling this method always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
            <param name="offset">this is irrelevant, since it will always throw!</param>
            <param name="origin">this is irrelevant, since it will always throw!</param>
            <returns>irrelevant!</returns>
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.SetLength(System.Int64)">
            <summary>
            Calling this method always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
            <param name="value">this is irrelevant, since it will always throw!</param>
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.Write(System.Byte[],System.Int32,System.Int32)">
             <summary>
               Write data to the stream.
             </summary>
             <remarks>
            
             <para>
               If you wish to use the <c>DeflateStream</c> to compress data while
               writing, you can create a <c>DeflateStream</c> with
               <c>CompressionMode.Compress</c>, and a writable output stream.  Then call
               <c>Write()</c> on that <c>DeflateStream</c>, providing uncompressed data
               as input.  The data sent to the output stream will be the compressed form
               of the data written.  If you wish to use the <c>DeflateStream</c> to
               decompress data while writing, you can create a <c>DeflateStream</c> with
               <c>CompressionMode.Decompress</c>, and a writable output stream.  Then
               call <c>Write()</c> on that stream, providing previously compressed
               data. The data sent to the output stream will be the decompressed form of
               the data written.
             </para>
            
             <para>
               A <c>DeflateStream</c> can be used for <c>Read()</c> or <c>Write()</c>,
               but not both.
             </para>
            
             </remarks>
            
             <param name="buffer">The buffer holding data to write to the stream.</param>
             <param name="offset">the offset within that data array to find the first byte to write.</param>
             <param name="count">the number of bytes to write.</param>
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.CompressString(System.String)">
             <summary>
               Compress a string into a byte array using DEFLATE (RFC 1951).
             </summary>
            
             <remarks>
               Uncompress it with <see cref="M:Ionic.Zlib.DeflateStream.UncompressString(System.Byte[])"/>.
             </remarks>
            
             <seealso cref="M:Ionic.Zlib.DeflateStream.UncompressString(System.Byte[])">DeflateStream.UncompressString(byte[])</seealso>
             <seealso cref="M:Ionic.Zlib.DeflateStream.CompressBuffer(System.Byte[])">DeflateStream.CompressBuffer(byte[])</seealso>
             <seealso cref="M:Ionic.Zlib.GZipStream.CompressString(System.String)">GZipStream.CompressString(string)</seealso>
             <seealso cref="!:ZlibStream.CompressString(string)">ZlibStream.CompressString(string)</seealso>
            
             <param name="s">
               A string to compress. The string will first be encoded
               using UTF8, then compressed.
             </param>
            
             <returns>The string in compressed form</returns>
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.CompressBuffer(System.Byte[])">
             <summary>
               Compress a byte array into a new byte array using DEFLATE.
             </summary>
            
             <remarks>
               Uncompress it with <see cref="M:Ionic.Zlib.DeflateStream.UncompressBuffer(System.Byte[])"/>.
             </remarks>
            
             <seealso cref="M:Ionic.Zlib.DeflateStream.CompressString(System.String)">DeflateStream.CompressString(string)</seealso>
             <seealso cref="M:Ionic.Zlib.DeflateStream.UncompressBuffer(System.Byte[])">DeflateStream.UncompressBuffer(byte[])</seealso>
             <seealso cref="M:Ionic.Zlib.GZipStream.CompressBuffer(System.Byte[])">GZipStream.CompressBuffer(byte[])</seealso>
             <seealso cref="!:ZlibStream.CompressBuffer(byte[])">ZlibStream.CompressBuffer(byte[])</seealso>
            
             <param name="b">
               A buffer to compress.
             </param>
            
             <returns>The data in compressed form</returns>
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.UncompressString(System.Byte[])">
             <summary>
               Uncompress a DEFLATE'd byte array into a single string.
             </summary>
            
             <seealso cref="M:Ionic.Zlib.DeflateStream.CompressString(System.String)">DeflateStream.CompressString(String)</seealso>
             <seealso cref="M:Ionic.Zlib.DeflateStream.UncompressBuffer(System.Byte[])">DeflateStream.UncompressBuffer(byte[])</seealso>
             <seealso cref="M:Ionic.Zlib.GZipStream.UncompressString(System.Byte[])">GZipStream.UncompressString(byte[])</seealso>
             <seealso cref="!:ZlibStream.UncompressString(byte[])">ZlibStream.UncompressString(byte[])</seealso>
            
             <param name="compressed">
               A buffer containing DEFLATE-compressed data.
             </param>
            
             <returns>The uncompressed string</returns>
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.UncompressBuffer(System.Byte[])">
             <summary>
               Uncompress a DEFLATE'd byte array into a byte array.
             </summary>
            
             <seealso cref="M:Ionic.Zlib.DeflateStream.CompressBuffer(System.Byte[])">DeflateStream.CompressBuffer(byte[])</seealso>
             <seealso cref="M:Ionic.Zlib.DeflateStream.UncompressString(System.Byte[])">DeflateStream.UncompressString(byte[])</seealso>
             <seealso cref="M:Ionic.Zlib.GZipStream.UncompressBuffer(System.Byte[])">GZipStream.UncompressBuffer(byte[])</seealso>
             <seealso cref="!:ZlibStream.UncompressBuffer(byte[])">ZlibStream.UncompressBuffer(byte[])</seealso>
            
             <param name="compressed">
               A buffer containing data that has been compressed with DEFLATE.
             </param>
            
             <returns>The data in uncompressed form</returns>
        </member>
        <member name="T:Ionic.Zlib.FlushType">
            <summary>
            Describes how to flush the current deflate operation.
            </summary>
            <remarks>
            The different FlushType values are useful when using a Deflate in a streaming application.
            </remarks>
        </member>
        <member name="F:Ionic.Zlib.FlushType.None">
            <summary>No flush at all.</summary>
        </member>
        <member name="F:Ionic.Zlib.FlushType.Partial">
            <summary>Closes the current block, but doesn't flush it to
            the output. Used internally only in hypothetical
            scenarios.  This was supposed to be removed by Zlib, but it is
            still in use in some edge cases.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.FlushType.Sync">
            <summary>
            Use this during compression to specify that all pending output should be
            flushed to the output buffer and the output should be aligned on a byte
            boundary.  You might use this in a streaming communication scenario, so that
            the decompressor can get all input data available so far.  When using this
            with a ZlibCodec, <c>AvailableBytesIn</c> will be zero after the call if
            enough output space has been provided before the call.  Flushing will
            degrade compression and so it should be used only when necessary.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.FlushType.Full">
            <summary>
            Use this during compression to specify that all output should be flushed, as
            with <c>FlushType.Sync</c>, but also, the compression state should be reset
            so that decompression can restart from this point if previous compressed
            data has been damaged or if random access is desired.  Using
            <c>FlushType.Full</c> too often can significantly degrade the compression.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.FlushType.Finish">
            <summary>Signals the end of the compression/decompression stream.</summary>
        </member>
        <member name="T:Ionic.Zlib.CompressionLevel">
            <summary>
            The compression level to be used when using a DeflateStream or ZlibStream with CompressionMode.Compress.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.None">
            <summary>
            None means that the data will be simply stored, with no change at all.
            If you are producing ZIPs for use on Mac OSX, be aware that archives produced with CompressionLevel.None
            cannot be opened with the default zip reader. Use a different CompressionLevel.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.Level0">
            <summary>
            Same as None.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.BestSpeed">
            <summary>
            The fastest but least effective compression.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.Level1">
            <summary>
            A synonym for BestSpeed.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.Level2">
            <summary>
            A little slower, but better, than level 1.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.Level3">
            <summary>
            A little slower, but better, than level 2.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.Level4">
            <summary>
            A little slower, but better, than level 3.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.Level5">
            <summary>
            A little slower than level 4, but with better compression.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.Default">
            <summary>
            The default compression level, with a good balance of speed and compression efficiency.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.Level6">
            <summary>
            A synonym for Default.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.Level7">
            <summary>
            Pretty good compression!
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.Level8">
            <summary>
             Better compression than Level7!
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.BestCompression">
            <summary>
            The "best" compression, where best means greatest reduction in size of the input data stream.
            This is also the slowest compression.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.Level9">
            <summary>
            A synonym for BestCompression.
            </summary>
        </member>
        <member name="T:Ionic.Zlib.CompressionStrategy">
            <summary>
            Describes options for how the compression algorithm is executed.  Different strategies
            work better on different sorts of data.  The strategy parameter can affect the compression
            ratio and the speed of compression but not the correctness of the compresssion.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionStrategy.Default">
            <summary>
            The default strategy is probably the best for normal data.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionStrategy.Filtered">
            <summary>
            The <c>Filtered</c> strategy is intended to be used most effectively with data produced by a
            filter or predictor.  By this definition, filtered data consists mostly of small
            values with a somewhat random distribution.  In this case, the compression algorithm
            is tuned to compress them better.  The effect of <c>Filtered</c> is to force more Huffman
            coding and less string matching; it is a half-step between <c>Default</c> and <c>HuffmanOnly</c>.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionStrategy.HuffmanOnly">
            <summary>
            Using <c>HuffmanOnly</c> will force the compressor to do Huffman encoding only, with no
            string matching.
            </summary>
        </member>
        <member name="T:Ionic.Zlib.CompressionMode">
            <summary>
            An enum to specify the direction of transcoding - whether to compress or decompress.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionMode.Compress">
            <summary>
            Used to specify that the stream should compress the data.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionMode.Decompress">
            <summary>
            Used to specify that the stream should decompress the data.
            </summary>
        </member>
        <member name="T:Ionic.Zlib.ZlibException">
            <summary>
            A general purpose exception class for exceptions in the Zlib library.
            </summary>
        </member>
        <member name="M:Ionic.Zlib.ZlibException.#ctor">
            <summary>
            The ZlibException class captures exception information generated
            by the Zlib library.
            </summary>
        </member>
        <member name="M:Ionic.Zlib.ZlibException.#ctor(System.String)">
            <summary>
            This ctor collects a message attached to the exception.
            </summary>
            <param name="s">the message for the exception.</param>
        </member>
        <member name="M:Ionic.Zlib.SharedUtils.URShift(System.Int32,System.Int32)">
            <summary>
            Performs an unsigned bitwise right shift with the specified number
            </summary>
            <param name="number">Number to operate on</param>
            <param name="bits">Ammount of bits to shift</param>
            <returns>The resulting number from the shift operation</returns>
        </member>
        <member name="M:Ionic.Zlib.SharedUtils.ReadInput(System.IO.TextReader,System.Byte[],System.Int32,System.Int32)">
             <summary>
               Reads a number of characters from the current source TextReader and writes
               the data to the target array at the specified index.
             </summary>
            
             <param name="sourceTextReader">The source TextReader to read from</param>
             <param name="target">Contains the array of characteres read from the source TextReader.</param>
             <param name="start">The starting index of the target array.</param>
             <param name="count">The maximum number of characters to read from the source TextReader.</param>
            
             <returns>
               The number of characters read. The number will be less than or equal to
               count depending on the data available in the source TextReader. Returns -1
               if the end of the stream is reached.
             </returns>
        </member>
        <member name="T:Ionic.Zlib.Adler">
             <summary>
             Computes an Adler-32 checksum.
             </summary>
             <remarks>
             The Adler checksum is similar to a CRC checksum, but faster to compute, though less
             reliable.  It is used in producing RFC1950 compressed streams.  The Adler checksum
             is a required part of the "ZLIB" standard.  Applications will almost never need to
             use this class directly.
             </remarks>
            
             <exclude/>
        </member>
        <member name="M:Ionic.Zlib.Adler.Adler32(System.UInt32,System.Byte[],System.Int32,System.Int32)">
            <summary>
              Calculates the Adler32 checksum.
            </summary>
            <remarks>
              <para>
                This is used within ZLIB.  You probably don't need to use this directly.
              </para>
            </remarks>
            <example>
               To compute an Adler32 checksum on a byte array:
             <code>
               var adler = Adler.Adler32(0, null, 0, 0);
               adler = Adler.Adler32(adler, buffer, index, length);
             </code>
            </example>
        </member>
        <member name="T:Ionic.Zlib.ZlibConstants">
            <summary>
            A bunch of constants used in the Zlib interface.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibConstants.WindowBitsMax">
            <summary>
            The maximum number of window bits for the Deflate algorithm.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibConstants.WindowBitsDefault">
            <summary>
            The default number of window bits for the Deflate algorithm.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibConstants.Z_OK">
            <summary>
            indicates everything is A-OK
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibConstants.Z_STREAM_END">
            <summary>
            Indicates that the last operation reached the end of the stream.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibConstants.Z_NEED_DICT">
            <summary>
            The operation ended in need of a dictionary. 
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibConstants.Z_STREAM_ERROR">
            <summary>
            There was an error with the stream - not enough data, not open and readable, etc.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibConstants.Z_DATA_ERROR">
            <summary>
            There was an error with the data - not enough data, bad data, etc.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibConstants.Z_BUF_ERROR">
            <summary>
            There was an error with the working buffer.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibConstants.WorkingBufferSizeDefault">
            <summary>
            The size of the working buffer used in the ZlibCodec class. Defaults to 8192 bytes.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibConstants.WorkingBufferSizeMin">
            <summary>
            The minimum size of the working buffer used in the ZlibCodec class.  Currently it is 128 bytes.
            </summary>
        </member>
        <member name="T:Ionic.Zlib.ZlibCodec">
             <summary>
             Encoder and Decoder for ZLIB and DEFLATE (IETF RFC1950 and RFC1951).
             </summary>
            
             <remarks>
             This class compresses and decompresses data according to the Deflate algorithm
             and optionally, the ZLIB format, as documented in <see
             href="http://www.ietf.org/rfc/rfc1950.txt">RFC 1950 - ZLIB</see> and <see
             href="http://www.ietf.org/rfc/rfc1951.txt">RFC 1951 - DEFLATE</see>.
             </remarks>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.InputBuffer">
            <summary>
            The buffer from which data is taken.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.NextIn">
            <summary>
            An index into the InputBuffer array, indicating where to start reading. 
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.AvailableBytesIn">
            <summary>
            The number of bytes available in the InputBuffer, starting at NextIn. 
            </summary>
            <remarks>
            Generally you should set this to InputBuffer.Length before the first Inflate() or Deflate() call. 
            The class will update this number as calls to Inflate/Deflate are made.
            </remarks>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.TotalBytesIn">
            <summary>
            Total number of bytes read so far, through all calls to Inflate()/Deflate().
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.OutputBuffer">
            <summary>
            Buffer to store output data.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.NextOut">
            <summary>
            An index into the OutputBuffer array, indicating where to start writing. 
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.AvailableBytesOut">
            <summary>
            The number of bytes available in the OutputBuffer, starting at NextOut. 
            </summary>
            <remarks>
            Generally you should set this to OutputBuffer.Length before the first Inflate() or Deflate() call. 
            The class will update this number as calls to Inflate/Deflate are made.
            </remarks>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.TotalBytesOut">
            <summary>
            Total number of bytes written to the output so far, through all calls to Inflate()/Deflate().
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.Message">
            <summary>
            used for diagnostics, when something goes wrong!
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.CompressLevel">
            <summary>
            The compression level to use in this codec.  Useful only in compression mode.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.WindowBits">
            <summary>
            The number of Window Bits to use.  
            </summary>
            <remarks>
            This gauges the size of the sliding window, and hence the 
            compression effectiveness as well as memory consumption. It's best to just leave this 
            setting alone if you don't know what it is.  The maximum value is 15 bits, which implies
            a 32k window.  
            </remarks>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.Strategy">
            <summary>
            The compression strategy to use.
            </summary>
            <remarks>
            This is only effective in compression.  The theory offered by ZLIB is that different
            strategies could potentially produce significant differences in compression behavior
            for different data sets.  Unfortunately I don't have any good recommendations for how
            to set it differently.  When I tested changing the strategy I got minimally different
            compression performance. It's best to leave this property alone if you don't have a
            good feel for it.  Or, you may want to produce a test harness that runs through the
            different strategy options and evaluates them on different file types. If you do that,
            let me know your results.
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.ZlibCodec.Adler32">
            <summary>
            The Adler32 checksum on the data transferred through the codec so far. You probably don't need to look at this.
            </summary>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.#ctor">
            <summary>
            Create a ZlibCodec.
            </summary>
            <remarks>
            If you use this default constructor, you will later have to explicitly call 
            InitializeInflate() or InitializeDeflate() before using the ZlibCodec to compress 
            or decompress. 
            </remarks>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.#ctor(Ionic.Zlib.CompressionMode)">
            <summary>
            Create a ZlibCodec that either compresses or decompresses.
            </summary>
            <param name="mode">
            Indicates whether the codec should compress (deflate) or decompress (inflate).
            </param>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.InitializeInflate">
            <summary>
            Initialize the inflation state. 
            </summary>
            <remarks>
            It is not necessary to call this before using the ZlibCodec to inflate data; 
            It is implicitly called when you call the constructor.
            </remarks>
            <returns>Z_OK if everything goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.InitializeInflate(System.Boolean)">
             <summary>
             Initialize the inflation state with an explicit flag to
             govern the handling of RFC1950 header bytes.
             </summary>
            
             <remarks>
             By default, the ZLIB header defined in <see
             href="http://www.ietf.org/rfc/rfc1950.txt">RFC 1950</see> is expected.  If
             you want to read a zlib stream you should specify true for
             expectRfc1950Header.  If you have a deflate stream, you will want to specify
             false. It is only necessary to invoke this initializer explicitly if you
             want to specify false.
             </remarks>
            
             <param name="expectRfc1950Header">whether to expect an RFC1950 header byte
             pair when reading the stream of data to be inflated.</param>
            
             <returns>Z_OK if everything goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.InitializeInflate(System.Int32)">
            <summary>
            Initialize the ZlibCodec for inflation, with the specified number of window bits. 
            </summary>
            <param name="windowBits">The number of window bits to use. If you need to ask what that is, 
            then you shouldn't be calling this initializer.</param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.InitializeInflate(System.Int32,System.Boolean)">
             <summary>
             Initialize the inflation state with an explicit flag to govern the handling of
             RFC1950 header bytes. 
             </summary>
            
             <remarks>
             If you want to read a zlib stream you should specify true for
             expectRfc1950Header. In this case, the library will expect to find a ZLIB
             header, as defined in <see href="http://www.ietf.org/rfc/rfc1950.txt">RFC
             1950</see>, in the compressed stream.  If you will be reading a DEFLATE or
             GZIP stream, which does not have such a header, you will want to specify
             false.
             </remarks>
            
             <param name="expectRfc1950Header">whether to expect an RFC1950 header byte pair when reading 
             the stream of data to be inflated.</param>
             <param name="windowBits">The number of window bits to use. If you need to ask what that is, 
             then you shouldn't be calling this initializer.</param>
             <returns>Z_OK if everything goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.Inflate(Ionic.Zlib.FlushType)">
             <summary>
             Inflate the data in the InputBuffer, placing the result in the OutputBuffer.
             </summary>
             <remarks>
             You must have set InputBuffer and OutputBuffer, NextIn and NextOut, and AvailableBytesIn and 
             AvailableBytesOut  before calling this method.
             </remarks>
             <example>
             <code>
             private void InflateBuffer()
             {
                 int bufferSize = 1024;
                 byte[] buffer = new byte[bufferSize];
                 ZlibCodec decompressor = new ZlibCodec();
             
                 Console.WriteLine("\n============================================");
                 Console.WriteLine("Size of Buffer to Inflate: {0} bytes.", CompressedBytes.Length);
                 MemoryStream ms = new MemoryStream(DecompressedBytes);
             
                 int rc = decompressor.InitializeInflate();
             
                 decompressor.InputBuffer = CompressedBytes;
                 decompressor.NextIn = 0;
                 decompressor.AvailableBytesIn = CompressedBytes.Length;
             
                 decompressor.OutputBuffer = buffer;
             
                 // pass 1: inflate 
                 do
                 {
                     decompressor.NextOut = 0;
                     decompressor.AvailableBytesOut = buffer.Length;
                     rc = decompressor.Inflate(FlushType.None);
             
                     if (rc != ZlibConstants.Z_OK &amp;&amp; rc != ZlibConstants.Z_STREAM_END)
                         throw new Exception("inflating: " + decompressor.Message);
             
                     ms.Write(decompressor.OutputBuffer, 0, buffer.Length - decompressor.AvailableBytesOut);
                 }
                 while (decompressor.AvailableBytesIn &gt; 0 || decompressor.AvailableBytesOut == 0);
             
                 // pass 2: finish and flush
                 do
                 {
                     decompressor.NextOut = 0;
                     decompressor.AvailableBytesOut = buffer.Length;
                     rc = decompressor.Inflate(FlushType.Finish);
             
                     if (rc != ZlibConstants.Z_STREAM_END &amp;&amp; rc != ZlibConstants.Z_OK)
                         throw new Exception("inflating: " + decompressor.Message);
             
                     if (buffer.Length - decompressor.AvailableBytesOut &gt; 0)
                         ms.Write(buffer, 0, buffer.Length - decompressor.AvailableBytesOut);
                 }
                 while (decompressor.AvailableBytesIn &gt; 0 || decompressor.AvailableBytesOut == 0);
             
                 decompressor.EndInflate();
             }
            
             </code>
             </example>
             <param name="flush">The flush to use when inflating.</param>
             <returns>Z_OK if everything goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.EndInflate">
            <summary>
            Ends an inflation session. 
            </summary>
            <remarks>
            Call this after successively calling Inflate().  This will cause all buffers to be flushed. 
            After calling this you cannot call Inflate() without a intervening call to one of the
            InitializeInflate() overloads.
            </remarks>
            <returns>Z_OK if everything goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.SyncInflate">
            <summary>
            I don't know what this does!
            </summary>
            <returns>Z_OK if everything goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.InitializeDeflate">
            <summary>
            Initialize the ZlibCodec for deflation operation.
            </summary>
            <remarks>
            The codec will use the MAX window bits and the default level of compression.
            </remarks>
            <example>
            <code>
             int bufferSize = 40000;
             byte[] CompressedBytes = new byte[bufferSize];
             byte[] DecompressedBytes = new byte[bufferSize];
             
             ZlibCodec compressor = new ZlibCodec();
             
             compressor.InitializeDeflate(CompressionLevel.Default);
             
             compressor.InputBuffer = System.Text.ASCIIEncoding.ASCII.GetBytes(TextToCompress);
             compressor.NextIn = 0;
             compressor.AvailableBytesIn = compressor.InputBuffer.Length;
             
             compressor.OutputBuffer = CompressedBytes;
             compressor.NextOut = 0;
             compressor.AvailableBytesOut = CompressedBytes.Length;
             
             while (compressor.TotalBytesIn != TextToCompress.Length &amp;&amp; compressor.TotalBytesOut &lt; bufferSize)
             {
               compressor.Deflate(FlushType.None);
             }
             
             while (true)
             {
               int rc= compressor.Deflate(FlushType.Finish);
               if (rc == ZlibConstants.Z_STREAM_END) break;
             }
             
             compressor.EndDeflate();
              
            </code>
            </example>
            <returns>Z_OK if all goes well. You generally don't need to check the return code.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.InitializeDeflate(Ionic.Zlib.CompressionLevel)">
            <summary>
            Initialize the ZlibCodec for deflation operation, using the specified CompressionLevel.
            </summary>
            <remarks>
            The codec will use the maximum window bits (15) and the specified
            CompressionLevel.  It will emit a ZLIB stream as it compresses.
            </remarks>
            <param name="level">The compression level for the codec.</param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.InitializeDeflate(Ionic.Zlib.CompressionLevel,System.Boolean)">
            <summary>
            Initialize the ZlibCodec for deflation operation, using the specified CompressionLevel, 
            and the explicit flag governing whether to emit an RFC1950 header byte pair.
            </summary>
            <remarks>
            The codec will use the maximum window bits (15) and the specified CompressionLevel.
            If you want to generate a zlib stream, you should specify true for
            wantRfc1950Header. In this case, the library will emit a ZLIB
            header, as defined in <see href="http://www.ietf.org/rfc/rfc1950.txt">RFC
            1950</see>, in the compressed stream.  
            </remarks>
            <param name="level">The compression level for the codec.</param>
            <param name="wantRfc1950Header">whether to emit an initial RFC1950 byte pair in the compressed stream.</param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.InitializeDeflate(Ionic.Zlib.CompressionLevel,System.Int32)">
            <summary>
            Initialize the ZlibCodec for deflation operation, using the specified CompressionLevel, 
            and the specified number of window bits. 
            </summary>
            <remarks>
            The codec will use the specified number of window bits and the specified CompressionLevel.
            </remarks>
            <param name="level">The compression level for the codec.</param>
            <param name="bits">the number of window bits to use.  If you don't know what this means, don't use this method.</param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.InitializeDeflate(Ionic.Zlib.CompressionLevel,System.Int32,System.Boolean)">
             <summary>
             Initialize the ZlibCodec for deflation operation, using the specified
             CompressionLevel, the specified number of window bits, and the explicit flag
             governing whether to emit an RFC1950 header byte pair.
             </summary>
            
             <param name="level">The compression level for the codec.</param>
             <param name="wantRfc1950Header">whether to emit an initial RFC1950 byte pair in the compressed stream.</param>
             <param name="bits">the number of window bits to use.  If you don't know what this means, don't use this method.</param>
             <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.Deflate(Ionic.Zlib.FlushType)">
            <summary>
            Deflate one batch of data.
            </summary>
            <remarks>
            You must have set InputBuffer and OutputBuffer before calling this method.
            </remarks>
            <example>
            <code>
            private void DeflateBuffer(CompressionLevel level)
            {
                int bufferSize = 1024;
                byte[] buffer = new byte[bufferSize];
                ZlibCodec compressor = new ZlibCodec();
            
                Console.WriteLine("\n============================================");
                Console.WriteLine("Size of Buffer to Deflate: {0} bytes.", UncompressedBytes.Length);
                MemoryStream ms = new MemoryStream();
            
                int rc = compressor.InitializeDeflate(level);
            
                compressor.InputBuffer = UncompressedBytes;
                compressor.NextIn = 0;
                compressor.AvailableBytesIn = UncompressedBytes.Length;
            
                compressor.OutputBuffer = buffer;
            
                // pass 1: deflate 
                do
                {
                    compressor.NextOut = 0;
                    compressor.AvailableBytesOut = buffer.Length;
                    rc = compressor.Deflate(FlushType.None);
            
                    if (rc != ZlibConstants.Z_OK &amp;&amp; rc != ZlibConstants.Z_STREAM_END)
                        throw new Exception("deflating: " + compressor.Message);
            
                    ms.Write(compressor.OutputBuffer, 0, buffer.Length - compressor.AvailableBytesOut);
                }
                while (compressor.AvailableBytesIn &gt; 0 || compressor.AvailableBytesOut == 0);
            
                // pass 2: finish and flush
                do
                {
                    compressor.NextOut = 0;
                    compressor.AvailableBytesOut = buffer.Length;
                    rc = compressor.Deflate(FlushType.Finish);
            
                    if (rc != ZlibConstants.Z_STREAM_END &amp;&amp; rc != ZlibConstants.Z_OK)
                        throw new Exception("deflating: " + compressor.Message);
            
                    if (buffer.Length - compressor.AvailableBytesOut &gt; 0)
                        ms.Write(buffer, 0, buffer.Length - compressor.AvailableBytesOut);
                }
                while (compressor.AvailableBytesIn &gt; 0 || compressor.AvailableBytesOut == 0);
            
                compressor.EndDeflate();
            
                ms.Seek(0, SeekOrigin.Begin);
                CompressedBytes = new byte[compressor.TotalBytesOut];
                ms.Read(CompressedBytes, 0, CompressedBytes.Length);
            }
            </code>
            </example>
            <param name="flush">whether to flush all data as you deflate. Generally you will want to 
            use Z_NO_FLUSH here, in a series of calls to Deflate(), and then call EndDeflate() to 
            flush everything. 
            </param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.EndDeflate">
            <summary>
            End a deflation session.
            </summary>
            <remarks>
            Call this after making a series of one or more calls to Deflate(). All buffers are flushed.
            </remarks>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.ResetDeflate">
            <summary>
            Reset a codec for another deflation session.
            </summary>
            <remarks>
            Call this to reset the deflation state.  For example if a thread is deflating
            non-consecutive blocks, you can call Reset() after the Deflate(Sync) of the first
            block and before the next Deflate(None) of the second block.
            </remarks>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.SetDeflateParams(Ionic.Zlib.CompressionLevel,Ionic.Zlib.CompressionStrategy)">
            <summary>
            Set the CompressionStrategy and CompressionLevel for a deflation session.
            </summary>
            <param name="level">the level of compression to use.</param>
            <param name="strategy">the strategy to use for compression.</param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.SetDictionary(System.Byte[])">
            <summary>
            Set the dictionary to be used for either Inflation or Deflation.
            </summary>
            <param name="dictionary">The dictionary bytes to use.</param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.Tree.DistanceCode(System.Int32)">
            <summary>
            Map from a distance to a distance code.
            </summary>
            <remarks> 
            No side effects. _dist_code[256] and _dist_code[257] are never used.
            </remarks>
        </member>
        <member name="T:Ionic.Zlib.GZipStream">
             <summary>
               A class for compressing and decompressing GZIP streams.
             </summary>
             <remarks>
            
             <para>
               The <c>GZipStream</c> is a <see
               href="http://en.wikipedia.org/wiki/Decorator_pattern">Decorator</see> on a
               <see cref="T:System.IO.Stream"/>. It adds GZIP compression or decompression to any
               stream.
             </para>
            
             <para>
               Like the <c>System.IO.Compression.GZipStream</c> in the .NET Base Class Library, the
               <c>Ionic.Zlib.GZipStream</c> can compress while writing, or decompress while
               reading, but not vice versa.  The compression method used is GZIP, which is
               documented in <see href="http://www.ietf.org/rfc/rfc1952.txt">IETF RFC
               1952</see>, "GZIP file format specification version 4.3".</para>
            
             <para>
               A <c>GZipStream</c> can be used to decompress data (through <c>Read()</c>) or
               to compress data (through <c>Write()</c>), but not both.
             </para>
            
             <para>
               If you wish to use the <c>GZipStream</c> to compress data, you must wrap it
               around a write-able stream. As you call <c>Write()</c> on the <c>GZipStream</c>, the
               data will be compressed into the GZIP format.  If you want to decompress data,
               you must wrap the <c>GZipStream</c> around a readable stream that contains an
               IETF RFC 1952-compliant stream.  The data will be decompressed as you call
               <c>Read()</c> on the <c>GZipStream</c>.
             </para>
            
             <para>
               Though the GZIP format allows data from multiple files to be concatenated
               together, this stream handles only a single segment of GZIP format, typically
               representing a single file.
             </para>
            
             <para>
               This class is similar to <see cref="!:ZlibStream"/> and <see cref="T:Ionic.Zlib.DeflateStream"/>.
               <c>ZlibStream</c> handles RFC1950-compliant streams.  <see cref="T:Ionic.Zlib.DeflateStream"/>
               handles RFC1951-compliant streams. This class handles RFC1952-compliant streams.
             </para>
            
             </remarks>
            
             <seealso cref="T:Ionic.Zlib.DeflateStream" />
             <seealso cref="!:ZlibStream" />
        </member>
        <member name="P:Ionic.Zlib.GZipStream.Comment">
             <summary>
               The comment on the GZIP stream.
             </summary>
            
             <remarks>
             <para>
               The GZIP format allows for each file to optionally have an associated
               comment stored with the file.  The comment is encoded with the ISO-8859-1
               code page.  To include a comment in a GZIP stream you create, set this
               property before calling <c>Write()</c> for the first time on the
               <c>GZipStream</c>.
             </para>
            
             <para>
               When using <c>GZipStream</c> to decompress, you can retrieve this property
               after the first call to <c>Read()</c>.  If no comment has been set in the
               GZIP bytestream, the Comment property will return <c>null</c>
               (<c>Nothing</c> in VB).
             </para>
             </remarks>
        </member>
        <member name="P:Ionic.Zlib.GZipStream.FileName">
             <summary>
               The FileName for the GZIP stream.
             </summary>
            
             <remarks>
            
             <para>
               The GZIP format optionally allows each file to have an associated
               filename.  When compressing data (through <c>Write()</c>), set this
               FileName before calling <c>Write()</c> the first time on the <c>GZipStream</c>.
               The actual filename is encoded into the GZIP bytestream with the
               ISO-8859-1 code page, according to RFC 1952. It is the application's
               responsibility to insure that the FileName can be encoded and decoded
               correctly with this code page.
             </para>
            
             <para>
               When decompressing (through <c>Read()</c>), you can retrieve this value
               any time after the first <c>Read()</c>.  In the case where there was no filename
               encoded into the GZIP bytestream, the property will return <c>null</c> (<c>Nothing</c>
               in VB).
             </para>
             </remarks>
        </member>
        <member name="F:Ionic.Zlib.GZipStream.LastModified">
             <summary>
               The last modified time for the GZIP stream.
             </summary>
            
             <remarks>
               GZIP allows the storage of a last modified time with each GZIP entry.
               When compressing data, you can set this before the first call to
               <c>Write()</c>.  When decompressing, you can retrieve this value any time
               after the first call to <c>Read()</c>.
             </remarks>
        </member>
        <member name="P:Ionic.Zlib.GZipStream.Crc32">
            <summary>
            The CRC on the GZIP stream.
            </summary>
            <remarks>
            This is used for internal error checking. You probably don't need to look at this property.
            </remarks>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode)">
             <summary>
               Create a <c>GZipStream</c> using the specified <c>CompressionMode</c>.
             </summary>
             <remarks>
            
             <para>
               When mode is <c>CompressionMode.Compress</c>, the <c>GZipStream</c> will use the
               default compression level.
             </para>
            
             <para>
               As noted in the class documentation, the <c>CompressionMode</c> (Compress
               or Decompress) also establishes the "direction" of the stream.  A
               <c>GZipStream</c> with <c>CompressionMode.Compress</c> works only through
               <c>Write()</c>.  A <c>GZipStream</c> with
               <c>CompressionMode.Decompress</c> works only through <c>Read()</c>.
             </para>
            
             </remarks>
            
             <example>
               This example shows how to use a GZipStream to compress data.
             <code>
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(outputFile))
                 {
                     using (Stream compressor = new GZipStream(raw, CompressionMode.Compress))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n;
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code>
             <code lang="VB">
             Dim outputFile As String = (fileToCompress &amp; ".compressed")
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(outputFile)
                 Using compressor As Stream = New GZipStream(raw, CompressionMode.Compress)
                     Dim buffer As Byte() = New Byte(4096) {}
                     Dim n As Integer = -1
                     Do While (n &lt;&gt; 0)
                         If (n &gt; 0) Then
                             compressor.Write(buffer, 0, n)
                         End If
                         n = input.Read(buffer, 0, buffer.Length)
                     Loop
                 End Using
                 End Using
             End Using
             </code>
             </example>
            
             <example>
             This example shows how to use a GZipStream to uncompress a file.
             <code>
             private void GunZipFile(string filename)
             {
                 if (!filename.EndsWith(".gz))
                     throw new ArgumentException("filename");
                 var DecompressedFile = filename.Substring(0,filename.Length-3);
                 byte[] working = new byte[WORKING_BUFFER_SIZE];
                 int n= 1;
                 using (System.IO.Stream input = System.IO.File.OpenRead(filename))
                 {
                     using (Stream decompressor= new Ionic.Zlib.GZipStream(input, CompressionMode.Decompress, true))
                     {
                         using (var output = System.IO.File.Create(DecompressedFile))
                         {
                             while (n !=0)
                             {
                                 n= decompressor.Read(working, 0, working.Length);
                                 if (n > 0)
                                 {
                                     output.Write(working, 0, n);
                                 }
                             }
                         }
                     }
                 }
             }
             </code>
            
             <code lang="VB">
             Private Sub GunZipFile(ByVal filename as String)
                 If Not (filename.EndsWith(".gz)) Then
                     Throw New ArgumentException("filename")
                 End If
                 Dim DecompressedFile as String = filename.Substring(0,filename.Length-3)
                 Dim working(WORKING_BUFFER_SIZE) as Byte
                 Dim n As Integer = 1
                 Using input As Stream = File.OpenRead(filename)
                     Using decompressor As Stream = new Ionic.Zlib.GZipStream(input, CompressionMode.Decompress, True)
                         Using output As Stream = File.Create(UncompressedFile)
                             Do
                                 n= decompressor.Read(working, 0, working.Length)
                                 If n > 0 Then
                                     output.Write(working, 0, n)
                                 End IF
                             Loop While (n  > 0)
                         End Using
                     End Using
                 End Using
             End Sub
             </code>
             </example>
            
             <param name="stream">The stream which will be read or written.</param>
             <param name="mode">Indicates whether the GZipStream will compress or decompress.</param>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode,Ionic.Zlib.CompressionLevel)">
             <summary>
               Create a <c>GZipStream</c> using the specified <c>CompressionMode</c> and
               the specified <c>CompressionLevel</c>.
             </summary>
             <remarks>
            
             <para>
               The <c>CompressionMode</c> (Compress or Decompress) also establishes the
               "direction" of the stream.  A <c>GZipStream</c> with
               <c>CompressionMode.Compress</c> works only through <c>Write()</c>.  A
               <c>GZipStream</c> with <c>CompressionMode.Decompress</c> works only
               through <c>Read()</c>.
             </para>
            
             </remarks>
            
             <example>
            
             This example shows how to use a <c>GZipStream</c> to compress a file into a .gz file.
            
             <code>
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(fileToCompress + ".gz"))
                 {
                     using (Stream compressor = new GZipStream(raw,
                                                               CompressionMode.Compress,
                                                               CompressionLevel.BestCompression))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n;
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code>
            
             <code lang="VB">
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(fileToCompress &amp; ".gz")
                     Using compressor As Stream = New GZipStream(raw, CompressionMode.Compress, CompressionLevel.BestCompression)
                         Dim buffer As Byte() = New Byte(4096) {}
                         Dim n As Integer = -1
                         Do While (n &lt;&gt; 0)
                             If (n &gt; 0) Then
                                 compressor.Write(buffer, 0, n)
                             End If
                             n = input.Read(buffer, 0, buffer.Length)
                         Loop
                     End Using
                 End Using
             End Using
             </code>
             </example>
             <param name="stream">The stream to be read or written while deflating or inflating.</param>
             <param name="mode">Indicates whether the <c>GZipStream</c> will compress or decompress.</param>
             <param name="level">A tuning knob to trade speed for effectiveness.</param>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode,System.Boolean)">
             <summary>
               Create a <c>GZipStream</c> using the specified <c>CompressionMode</c>, and
               explicitly specify whether the stream should be left open after Deflation
               or Inflation.
             </summary>
            
             <remarks>
             <para>
               This constructor allows the application to request that the captive stream
               remain open after the deflation or inflation occurs.  By default, after
               <c>Close()</c> is called on the stream, the captive stream is also
               closed. In some cases this is not desired, for example if the stream is a
               memory stream that will be re-read after compressed data has been written
               to it.  Specify true for the <paramref name="leaveOpen"/> parameter to leave
               the stream open.
             </para>
            
             <para>
               The <see cref="T:Ionic.Zlib.CompressionMode"/> (Compress or Decompress) also
               establishes the "direction" of the stream.  A <c>GZipStream</c> with
               <c>CompressionMode.Compress</c> works only through <c>Write()</c>.  A <c>GZipStream</c>
               with <c>CompressionMode.Decompress</c> works only through <c>Read()</c>.
             </para>
            
             <para>
               The <c>GZipStream</c> will use the default compression level. If you want
               to specify the compression level, see <see cref="M:Ionic.Zlib.GZipStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode,Ionic.Zlib.CompressionLevel,System.Boolean)"/>.
             </para>
            
             <para>
               See the other overloads of this constructor for example code.
             </para>
            
             </remarks>
            
             <param name="stream">
               The stream which will be read or written. This is called the "captive"
               stream in other places in this documentation.
             </param>
            
             <param name="mode">Indicates whether the GZipStream will compress or decompress.
             </param>
            
             <param name="leaveOpen">
               true if the application would like the base stream to remain open after
               inflation/deflation.
             </param>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode,Ionic.Zlib.CompressionLevel,System.Boolean)">
             <summary>
               Create a <c>GZipStream</c> using the specified <c>CompressionMode</c> and the
               specified <c>CompressionLevel</c>, and explicitly specify whether the
               stream should be left open after Deflation or Inflation.
             </summary>
            
             <remarks>
            
             <para>
               This constructor allows the application to request that the captive stream
               remain open after the deflation or inflation occurs.  By default, after
               <c>Close()</c> is called on the stream, the captive stream is also
               closed. In some cases this is not desired, for example if the stream is a
               memory stream that will be re-read after compressed data has been written
               to it.  Specify true for the <paramref name="leaveOpen"/> parameter to
               leave the stream open.
             </para>
            
             <para>
               As noted in the class documentation, the <c>CompressionMode</c> (Compress
               or Decompress) also establishes the "direction" of the stream.  A
               <c>GZipStream</c> with <c>CompressionMode.Compress</c> works only through
               <c>Write()</c>.  A <c>GZipStream</c> with <c>CompressionMode.Decompress</c> works only
               through <c>Read()</c>.
             </para>
            
             </remarks>
            
             <example>
               This example shows how to use a <c>GZipStream</c> to compress data.
             <code>
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(outputFile))
                 {
                     using (Stream compressor = new GZipStream(raw, CompressionMode.Compress, CompressionLevel.BestCompression, true))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n;
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code>
             <code lang="VB">
             Dim outputFile As String = (fileToCompress &amp; ".compressed")
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(outputFile)
                 Using compressor As Stream = New GZipStream(raw, CompressionMode.Compress, CompressionLevel.BestCompression, True)
                     Dim buffer As Byte() = New Byte(4096) {}
                     Dim n As Integer = -1
                     Do While (n &lt;&gt; 0)
                         If (n &gt; 0) Then
                             compressor.Write(buffer, 0, n)
                         End If
                         n = input.Read(buffer, 0, buffer.Length)
                     Loop
                 End Using
                 End Using
             End Using
             </code>
             </example>
             <param name="stream">The stream which will be read or written.</param>
             <param name="mode">Indicates whether the GZipStream will compress or decompress.</param>
             <param name="leaveOpen">true if the application would like the stream to remain open after inflation/deflation.</param>
             <param name="level">A tuning knob to trade speed for effectiveness.</param>
        </member>
        <member name="P:Ionic.Zlib.GZipStream.FlushMode">
            <summary>
            This property sets the flush behavior on the stream.
            </summary>
        </member>
        <member name="P:Ionic.Zlib.GZipStream.BufferSize">
             <summary>
               The size of the working buffer for the compression codec.
             </summary>
            
             <remarks>
             <para>
               The working buffer is used for all stream operations.  The default size is
               1024 bytes.  The minimum size is 128 bytes. You may get better performance
               with a larger buffer.  Then again, you might not.  You would have to test
               it.
             </para>
            
             <para>
               Set this before the first call to <c>Read()</c> or <c>Write()</c> on the
               stream. If you try to set it afterwards, it will throw.
             </para>
             </remarks>
        </member>
        <member name="P:Ionic.Zlib.GZipStream.TotalIn">
            <summary> Returns the total number of bytes input so far.</summary>
        </member>
        <member name="P:Ionic.Zlib.GZipStream.TotalOut">
            <summary> Returns the total number of bytes output so far.</summary>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.Dispose(System.Boolean)">
            <summary>
              Dispose the stream.
            </summary>
            <remarks>
              <para>
                This may or may not result in a <c>Close()</c> call on the captive
                stream.  See the constructors that have a <c>leaveOpen</c> parameter
                for more information.
              </para>
              <para>
                This method may be invoked in two distinct scenarios.  If disposing
                == true, the method has been called directly or indirectly by a
                user's code, for example via the public Dispose() method. In this
                case, both managed and unmanaged resources can be referenced and
                disposed.  If disposing == false, the method has been called by the
                runtime from inside the object finalizer and this method should not
                reference other objects; in that case only unmanaged resources must
                be referenced or disposed.
              </para>
            </remarks>
            <param name="disposing">
              indicates whether the Dispose method was invoked by user code.
            </param>
        </member>
        <member name="P:Ionic.Zlib.GZipStream.CanRead">
            <summary>
            Indicates whether the stream can be read.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports reading.
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.GZipStream.CanSeek">
            <summary>
            Indicates whether the stream supports Seek operations.
            </summary>
            <remarks>
            Always returns false.
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.GZipStream.CanWrite">
            <summary>
            Indicates whether the stream can be written.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports writing.
            </remarks>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.Flush">
            <summary>
            Flush the stream.
            </summary>
        </member>
        <member name="P:Ionic.Zlib.GZipStream.Length">
            <summary>
            Reading this property always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
        </member>
        <member name="P:Ionic.Zlib.GZipStream.Position">
             <summary>
               The position of the stream pointer.
             </summary>
            
             <remarks>
               Setting this property always throws a <see
               cref="T:System.NotImplementedException"/>. Reading will return the total bytes
               written out, if used in writing, or the total bytes read in, if used in
               reading.  The count may refer to compressed bytes or uncompressed bytes,
               depending on how you've used the stream.
             </remarks>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.Read(System.Byte[],System.Int32,System.Int32)">
             <summary>
               Read and decompress data from the source stream.
             </summary>
            
             <remarks>
               With a <c>GZipStream</c>, decompression is done through reading.
             </remarks>
            
             <example>
             <code>
             byte[] working = new byte[WORKING_BUFFER_SIZE];
             using (System.IO.Stream input = System.IO.File.OpenRead(_CompressedFile))
             {
                 using (Stream decompressor= new Ionic.Zlib.GZipStream(input, CompressionMode.Decompress, true))
                 {
                     using (var output = System.IO.File.Create(_DecompressedFile))
                     {
                         int n;
                         while ((n= decompressor.Read(working, 0, working.Length)) !=0)
                         {
                             output.Write(working, 0, n);
                         }
                     }
                 }
             }
             </code>
             </example>
             <param name="buffer">The buffer into which the decompressed data should be placed.</param>
             <param name="offset">the offset within that data array to put the first byte read.</param>
             <param name="count">the number of bytes to read.</param>
             <returns>the number of bytes actually read</returns>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
              Calling this method always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
            <param name="offset">irrelevant; it will always throw!</param>
            <param name="origin">irrelevant; it will always throw!</param>
            <returns>irrelevant!</returns>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.SetLength(System.Int64)">
            <summary>
              Calling this method always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
            <param name="value">irrelevant; this method will always throw!</param>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.Write(System.Byte[],System.Int32,System.Int32)">
             <summary>
               Write data to the stream.
             </summary>
            
             <remarks>
             <para>
               If you wish to use the <c>GZipStream</c> to compress data while writing,
               you can create a <c>GZipStream</c> with <c>CompressionMode.Compress</c>, and a
               writable output stream.  Then call <c>Write()</c> on that <c>GZipStream</c>,
               providing uncompressed data as input.  The data sent to the output stream
               will be the compressed form of the data written.
             </para>
            
             <para>
               A <c>GZipStream</c> can be used for <c>Read()</c> or <c>Write()</c>, but not
               both. Writing implies compression.  Reading implies decompression.
             </para>
            
             </remarks>
             <param name="buffer">The buffer holding data to write to the stream.</param>
             <param name="offset">the offset within that data array to find the first byte to write.</param>
             <param name="count">the number of bytes to write.</param>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.CompressString(System.String)">
             <summary>
               Compress a string into a byte array using GZip.
             </summary>
            
             <remarks>
               Uncompress it with <see cref="M:Ionic.Zlib.GZipStream.UncompressString(System.Byte[])"/>.
             </remarks>
            
             <seealso cref="M:Ionic.Zlib.GZipStream.UncompressString(System.Byte[])"/>
             <seealso cref="M:Ionic.Zlib.GZipStream.CompressBuffer(System.Byte[])"/>
            
             <param name="s">
               A string to compress. The string will first be encoded
               using UTF8, then compressed.
             </param>
            
             <returns>The string in compressed form</returns>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.CompressBuffer(System.Byte[])">
             <summary>
               Compress a byte array into a new byte array using GZip.
             </summary>
            
             <remarks>
               Uncompress it with <see cref="M:Ionic.Zlib.GZipStream.UncompressBuffer(System.Byte[])"/>.
             </remarks>
            
             <seealso cref="M:Ionic.Zlib.GZipStream.CompressString(System.String)"/>
             <seealso cref="M:Ionic.Zlib.GZipStream.UncompressBuffer(System.Byte[])"/>
            
             <param name="b">
               A buffer to compress.
             </param>
            
             <returns>The data in compressed form</returns>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.UncompressString(System.Byte[])">
             <summary>
               Uncompress a GZip'ed byte array into a single string.
             </summary>
            
             <seealso cref="M:Ionic.Zlib.GZipStream.CompressString(System.String)"/>
             <seealso cref="M:Ionic.Zlib.GZipStream.UncompressBuffer(System.Byte[])"/>
            
             <param name="compressed">
               A buffer containing GZIP-compressed data.
             </param>
            
             <returns>The uncompressed string</returns>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.UncompressBuffer(System.Byte[])">
             <summary>
               Uncompress a GZip'ed byte array into a byte array.
             </summary>
            
             <seealso cref="M:Ionic.Zlib.GZipStream.CompressBuffer(System.Byte[])"/>
             <seealso cref="M:Ionic.Zlib.GZipStream.UncompressString(System.Byte[])"/>
            
             <param name="compressed">
               A buffer containing data that has been compressed with GZip.
             </param>
            
             <returns>The data in uncompressed form</returns>
        </member>
        <member name="T:Ionic.Zlib.ParallelDeflateOutputStream">
             <summary>
               A class for compressing streams using the
               Deflate algorithm with multiple threads.
             </summary>
            
             <remarks>
             <para>
               This class performs DEFLATE compression through writing.  For
               more information on the Deflate algorithm, see IETF RFC 1951,
               "DEFLATE Compressed Data Format Specification version 1.3."
             </para>
            
             <para>
               This class is similar to <see cref="T:Ionic.Zlib.DeflateStream"/>, except
               that this class is for compression only, and this implementation uses an
               approach that employs multiple worker threads to perform the DEFLATE.  On
               a multi-cpu or multi-core computer, the performance of this class can be
               significantly higher than the single-threaded DeflateStream, particularly
               for larger streams.  How large?  Anything over 10mb is a good candidate
               for parallel compression.
             </para>
            
             <para>
               The tradeoff is that this class uses more memory and more CPU than the
               vanilla DeflateStream, and also is less efficient as a compressor. For
               large files the size of the compressed data stream can be less than 1%
               larger than the size of a compressed data stream from the vanialla
               DeflateStream.  For smaller files the difference can be larger.  The
               difference will also be larger if you set the BufferSize to be lower than
               the default value.  Your mileage may vary. Finally, for small files, the
               ParallelDeflateOutputStream can be much slower than the vanilla
               DeflateStream, because of the overhead associated to using the thread
               pool.
             </para>
            
             </remarks>
             <seealso cref="T:Ionic.Zlib.DeflateStream" />
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.#ctor(System.IO.Stream)">
             <summary>
             Create a ParallelDeflateOutputStream.
             </summary>
             <remarks>
            
             <para>
               This stream compresses data written into it via the DEFLATE
               algorithm (see RFC 1951), and writes out the compressed byte stream.
             </para>
            
             <para>
               The instance will use the default compression level, the default
               buffer sizes and the default number of threads and buffers per
               thread.
             </para>
            
             <para>
               This class is similar to <see cref="T:Ionic.Zlib.DeflateStream"/>,
               except that this implementation uses an approach that employs
               multiple worker threads to perform the DEFLATE.  On a multi-cpu or
               multi-core computer, the performance of this class can be
               significantly higher than the single-threaded DeflateStream,
               particularly for larger streams.  How large?  Anything over 10mb is
               a good candidate for parallel compression.
             </para>
            
             </remarks>
            
             <example>
            
             This example shows how to use a ParallelDeflateOutputStream to compress
             data.  It reads a file, compresses it, and writes the compressed data to
             a second, output file.
            
             <code>
             byte[] buffer = new byte[WORKING_BUFFER_SIZE];
             int n= -1;
             String outputFile = fileToCompress + ".compressed";
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(outputFile))
                 {
                     using (Stream compressor = new ParallelDeflateOutputStream(raw))
                     {
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code>
             <code lang="VB">
             Dim buffer As Byte() = New Byte(4096) {}
             Dim n As Integer = -1
             Dim outputFile As String = (fileToCompress &amp; ".compressed")
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(outputFile)
                     Using compressor As Stream = New ParallelDeflateOutputStream(raw)
                         Do While (n &lt;&gt; 0)
                             If (n &gt; 0) Then
                                 compressor.Write(buffer, 0, n)
                             End If
                             n = input.Read(buffer, 0, buffer.Length)
                         Loop
                     End Using
                 End Using
             End Using
             </code>
             </example>
             <param name="stream">The stream to which compressed data will be written.</param>
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionLevel)">
            <summary>
              Create a ParallelDeflateOutputStream using the specified CompressionLevel.
            </summary>
            <remarks>
              See the <see cref="M:Ionic.Zlib.ParallelDeflateOutputStream.#ctor(System.IO.Stream)"/>
              constructor for example code.
            </remarks>
            <param name="stream">The stream to which compressed data will be written.</param>
            <param name="level">A tuning knob to trade speed for effectiveness.</param>
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.#ctor(System.IO.Stream,System.Boolean)">
            <summary>
            Create a ParallelDeflateOutputStream and specify whether to leave the captive stream open
            when the ParallelDeflateOutputStream is closed.
            </summary>
            <remarks>
              See the <see cref="M:Ionic.Zlib.ParallelDeflateOutputStream.#ctor(System.IO.Stream)"/>
              constructor for example code.
            </remarks>
            <param name="stream">The stream to which compressed data will be written.</param>
            <param name="leaveOpen">
               true if the application would like the stream to remain open after inflation/deflation.
            </param>
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionLevel,System.Boolean)">
            <summary>
            Create a ParallelDeflateOutputStream and specify whether to leave the captive stream open
            when the ParallelDeflateOutputStream is closed.
            </summary>
            <remarks>
              See the <see cref="M:Ionic.Zlib.ParallelDeflateOutputStream.#ctor(System.IO.Stream)"/>
              constructor for example code.
            </remarks>
            <param name="stream">The stream to which compressed data will be written.</param>
            <param name="level">A tuning knob to trade speed for effectiveness.</param>
            <param name="leaveOpen">
               true if the application would like the stream to remain open after inflation/deflation.
            </param>
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionLevel,Ionic.Zlib.CompressionStrategy,System.Boolean)">
            <summary>
            Create a ParallelDeflateOutputStream using the specified
            CompressionLevel and CompressionStrategy, and specifying whether to
            leave the captive stream open when the ParallelDeflateOutputStream is
            closed.
            </summary>
            <remarks>
              See the <see cref="M:Ionic.Zlib.ParallelDeflateOutputStream.#ctor(System.IO.Stream)"/>
              constructor for example code.
            </remarks>
            <param name="stream">The stream to which compressed data will be written.</param>
            <param name="level">A tuning knob to trade speed for effectiveness.</param>
            <param name="strategy">
              By tweaking this parameter, you may be able to optimize the compression for
              data with particular characteristics.
            </param>
            <param name="leaveOpen">
               true if the application would like the stream to remain open after inflation/deflation.
            </param>
        </member>
        <member name="P:Ionic.Zlib.ParallelDeflateOutputStream.Strategy">
             <summary>
               The ZLIB strategy to be used during compression.
             </summary>
            
        </member>
        <member name="P:Ionic.Zlib.ParallelDeflateOutputStream.MaxBufferPairs">
             <summary>
               The maximum number of buffer pairs to use.
             </summary>
            
             <remarks>
             <para>
               This property sets an upper limit on the number of memory buffer
               pairs to create.  The implementation of this stream allocates
               multiple buffers to facilitate parallel compression.  As each buffer
               fills up, this stream uses <see
               cref="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)">
               ThreadPool.QueueUserWorkItem()</see>
               to compress those buffers in a background threadpool thread. After a
               buffer is compressed, it is re-ordered and written to the output
               stream.
             </para>
            
             <para>
               A higher number of buffer pairs enables a higher degree of
               parallelism, which tends to increase the speed of compression on
               multi-cpu computers.  On the other hand, a higher number of buffer
               pairs also implies a larger memory consumption, more active worker
               threads, and a higher cpu utilization for any compression. This
               property enables the application to limit its memory consumption and
               CPU utilization behavior depending on requirements.
             </para>
            
             <para>
               For each compression "task" that occurs in parallel, there are 2
               buffers allocated: one for input and one for output.  This property
               sets a limit for the number of pairs.  The total amount of storage
               space allocated for buffering will then be (N*S*2), where N is the
               number of buffer pairs, S is the size of each buffer (<see
               cref="P:Ionic.Zlib.ParallelDeflateOutputStream.BufferSize"/>).  By default, DotNetZip allocates 4 buffer
               pairs per CPU core, so if your machine has 4 cores, and you retain
               the default buffer size of 128k, then the
               ParallelDeflateOutputStream will use 4 * 4 * 2 * 128kb of buffer
               memory in total, or 4mb, in blocks of 128kb.  If you then set this
               property to 8, then the number will be 8 * 2 * 128kb of buffer
               memory, or 2mb.
             </para>
            
             <para>
               CPU utilization will also go up with additional buffers, because a
               larger number of buffer pairs allows a larger number of background
               threads to compress in parallel. If you find that parallel
               compression is consuming too much memory or CPU, you can adjust this
               value downward.
             </para>
            
             <para>
               The default value is 16. Different values may deliver better or
               worse results, depending on your priorities and the dynamic
               performance characteristics of your storage and compute resources.
             </para>
            
             <para>
               This property is not the number of buffer pairs to use; it is an
               upper limit. An illustration: Suppose you have an application that
               uses the default value of this property (which is 16), and it runs
               on a machine with 2 CPU cores. In that case, DotNetZip will allocate
               4 buffer pairs per CPU core, for a total of 8 pairs.  The upper
               limit specified by this property has no effect.
             </para>
            
             <para>
               The application can set this value at any time, but it is effective
               only before the first call to Write(), which is when the buffers are
               allocated.
             </para>
             </remarks>
        </member>
        <member name="P:Ionic.Zlib.ParallelDeflateOutputStream.BufferSize">
             <summary>
               The size of the buffers used by the compressor threads.
             </summary>
             <remarks>
            
             <para>
               The default buffer size is 128k. The application can set this value
               at any time, but it is effective only before the first Write().
             </para>
            
             <para>
               Larger buffer sizes implies larger memory consumption but allows
               more efficient compression. Using smaller buffer sizes consumes less
               memory but may result in less effective compression.  For example,
               using the default buffer size of 128k, the compression delivered is
               within 1% of the compression delivered by the single-threaded <see
               cref="T:Ionic.Zlib.DeflateStream"/>.  On the other hand, using a
               BufferSize of 8k can result in a compressed data stream that is 5%
               larger than that delivered by the single-threaded
               <c>DeflateStream</c>.  Excessively small buffer sizes can also cause
               the speed of the ParallelDeflateOutputStream to drop, because of
               larger thread scheduling overhead dealing with many many small
               buffers.
             </para>
            
             <para>
               The total amount of storage space allocated for buffering will be
               (N*S*2), where N is the number of buffer pairs, and S is the size of
               each buffer (this property). There are 2 buffers used by the
               compressor, one for input and one for output.  By default, DotNetZip
               allocates 4 buffer pairs per CPU core, so if your machine has 4
               cores, then the number of buffer pairs used will be 16. If you
               accept the default value of this property, 128k, then the
               ParallelDeflateOutputStream will use 16 * 2 * 128kb of buffer memory
               in total, or 4mb, in blocks of 128kb.  If you set this property to
               64kb, then the number will be 16 * 2 * 64kb of buffer memory, or
               2mb.
             </para>
            
             </remarks>
        </member>
        <member name="P:Ionic.Zlib.ParallelDeflateOutputStream.Crc32">
            <summary>
            The CRC32 for the data that was written out, prior to compression.
            </summary>
            <remarks>
            This value is meaningful only after a call to Close().
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.ParallelDeflateOutputStream.BytesProcessed">
            <summary>
            The total number of uncompressed bytes processed by the ParallelDeflateOutputStream.
            </summary>
            <remarks>
            This value is meaningful only after a call to Close().
            </remarks>
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.Write(System.Byte[],System.Int32,System.Int32)">
             <summary>
               Write data to the stream.
             </summary>
            
             <remarks>
            
             <para>
               To use the ParallelDeflateOutputStream to compress data, create a
               ParallelDeflateOutputStream with CompressionMode.Compress, passing a
               writable output stream.  Then call Write() on that
               ParallelDeflateOutputStream, providing uncompressed data as input.  The
               data sent to the output stream will be the compressed form of the data
               written.
             </para>
            
             <para>
               To decompress data, use the <see cref="T:Ionic.Zlib.DeflateStream"/> class.
             </para>
            
             </remarks>
             <param name="buffer">The buffer holding data to write to the stream.</param>
             <param name="offset">the offset within that data array to find the first byte to write.</param>
             <param name="count">the number of bytes to write.</param>
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.Flush">
            <summary>
            Flush the stream.
            </summary>
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.Close">
            <summary>
            Close the stream.
            </summary>
            <remarks>
            You must call Close on the stream to guarantee that all of the data written in has
            been compressed, and the compressed data has been written out.
            </remarks>
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.Dispose">
            <summary>Dispose the object</summary>
            <remarks>
              <para>
                Because ParallelDeflateOutputStream is IDisposable, the
                application must call this method when finished using the instance.
              </para>
              <para>
                This method is generally called implicitly upon exit from
                a <c>using</c> scope in C# (<c>Using</c> in VB).
              </para>
            </remarks>
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.Dispose(System.Boolean)">
            <summary>The Dispose method</summary>
            <param name="disposing">
              indicates whether the Dispose method was invoked by user code.
            </param>
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.Reset(System.IO.Stream)">
             <summary>
               Resets the stream for use with another stream.
             </summary>
             <remarks>
               Because the ParallelDeflateOutputStream is expensive to create, it
               has been designed so that it can be recycled and re-used.  You have
               to call Close() on the stream first, then you can call Reset() on
               it, to use it again on another stream.
             </remarks>
            
             <param name="stream">
               The new output stream for this era.
             </param>
            
             <example>
             <code>
             ParallelDeflateOutputStream deflater = null;
             foreach (var inputFile in listOfFiles)
             {
                 string outputFile = inputFile + ".compressed";
                 using (System.IO.Stream input = System.IO.File.OpenRead(inputFile))
                 {
                     using (var outStream = System.IO.File.Create(outputFile))
                     {
                         if (deflater == null)
                             deflater = new ParallelDeflateOutputStream(outStream,
                                                                        CompressionLevel.Best,
                                                                        CompressionStrategy.Default,
                                                                        true);
                         deflater.Reset(outStream);
            
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             deflater.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code>
             </example>
        </member>
        <member name="P:Ionic.Zlib.ParallelDeflateOutputStream.CanSeek">
            <summary>
            Indicates whether the stream supports Seek operations.
            </summary>
            <remarks>
            Always returns false.
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.ParallelDeflateOutputStream.CanRead">
            <summary>
            Indicates whether the stream supports Read operations.
            </summary>
            <remarks>
            Always returns false.
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.ParallelDeflateOutputStream.CanWrite">
            <summary>
            Indicates whether the stream supports Write operations.
            </summary>
            <remarks>
            Returns true if the provided stream is writable.
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.ParallelDeflateOutputStream.Length">
            <summary>
            Reading this property always throws a NotSupportedException.
            </summary>
        </member>
        <member name="P:Ionic.Zlib.ParallelDeflateOutputStream.Position">
            <summary>
            Returns the current position of the output stream.
            </summary>
            <remarks>
              <para>
                Because the output gets written by a background thread,
                the value may change asynchronously.  Setting this
                property always throws a NotSupportedException.
              </para>
            </remarks>
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            This method always throws a NotSupportedException.
            </summary>
            <param name="buffer">
              The buffer into which data would be read, IF THIS METHOD
              ACTUALLY DID ANYTHING.
            </param>
            <param name="offset">
              The offset within that data array at which to insert the
              data that is read, IF THIS METHOD ACTUALLY DID
              ANYTHING.
            </param>
            <param name="count">
              The number of bytes to write, IF THIS METHOD ACTUALLY DID
              ANYTHING.
            </param>
            <returns>nothing.</returns>
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            This method always throws a NotSupportedException.
            </summary>
            <param name="offset">
              The offset to seek to....
              IF THIS METHOD ACTUALLY DID ANYTHING.
            </param>
            <param name="origin">
              The reference specifying how to apply the offset....  IF
              THIS METHOD ACTUALLY DID ANYTHING.
            </param>
            <returns>nothing. It always throws.</returns>
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.SetLength(System.Int64)">
            <summary>
            This method always throws a NotSupportedException.
            </summary>
            <param name="value">
              The new value for the stream length....  IF
              THIS METHOD ACTUALLY DID ANYTHING.
            </param>
        </member>
        <member name="T:Ionic.Zip.WriteDelegate">
             <summary>
               Delegate in which the application writes the <c>ZipEntry</c> content for the named entry.
             </summary>
            
             <param name="entryName">The name of the entry that must be written.</param>
             <param name="stream">The stream to which the entry data should be written.</param>
            
             <remarks>
               When you add an entry and specify a <c>WriteDelegate</c>, via <see
               cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,Ionic.Zip.WriteDelegate)"/>, the application
               code provides the logic that writes the entry data directly into the zip file.
             </remarks>
            
             <example>
            
             This example shows how to define a WriteDelegate that obtains a DataSet, and then
             writes the XML for the DataSet into the zip archive.  There's no need to
             save the XML to a disk file first.
            
             <code lang="C#">
             private void WriteEntry (String filename, Stream output)
             {
                 DataSet ds1 = ObtainDataSet();
                 ds1.WriteXml(output);
             }
            
             private void Run()
             {
                 using (var zip = new ZipFile())
                 {
                     zip.AddEntry(zipEntryName, WriteEntry);
                     zip.Save(zipFileName);
                 }
             }
             </code>
            
             <code lang="vb">
             Private Sub WriteEntry (ByVal filename As String, ByVal output As Stream)
                 DataSet ds1 = ObtainDataSet()
                 ds1.WriteXml(stream)
             End Sub
            
             Public Sub Run()
                 Using zip = New ZipFile
                     zip.AddEntry(zipEntryName, New WriteDelegate(AddressOf WriteEntry))
                     zip.Save(zipFileName)
                 End Using
             End Sub
             </code>
             </example>
             <seealso cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,Ionic.Zip.WriteDelegate)"/>
        </member>
        <member name="T:Ionic.Zip.OpenDelegate">
             <summary>
               Delegate in which the application opens the stream, just-in-time, for the named entry.
             </summary>
            
             <param name="entryName">
             The name of the ZipEntry that the application should open the stream for.
             </param>
            
             <remarks>
               When you add an entry via <see cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,Ionic.Zip.OpenDelegate,Ionic.Zip.CloseDelegate)"/>, the application code provides the logic that
               opens and closes the stream for the given ZipEntry.
             </remarks>
            
             <seealso cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,Ionic.Zip.OpenDelegate,Ionic.Zip.CloseDelegate)"/>
        </member>
        <member name="T:Ionic.Zip.CloseDelegate">
             <summary>
               Delegate in which the application closes the stream, just-in-time, for the named entry.
             </summary>
            
             <param name="entryName">
             The name of the ZipEntry that the application should close the stream for.
             </param>
            
             <param name="stream">The stream to be closed.</param>
            
             <remarks>
               When you add an entry via <see cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,Ionic.Zip.OpenDelegate,Ionic.Zip.CloseDelegate)"/>, the application code provides the logic that
               opens and closes the stream for the given ZipEntry.
             </remarks>
            
             <seealso cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,Ionic.Zip.OpenDelegate,Ionic.Zip.CloseDelegate)"/>
        </member>
        <member name="T:Ionic.Zip.SetCompressionCallback">
             <summary>
               Delegate for the callback by which the application tells the
               library the CompressionLevel to use for a file.
             </summary>
            
             <remarks>
             <para>
               Using this callback, the application can, for example, specify that
               previously-compressed files (.mp3, .png, .docx, etc) should use a
               <c>CompressionLevel</c> of <c>None</c>, or can set the compression level based
               on any other factor.
             </para>
             </remarks>
             <seealso cref="P:Ionic.Zip.ZipFile.SetCompression"/>
        </member>
        <member name="T:Ionic.Zip.ZipProgressEventType">
            <summary>
              In an EventArgs type, indicates which sort of progress event is being
              reported.
            </summary>
            <remarks>
              There are events for reading, events for saving, and events for
              extracting. This enumeration allows a single EventArgs type to be sued to
              describe one of multiple subevents. For example, a SaveProgress event is
              invoked before, after, and during the saving of a single entry.  The value
              of an enum with this type, specifies which event is being triggered.  The
              same applies to Extraction, Reading and Adding events.
            </remarks>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Adding_Started">
            <summary>
            Indicates that a Add() operation has started.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Adding_AfterAddEntry">
            <summary>
            Indicates that an individual entry in the archive has been added.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Adding_Completed">
            <summary>
            Indicates that a Add() operation has completed.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Reading_Started">
            <summary>
            Indicates that a Read() operation has started.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Reading_BeforeReadEntry">
            <summary>
            Indicates that an individual entry in the archive is about to be read.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Reading_AfterReadEntry">
            <summary>
            Indicates that an individual entry in the archive has just been read.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Reading_Completed">
            <summary>
            Indicates that a Read() operation has completed.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Reading_ArchiveBytesRead">
            <summary>
            The given event reports the number of bytes read so far
            during a Read() operation.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Saving_Started">
            <summary>
            Indicates that a Save() operation has started.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Saving_BeforeWriteEntry">
            <summary>
            Indicates that an individual entry in the archive is about to be written.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Saving_AfterWriteEntry">
            <summary>
            Indicates that an individual entry in the archive has just been saved.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Saving_Completed">
            <summary>
            Indicates that a Save() operation has completed.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Saving_AfterSaveTempArchive">
            <summary>
            Indicates that the zip archive has been created in a
            temporary location during a Save() operation.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Saving_BeforeRenameTempArchive">
            <summary>
            Indicates that the temporary file is about to be renamed to the final archive
            name during a Save() operation.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Saving_AfterRenameTempArchive">
            <summary>
            Indicates that the temporary file is has just been renamed to the final archive
            name during a Save() operation.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Saving_AfterCompileSelfExtractor">
            <summary>
            Indicates that the self-extracting archive has been compiled
            during a Save() operation.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Saving_EntryBytesRead">
            <summary>
            The given event is reporting the number of source bytes that have run through the compressor so far
            during a Save() operation.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Extracting_BeforeExtractEntry">
            <summary>
            Indicates that an entry is about to be extracted.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Extracting_AfterExtractEntry">
            <summary>
            Indicates that an entry has just been extracted.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Extracting_ExtractEntryWouldOverwrite">
            <summary>
              Indicates that extraction of an entry would overwrite an existing
              filesystem file. You must use
              <see cref="F:Ionic.Zip.ExtractExistingFileAction.InvokeExtractProgressEvent">
              ExtractExistingFileAction.InvokeExtractProgressEvent</see> in the call
              to <c>ZipEntry.Extract()</c> in order to receive this event.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Extracting_EntryBytesWritten">
            <summary>
              The given event is reporting the number of bytes written so far for
              the current entry during an Extract() operation.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Extracting_BeforeExtractAll">
            <summary>
            Indicates that an ExtractAll operation is about to begin.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Extracting_AfterExtractAll">
            <summary>
            Indicates that an ExtractAll operation has completed.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Error_Saving">
            <summary>
            Indicates that an error has occurred while saving a zip file.
            This generally means the file cannot be opened, because it has been
            removed, or because it is locked by another process.  It can also
            mean that the file cannot be Read, because of a range lock conflict.
            </summary>
        </member>
        <member name="T:Ionic.Zip.ZipProgressEventArgs">
            <summary>
            Provides information about the progress of a save, read, or extract operation.
            This is a base class; you will probably use one of the classes derived from this one.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipProgressEventArgs.EntriesTotal">
            <summary>
            The total number of entries to be saved or extracted.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipProgressEventArgs.CurrentEntry">
            <summary>
            The name of the last entry saved or extracted.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipProgressEventArgs.Cancel">
            <summary>
            In an event handler, set this to cancel the save or extract
            operation that is in progress.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipProgressEventArgs.EventType">
            <summary>
            The type of event being reported.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipProgressEventArgs.ArchiveName">
            <summary>
            Returns the archive name associated to this event.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipProgressEventArgs.BytesTransferred">
            <summary>
            The number of bytes read or written so far for this entry.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipProgressEventArgs.TotalBytesToTransfer">
            <summary>
            Total number of bytes that will be read or written for this entry.
            This number will be -1 if the value cannot be determined.
            </summary>
        </member>
        <member name="T:Ionic.Zip.ReadProgressEventArgs">
            <summary>
            Provides information about the progress of a Read operation.
            </summary>
        </member>
        <member name="T:Ionic.Zip.AddProgressEventArgs">
            <summary>
            Provides information about the progress of a Add operation.
            </summary>
        </member>
        <member name="T:Ionic.Zip.SaveProgressEventArgs">
            <summary>
            Provides information about the progress of a save operation.
            </summary>
        </member>
        <member name="M:Ionic.Zip.SaveProgressEventArgs.#ctor(System.String,System.Boolean,System.Int32,System.Int32,Ionic.Zip.ZipEntry)">
            <summary>
            Constructor for the SaveProgressEventArgs.
            </summary>
            <param name="archiveName">the name of the zip archive.</param>
            <param name="before">whether this is before saving the entry, or after</param>
            <param name="entriesTotal">The total number of entries in the zip archive.</param>
            <param name="entriesSaved">Number of entries that have been saved.</param>
            <param name="entry">The entry involved in the event.</param>
        </member>
        <member name="P:Ionic.Zip.SaveProgressEventArgs.EntriesSaved">
            <summary>
            Number of entries saved so far.
            </summary>
        </member>
        <member name="T:Ionic.Zip.ExtractProgressEventArgs">
            <summary>
            Provides information about the progress of the extract operation.
            </summary>
        </member>
        <member name="M:Ionic.Zip.ExtractProgressEventArgs.#ctor(System.String,System.Boolean,System.Int32,System.Int32,Ionic.Zip.ZipEntry,System.String)">
            <summary>
            Constructor for the ExtractProgressEventArgs.
            </summary>
            <param name="archiveName">the name of the zip archive.</param>
            <param name="before">whether this is before saving the entry, or after</param>
            <param name="entriesTotal">The total number of entries in the zip archive.</param>
            <param name="entriesExtracted">Number of entries that have been extracted.</param>
            <param name="entry">The entry involved in the event.</param>
            <param name="extractLocation">The location to which entries are extracted.</param>
        </member>
        <member name="P:Ionic.Zip.ExtractProgressEventArgs.EntriesExtracted">
            <summary>
            Number of entries extracted so far.  This is set only if the
            EventType is Extracting_BeforeExtractEntry or Extracting_AfterExtractEntry, and
            the Extract() is occurring witin the scope of a call to ExtractAll().
            </summary>
        </member>
        <member name="P:Ionic.Zip.ExtractProgressEventArgs.ExtractLocation">
            <summary>
            Returns the extraction target location, a filesystem path.
            </summary>
        </member>
        <member name="T:Ionic.Zip.ZipErrorEventArgs">
            <summary>
            Provides information about the an error that occurred while zipping.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipErrorEventArgs.Exception">
            <summary>
            Returns the exception that occurred, if any.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipErrorEventArgs.FileName">
            <summary>
            Returns the name of the file that caused the exception, if any.
            </summary>
        </member>
        <member name="T:Ionic.Zip.BadPasswordException">
            <summary>
            Issued when an <c>ZipEntry.ExtractWithPassword()</c> method is invoked
            with an incorrect password.
            </summary>
        </member>
        <member name="M:Ionic.Zip.BadPasswordException.#ctor">
            <summary>
            Default ctor.
            </summary>
        </member>
        <member name="M:Ionic.Zip.BadPasswordException.#ctor(System.String)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="message">The message in the exception.</param>
        </member>
        <member name="M:Ionic.Zip.BadPasswordException.#ctor(System.String,System.Exception)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="message">The message in the exception.</param>
            <param name="innerException">The innerException for this exception.</param>
        </member>
        <member name="M:Ionic.Zip.BadPasswordException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="info">The serialization info for the exception.</param>
            <param name="context">The streaming context from which to deserialize.</param>
        </member>
        <member name="T:Ionic.Zip.BadReadException">
            <summary>
            Indicates that a read was attempted on a stream, and bad or incomplete data was
            received.
            </summary>
        </member>
        <member name="M:Ionic.Zip.BadReadException.#ctor">
            <summary>
            Default ctor.
            </summary>
        </member>
        <member name="M:Ionic.Zip.BadReadException.#ctor(System.String)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="message">The message in the exception.</param>
        </member>
        <member name="M:Ionic.Zip.BadReadException.#ctor(System.String,System.Exception)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="message">The message in the exception.</param>
            <param name="innerException">The innerException for this exception.</param>
        </member>
        <member name="M:Ionic.Zip.BadReadException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="info">The serialization info for the exception.</param>
            <param name="context">The streaming context from which to deserialize.</param>
        </member>
        <member name="T:Ionic.Zip.BadCrcException">
            <summary>
            Issued when an CRC check fails upon extracting an entry from a zip archive.
            </summary>
        </member>
        <member name="M:Ionic.Zip.BadCrcException.#ctor">
            <summary>
            Default ctor.
            </summary>
        </member>
        <member name="M:Ionic.Zip.BadCrcException.#ctor(System.String)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="message">The message in the exception.</param>
        </member>
        <member name="M:Ionic.Zip.BadCrcException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="info">The serialization info for the exception.</param>
            <param name="context">The streaming context from which to deserialize.</param>
        </member>
        <member name="T:Ionic.Zip.SfxGenerationException">
            <summary>
            Issued when errors occur saving a self-extracting archive.
            </summary>
        </member>
        <member name="M:Ionic.Zip.SfxGenerationException.#ctor">
            <summary>
            Default ctor.
            </summary>
        </member>
        <member name="M:Ionic.Zip.SfxGenerationException.#ctor(System.String)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="message">The message in the exception.</param>
        </member>
        <member name="M:Ionic.Zip.SfxGenerationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="info">The serialization info for the exception.</param>
            <param name="context">The streaming context from which to deserialize.</param>
        </member>
        <member name="T:Ionic.Zip.BadStateException">
            <summary>
            Indicates that an operation was attempted on a ZipFile which was not possible
            given the state of the instance. For example, if you call <c>Save()</c> on a ZipFile
            which has no filename set, you can get this exception.
            </summary>
        </member>
        <member name="M:Ionic.Zip.BadStateException.#ctor">
            <summary>
            Default ctor.
            </summary>
        </member>
        <member name="M:Ionic.Zip.BadStateException.#ctor(System.String)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="message">The message in the exception.</param>
        </member>
        <member name="M:Ionic.Zip.BadStateException.#ctor(System.String,System.Exception)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="message">The message in the exception.</param>
            <param name="innerException">The innerException for this exception.</param>
        </member>
        <member name="M:Ionic.Zip.BadStateException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="info">The serialization info for the exception.</param>
            <param name="context">The streaming context from which to deserialize.</param>
        </member>
        <member name="T:Ionic.Zip.ZipException">
            <summary>
            Base class for all exceptions defined by and throw by the Zip library.
            </summary>
        </member>
        <member name="M:Ionic.Zip.ZipException.#ctor">
            <summary>
            Default ctor.
            </summary>
        </member>
        <member name="M:Ionic.Zip.ZipException.#ctor(System.String)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="message">The message in the exception.</param>
        </member>
        <member name="M:Ionic.Zip.ZipException.#ctor(System.String,System.Exception)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="message">The message in the exception.</param>
            <param name="innerException">The innerException for this exception.</param>
        </member>
        <member name="M:Ionic.Zip.ZipException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="info">The serialization info for the exception.</param>
            <param name="context">The streaming context from which to deserialize.</param>
        </member>
        <member name="T:Ionic.Zip.SharedUtilities">
            <summary>
            Collects general purpose utility methods.
            </summary>
        </member>
        <member name="M:Ionic.Zip.SharedUtilities.GetFileLength(System.String)">
            private null constructor
        </member>
        <member name="M:Ionic.Zip.SharedUtilities.NormalizePathForUseInZipFile(System.String)">
            <summary>
            Utility routine for transforming path names from filesystem format (on Windows that means backslashes) to
            a format suitable for use within zipfiles. This means trimming the volume letter and colon (if any) And
            swapping backslashes for forward slashes.
            </summary>
            <param name="pathName">source path.</param>
            <returns>transformed path</returns>
        </member>
        <member name="M:Ionic.Zip.SharedUtilities.FindSignature(System.IO.Stream,System.Int32)">
             <summary>
               Finds a signature in the zip stream. This is useful for finding
               the end of a zip entry, for example, or the beginning of the next ZipEntry.
             </summary>
            
             <remarks>
               <para>
                 Scans through 64k at a time.
               </para>
            
               <para>
                 If the method fails to find the requested signature, the stream Position
                 after completion of this method is unchanged. If the method succeeds in
                 finding the requested signature, the stream position after completion is
                 direct AFTER the signature found in the stream.
               </para>
             </remarks>
            
             <param name="stream">The stream to search</param>
             <param name="SignatureToFind">The 4-byte signature to find</param>
             <returns>The number of bytes read</returns>
        </member>
        <member name="M:Ionic.Zip.SharedUtilities.CreateAndOpenUniqueTempFile(System.String,System.IO.Stream@,System.String@)">
            <summary>
              Create a pseudo-random filename, suitable for use as a temporary
              file, and open it.
            </summary>
            <remarks>
            <para>
              The System.IO.Path.GetRandomFileName() method is not available on
              the Compact Framework, so this library provides its own substitute
              on NETCF.
            </para>
            <para>
              This method produces a filename of the form
              DotNetZip-xxxxxxxx.tmp, where xxxxxxxx is replaced by randomly
              chosen characters, and creates that file.
            </para>
            </remarks>
        </member>
        <member name="M:Ionic.Zip.SharedUtilities.ReadWithRetry(System.IO.Stream,System.Byte[],System.Int32,System.Int32,System.String)">
            <summary>
            Workitem 7889: handle ERROR_LOCK_VIOLATION during read
            </summary>
            <remarks>
            This could be gracefully handled with an extension attribute, but
            This assembly is built for .NET 2.0, so I cannot use them.
            </remarks>
        </member>
        <member name="T:Ionic.Zip.CountingStream">
            <summary>
              A decorator stream. It wraps another stream, and performs bookkeeping
              to keep track of the stream Position.
            </summary>
            <remarks>
              <para>
                In some cases, it is not possible to get the Position of a stream, let's
                say, on a write-only output stream like ASP.NET's
                <c>Response.OutputStream</c>, or on a different write-only stream
                provided as the destination for the zip by the application.  In this
                case, programmers can use this counting stream to count the bytes read
                or written.
              </para>
              <para>
                Consider the scenario of an application that saves a self-extracting
                archive (SFX), that uses a custom SFX stub.
              </para>
              <para>
                Saving to a filesystem file, the application would open the
                filesystem file (getting a <c>FileStream</c>), save the custom sfx stub
                into it, and then call <c>ZipFile.Save()</c>, specifying the same
                FileStream. <c>ZipFile.Save()</c> does the right thing for the zipentry
                offsets, by inquiring the Position of the <c>FileStream</c> before writing
                any data, and then adding that initial offset into any ZipEntry
                offsets in the zip directory. Everything works fine.
              </para>
              <para>
                Now suppose the application is an ASPNET application and it saves
                directly to <c>Response.OutputStream</c>. It's not possible for DotNetZip to
                inquire the <c>Position</c>, so the offsets for the SFX will be wrong.
              </para>
              <para>
                The workaround is for the application to use this class to wrap
                <c>HttpResponse.OutputStream</c>, then write the SFX stub and the ZipFile
                into that wrapper stream. Because <c>ZipFile.Save()</c> can inquire the
                <c>Position</c>, it will then do the right thing with the offsets.
              </para>
            </remarks>
        </member>
        <member name="M:Ionic.Zip.CountingStream.#ctor(System.IO.Stream)">
            <summary>
            The constructor.
            </summary>
            <param name="stream">The underlying stream</param>
        </member>
        <member name="P:Ionic.Zip.CountingStream.WrappedStream">
            <summary>
              Gets the wrapped stream.
            </summary>
        </member>
        <member name="P:Ionic.Zip.CountingStream.BytesWritten">
            <summary>
              The count of bytes written out to the stream.
            </summary>
        </member>
        <member name="P:Ionic.Zip.CountingStream.BytesRead">
            <summary>
              the count of bytes that have been read from the stream.
            </summary>
        </member>
        <member name="M:Ionic.Zip.CountingStream.Adjust(System.Int64)">
             <summary>
                Adjust the byte count on the stream.
             </summary>
            
             <param name='delta'>
               the number of bytes to subtract from the count.
             </param>
            
             <remarks>
               <para>
                 Subtract delta from the count of bytes written to the stream.
                 This is necessary when seeking back, and writing additional data,
                 as happens in some cases when saving Zip files.
               </para>
             </remarks>
        </member>
        <member name="M:Ionic.Zip.CountingStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
              The read method.
            </summary>
            <param name="buffer">The buffer to hold the data read from the stream.</param>
            <param name="offset">the offset within the buffer to copy the first byte read.</param>
            <param name="count">the number of bytes to read.</param>
            <returns>the number of bytes read, after decryption and decompression.</returns>
        </member>
        <member name="M:Ionic.Zip.CountingStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
              Write data into the stream.
            </summary>
            <param name="buffer">The buffer holding data to write to the stream.</param>
            <param name="offset">the offset within that data array to find the first byte to write.</param>
            <param name="count">the number of bytes to write.</param>
        </member>
        <member name="P:Ionic.Zip.CountingStream.CanRead">
            <summary>
              Whether the stream can be read.
            </summary>
        </member>
        <member name="P:Ionic.Zip.CountingStream.CanSeek">
            <summary>
              Whether it is possible to call Seek() on the stream.
            </summary>
        </member>
        <member name="P:Ionic.Zip.CountingStream.CanWrite">
            <summary>
              Whether it is possible to call Write() on the stream.
            </summary>
        </member>
        <member name="M:Ionic.Zip.CountingStream.Flush">
            <summary>
              Flushes the underlying stream.
            </summary>
        </member>
        <member name="P:Ionic.Zip.CountingStream.Length">
            <summary>
              The length of the underlying stream.
            </summary>
        </member>
        <member name="P:Ionic.Zip.CountingStream.ComputedPosition">
            <summary>
              Returns the sum of number of bytes written, plus the initial
              offset before writing.
            </summary>
        </member>
        <member name="P:Ionic.Zip.CountingStream.Position">
            <summary>
              The Position of the stream.
            </summary>
        </member>
        <member name="M:Ionic.Zip.CountingStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
              Seek in the stream.
            </summary>
            <param name="offset">the offset point to seek to</param>
            <param name="origin">the reference point from which to seek</param>
            <returns>The new position</returns>
        </member>
        <member name="M:Ionic.Zip.CountingStream.SetLength(System.Int64)">
             <summary>
               Set the length of the underlying stream.  Be careful with this!
             </summary>
            
             <param name='value'>the length to set on the underlying stream.</param>
        </member>
        <member name="T:Ionic.Zip.EncryptionAlgorithm">
             <summary>
             An enum that provides the various encryption algorithms supported by this
             library.
             </summary>
            
             <remarks>
            
             <para>
               <c>PkzipWeak</c> implies the use of Zip 2.0 encryption, which is known to be
               weak and subvertible.
             </para>
            
             <para>
               A note on interoperability: Values of <c>PkzipWeak</c> and <c>None</c> are
               specified in <see
               href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">PKWARE's zip
               specification</see>, and are considered to be "standard".  Zip archives
               produced using these options will be interoperable with many other zip tools
               and libraries, including Windows Explorer.
             </para>
            
             <para>
               Values of <c>WinZipAes128</c> and <c>WinZipAes256</c> are not part of the Zip
               specification, but rather imply the use of a vendor-specific extension from
               WinZip. If you want to produce interoperable Zip archives, do not use these
               values.  For example, if you produce a zip archive using WinZipAes256, you
               will be able to open it in Windows Explorer on Windows XP and Vista, but you
               will not be able to extract entries; trying this will lead to an "unspecified
               error". For this reason, some people have said that a zip archive that uses
               WinZip's AES encryption is not actually a zip archive at all.  A zip archive
               produced this way will be readable with the WinZip tool (Version 11 and
               beyond).
             </para>
            
             <para>
               There are other third-party tools and libraries, both commercial and
               otherwise, that support WinZip's AES encryption. These will be able to read
               AES-encrypted zip archives produced by DotNetZip, and conversely applications
               that use DotNetZip to read zip archives will be able to read AES-encrypted
               archives produced by those tools or libraries.  Consult the documentation for
               those other tools and libraries to find out if WinZip's AES encryption is
               supported.
             </para>
            
             <para>
               In case you care: According to <see
               href="http://www.winzip.com/aes_info.htm">the WinZip specification</see>, the
               actual AES key used is derived from the <see cref="P:Ionic.Zip.ZipEntry.Password"/> via an
               algorithm that complies with <see
               href="http://www.ietf.org/rfc/rfc2898.txt">RFC 2898</see>, using an iteration
               count of 1000.  The algorithm is sometimes referred to as PBKDF2, which stands
               for "Password Based Key Derivation Function #2".
             </para>
            
             <para>
               A word about password strength and length: The AES encryption technology is
               very good, but any system is only as secure as the weakest link.  If you want
               to secure your data, be sure to use a password that is hard to guess.  To make
               it harder to guess (increase its "entropy"), you should make it longer.  If
               you use normal characters from an ASCII keyboard, a password of length 20 will
               be strong enough that it will be impossible to guess.  For more information on
               that, I'd encourage you to read <see
               href="http://www.redkestrel.co.uk/Articles/RandomPasswordStrength.html">this
               article.</see>
             </para>
            
             <para>
               The WinZip AES algorithms are not supported with the version of DotNetZip that
               runs on the .NET Compact Framework.  This is because .NET CF lacks the
               HMACSHA1 class that is required for producing the archive.
             </para>
             </remarks>
        </member>
        <member name="F:Ionic.Zip.EncryptionAlgorithm.None">
            <summary>
            No encryption at all.
            </summary>
        </member>
        <member name="F:Ionic.Zip.EncryptionAlgorithm.PkzipWeak">
            <summary>
            Traditional or Classic pkzip encryption.
            </summary>
        </member>
        <member name="F:Ionic.Zip.EncryptionAlgorithm.Unsupported">
            <summary>
            An encryption algorithm that is not supported by DotNetZip.
            </summary>
        </member>
        <member name="T:Ionic.Zip.ZipEntrySource">
            <summary>
            An enum that specifies the source of the ZipEntry. 
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipEntrySource.None">
            <summary>
            Default value.  Invalid on a bonafide ZipEntry.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipEntrySource.FileSystem">
            <summary>
            The entry was instantiated by calling AddFile() or another method that 
            added an entry from the filesystem.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipEntrySource.Stream">
            <summary>
            The entry was instantiated via <see cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,System.String)"/> or
            <see cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,System.IO.Stream)"/> .
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipEntrySource.ZipFile">
            <summary>
            The ZipEntry was instantiated by reading a zipfile.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipEntrySource.WriteDelegate">
            <summary>
            The content for the ZipEntry will be or was provided by the WriteDelegate.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipEntrySource.JitStream">
            <summary>
            The content for the ZipEntry will be obtained from the stream dispensed by the <c>OpenDelegate</c>.
            The entry was instantiated via <see cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,Ionic.Zip.OpenDelegate,Ionic.Zip.CloseDelegate)"/>.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipEntrySource.ZipOutputStream">
            <summary>
            The content for the ZipEntry will be or was obtained from a <c>ZipOutputStream</c>.
            </summary>
        </member>
        <member name="T:Ionic.Zip.ZipErrorAction">
             <summary>
             An enum providing the options when an error occurs during opening or reading
             of a file or directory that is being saved to a zip file. 
             </summary>
            
             <remarks>
              <para>
                This enum describes the actions that the library can take when an error occurs
                opening or reading a file, as it is being saved into a Zip archive. 
              </para>
            
              <para>
                 In some cases an error will occur when DotNetZip tries to open a file to be
                 added to the zip archive.  In other cases, an error might occur after the
                 file has been successfully opened, while DotNetZip is reading the file.
              </para>
             
              <para>
                The first problem might occur when calling AddDirectory() on a directory
                that contains a Clipper .dbf file; the file is locked by Clipper and
                cannot be opened by another process. An example of the second problem is
                the ERROR_LOCK_VIOLATION that results when a file is opened by another
                process, but not locked, and a range lock has been taken on the file.
                Microsoft Outlook takes range locks on .PST files.
              </para>
             </remarks>
        </member>
        <member name="F:Ionic.Zip.ZipErrorAction.Throw">
            <summary>
            Throw an exception when an error occurs while zipping.  This is the default
            behavior.  (For COM clients, this is a 0 (zero).)
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipErrorAction.Skip">
            <summary>
            When an error occurs during zipping, for example a file cannot be opened,
            skip the file causing the error, and continue zipping.  (For COM clients,
            this is a 1.)
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipErrorAction.Retry">
            <summary>
            When an error occurs during zipping, for example a file cannot be opened,
            retry the operation that caused the error. Be careful with this option. If
            the error is not temporary, the library will retry forever.  (For COM
            clients, this is a 2.)
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipErrorAction.InvokeErrorEvent">
            <summary>
            When an error occurs, invoke the zipError event.  The event type used is
            <see cref="F:Ionic.Zip.ZipProgressEventType.Error_Saving"/>.  A typical use of this option:
            a GUI application may wish to pop up a dialog to allow the user to view the
            error that occurred, and choose an appropriate action.  After your
            processing in the error event, if you want to skip the file, set <see
            cref="P:Ionic.Zip.ZipEntry.ZipErrorAction"/> on the
            <c>ZipProgressEventArgs.CurrentEntry</c> to <c>Skip</c>.  If you want the
            exception to be thrown, set <c>ZipErrorAction</c> on the <c>CurrentEntry</c>
            to <c>Throw</c>.  If you want to cancel the zip, set
            <c>ZipProgressEventArgs.Cancel</c> to true.  Cancelling differs from using
            Skip in that a cancel will not save any further entries, if there are any.
            (For COM clients, the value of this enum is a 3.)
            </summary>
        </member>
        <member name="T:Ionic.Zip.ReadOptions">
             <summary>
               A class for collecting the various options that can be used when
               Reading zip files for extraction or update.
             </summary>
            
             <remarks>
               <para>
                 When reading a zip file, there are several options an
                 application can set, to modify how the file is read, or what
                 the library does while reading.  This class collects those
                 options into one container.
               </para>
            
               <para>
                 Pass an instance of the <c>ReadOptions</c> class into the
                 <c>ZipFile.Read()</c> method.
               </para>
            
             <seealso cref="M:Ionic.Zip.ZipFile.Read(System.String,Ionic.Zip.ReadOptions)"/>.
             <seealso cref="M:Ionic.Zip.ZipFile.Read(System.IO.Stream,Ionic.Zip.ReadOptions)"/>.
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ReadOptions.ReadProgress">
            <summary>
            An event handler for Read operations.  When opening large zip
            archives, you may want to display a progress bar or other
            indicator of status progress while reading.  This parameter
            allows you to specify a ReadProgress Event Handler directly.
            When you call <c>Read()</c>, the progress event is invoked as
            necessary.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ReadOptions.StatusMessageWriter">
            <summary>
            The <c>System.IO.TextWriter</c> to use for writing verbose status messages
            during operations on the zip archive.  A console application may wish to
            pass <c>System.Console.Out</c> to get messages on the Console. A graphical
            or headless application may wish to capture the messages in a different
            <c>TextWriter</c>, such as a <c>System.IO.StringWriter</c>.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ReadOptions.Encoding">
             <summary>
             The <c>System.Text.Encoding</c> to use when reading in the zip archive. Be
             careful specifying the encoding.  If the value you use here is not the same
             as the Encoding used when the zip archive was created (possibly by a
             different archiver) you will get unexpected results and possibly exceptions.
             </summary>
            
             <seealso cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>
            
        </member>
        <member name="T:Ionic.Zip.ZipCrypto">
             <summary>
               This class implements the "traditional" or "classic" PKZip encryption,
               which today is considered to be weak. On the other hand it is
               ubiquitous. This class is intended for use only by the DotNetZip
               library.
             </summary>
            
             <remarks>
               Most uses of the DotNetZip library will not involve direct calls into
               the ZipCrypto class.  Instead, the ZipCrypto class is instantiated and
               used by the ZipEntry() class when encryption or decryption on an entry
               is employed.  If for some reason you really wanted to use a weak
               encryption algorithm in some other application, you might use this
               library.  But you would be much better off using one of the built-in
               strong encryption libraries in the .NET Framework, like the AES
               algorithm or SHA.
             </remarks>
        </member>
        <member name="M:Ionic.Zip.ZipCrypto.#ctor">
             <summary>
               The default constructor for ZipCrypto.
             </summary>
            
             <remarks>
               This class is intended for internal use by the library only. It's
               probably not useful to you. Seriously.  Stop reading this
               documentation.  It's a waste of your time.  Go do something else.
               Check the football scores. Go get an ice cream with a friend.
               Seriously.
             </remarks>
            
        </member>
        <member name="P:Ionic.Zip.ZipCrypto.MagicByte">
            <summary>
            From AppNote.txt:
            unsigned char decrypt_byte()
                local unsigned short temp
                temp :=- Key(2) | 2
                decrypt_byte := (temp * (temp ^ 1)) bitshift-right 8
            end decrypt_byte
            </summary>
        </member>
        <member name="M:Ionic.Zip.ZipCrypto.DecryptMessage(System.Byte[],System.Int32)">
             <summary>
               Call this method on a cipher text to render the plaintext. You must
               first initialize the cipher with a call to InitCipher.
             </summary>
            
             <example>
               <code>
                 var cipher = new ZipCrypto();
                 cipher.InitCipher(Password);
                 // Decrypt the header.  This has a side effect of "further initializing the
                 // encryption keys" in the traditional zip encryption.
                 byte[] DecryptedMessage = cipher.DecryptMessage(EncryptedMessage);
               </code>
             </example>
            
             <param name="cipherText">The encrypted buffer.</param>
             <param name="length">
               The number of bytes to encrypt.
               Should be less than or equal to CipherText.Length.
             </param>
            
             <returns>The plaintext.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipCrypto.EncryptMessage(System.Byte[],System.Int32)">
             <summary>
               This is the converse of DecryptMessage.  It encrypts the plaintext
               and produces a ciphertext.
             </summary>
            
             <param name="plainText">The plain text buffer.</param>
            
             <param name="length">
               The number of bytes to encrypt.
               Should be less than or equal to plainText.Length.
             </param>
            
             <returns>The ciphertext.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipCrypto.InitCipher(System.String)">
             <summary>
               This initializes the cipher with the given password.
               See AppNote.txt for details.
             </summary>
            
             <param name="passphrase">
               The passphrase for encrypting or decrypting with this cipher.
             </param>
            
             <remarks>
             <code>
             Step 1 - Initializing the encryption keys
             -----------------------------------------
             Start with these keys:
             Key(0) := 305419896 (0x12345678)
             Key(1) := 591751049 (0x23456789)
             Key(2) := 878082192 (0x34567890)
            
             Then, initialize the keys with a password:
            
             loop for i from 0 to length(password)-1
                 update_keys(password(i))
             end loop
            
             Where update_keys() is defined as:
            
             update_keys(char):
               Key(0) := crc32(key(0),char)
               Key(1) := Key(1) + (Key(0) bitwiseAND 000000ffH)
               Key(1) := Key(1) * 134775813 + 1
               Key(2) := crc32(key(2),key(1) rightshift 24)
             end update_keys
            
             Where crc32(old_crc,char) is a routine that given a CRC value and a
             character, returns an updated CRC value after applying the CRC-32
             algorithm described elsewhere in this document.
            
             </code>
            
             <para>
               After the keys are initialized, then you can use the cipher to
               encrypt the plaintext.
             </para>
            
             <para>
               Essentially we encrypt the password with the keys, then discard the
               ciphertext for the password. This initializes the keys for later use.
             </para>
            
             </remarks>
        </member>
        <member name="T:Ionic.Zip.ZipCipherStream">
            <summary>
              A Stream for reading and concurrently decrypting data from a zip file,
              or for writing and concurrently encrypting data to a zip file.
            </summary>
        </member>
        <member name="M:Ionic.Zip.ZipCipherStream.#ctor(System.IO.Stream,Ionic.Zip.ZipCrypto,Ionic.Zip.CryptoMode)">
            <summary>  The constructor. </summary>
            <param name="s">The underlying stream</param>
            <param name="mode">To either encrypt or decrypt.</param>
            <param name="cipher">The pre-initialized ZipCrypto object.</param>
        </member>
        <member name="T:Ionic.Zip.ExtractExistingFileAction">
             <summary>
             An enum for the options when extracting an entry would overwrite an existing file. 
             </summary>
             
             <remarks>
               <para>
                 This enum describes the actions that the library can take when an
                 <c>Extract()</c> or <c>ExtractWithPassword()</c> method is called to extract an
                 entry to a filesystem, and the extraction would overwrite an existing filesystem
                 file.
               </para>
             </remarks>
            
        </member>
        <member name="F:Ionic.Zip.ExtractExistingFileAction.Throw">
            <summary>
            Throw an exception when extraction would overwrite an existing file. (For
            COM clients, this is a 0 (zero).)
            </summary>
        </member>
        <member name="F:Ionic.Zip.ExtractExistingFileAction.OverwriteSilently">
            <summary>
            When extraction would overwrite an existing file, overwrite the file silently.
            The overwrite will happen even if the target file is marked as read-only.
            (For COM clients, this is a 1.)
            </summary>
        </member>
        <member name="F:Ionic.Zip.ExtractExistingFileAction.DoNotOverwrite">
            <summary>
            When extraction would overwrite an existing file, don't overwrite the file, silently. 
            (For COM clients, this is a 2.)
            </summary>
        </member>
        <member name="F:Ionic.Zip.ExtractExistingFileAction.InvokeExtractProgressEvent">
            <summary>
            When extraction would overwrite an existing file, invoke the ExtractProgress
            event, using an event type of <see
            cref="F:Ionic.Zip.ZipProgressEventType.Extracting_ExtractEntryWouldOverwrite"/>.  In
            this way, the application can decide, just-in-time, whether to overwrite the
            file. For example, a GUI application may wish to pop up a dialog to allow
            the user to choose. You may want to examine the <see
            cref="P:Ionic.Zip.ExtractProgressEventArgs.ExtractLocation"/> property before making
            the decision. If, after your processing in the Extract progress event, you
            want to NOT extract the file, set <see cref="P:Ionic.Zip.ZipEntry.ExtractExistingFile"/>
            on the <c>ZipProgressEventArgs.CurrentEntry</c> to <c>DoNotOverwrite</c>.
            If you do want to extract the file, set <c>ZipEntry.ExtractExistingFile</c>
            to <c>OverwriteSilently</c>.  If you want to cancel the Extraction, set
            <c>ZipProgressEventArgs.Cancel</c> to true.  Cancelling differs from using
            DoNotOverwrite in that a cancel will not extract any further entries, if
            there are any.  (For COM clients, the value of this enum is a 3.)
            </summary>
        </member>
        <member name="T:Ionic.Zip.ZipEntry">
            <summary>
            Represents a single entry in a ZipFile. Typically, applications get a ZipEntry
            by enumerating the entries within a ZipFile, or by adding an entry to a ZipFile.
            </summary>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.#ctor">
            <summary>
            Default constructor.
            </summary>
            <remarks>
            Applications should never need to call this directly.  It is exposed to
            support COM Automation environments.
            </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.LastModified">
             <summary>
               The time and date at which the file indicated by the <c>ZipEntry</c> was
               last modified.
             </summary>
            
             <remarks>
             <para>
               The DotNetZip library sets the LastModified value for an entry, equal to
               the Last Modified time of the file in the filesystem.  If an entry is
               added from a stream, the library uses <c>System.DateTime.Now</c> for this
               value, for the given entry.
             </para>
            
             <para>
               This property allows the application to retrieve and possibly set the
               LastModified value on an entry, to an arbitrary value.  <see
               cref="T:System.DateTime"/> values with a <see cref="T:System.DateTimeKind" />
               setting of <c>DateTimeKind.Unspecified</c> are taken to be expressed as
               <c>DateTimeKind.Local</c>.
             </para>
            
             <para>
               Be aware that because of the way <see
               href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">PKWare's
               Zip specification</see> describes how times are stored in the zip file,
               the full precision of the <c>System.DateTime</c> datatype is not stored
               for the last modified time when saving zip files.  For more information on
               how times are formatted, see the PKZip specification.
             </para>
            
             <para>
               The actual last modified time of a file can be stored in multiple ways in
               the zip file, and they are not mutually exclusive:
             </para>
            
             <list type="bullet">
               <item>
                 In the so-called "DOS" format, which has a 2-second precision. Values
                 are rounded to the nearest even second. For example, if the time on the
                 file is 12:34:43, then it will be stored as 12:34:44. This first value
                 is accessible via the <c>LastModified</c> property. This value is always
                 present in the metadata for each zip entry.  In some cases the value is
                 invalid, or zero.
               </item>
            
               <item>
                 In the so-called "Windows" or "NTFS" format, as an 8-byte integer
                 quantity expressed as the number of 1/10 milliseconds (in other words
                 the number of 100 nanosecond units) since January 1, 1601 (UTC).  This
                 format is how Windows represents file times.  This time is accessible
                 via the <c>ModifiedTime</c> property.
               </item>
            
               <item>
                 In the "Unix" format, a 4-byte quantity specifying the number of seconds since
                 January 1, 1970 UTC.
               </item>
            
               <item>
                 In an older format, now deprecated but still used by some current
                 tools. This format is also a 4-byte quantity specifying the number of
                 seconds since January 1, 1970 UTC.
               </item>
            
             </list>
            
             <para>
               Zip tools and libraries will always at least handle (read or write) the
               DOS time, and may also handle the other time formats.  Keep in mind that
               while the names refer to particular operating systems, there is nothing in
               the time formats themselves that prevents their use on other operating
               systems.
             </para>
            
             <para>
               When reading ZIP files, the DotNetZip library reads the Windows-formatted
               time, if it is stored in the entry, and sets both <c>LastModified</c> and
               <c>ModifiedTime</c> to that value. When writing ZIP files, the DotNetZip
               library by default will write both time quantities. It can also emit the
               Unix-formatted time if desired (See <see
               cref="P:Ionic.Zip.ZipEntry.EmitTimesInUnixFormatWhenSaving"/>.)
             </para>
            
             <para>
               The last modified time of the file created upon a call to
               <c>ZipEntry.Extract()</c> may be adjusted during extraction to compensate
               for differences in how the .NET Base Class Library deals with daylight
               saving time (DST) versus how the Windows filesystem deals with daylight
               saving time.  Raymond Chen <see
               href="http://blogs.msdn.com/oldnewthing/archive/2003/10/24/55413.aspx">provides
               some good context</see>.
             </para>
            
             <para>
               In a nutshell: Daylight savings time rules change regularly.  In 2007, for
               example, the inception week of DST changed.  In 1977, DST was in place all
               year round. In 1945, likewise.  And so on.  Win32 does not attempt to
               guess which time zone rules were in effect at the time in question.  It
               will render a time as "standard time" and allow the app to change to DST
               as necessary.  .NET makes a different choice.
             </para>
            
             <para>
               Compare the output of FileInfo.LastWriteTime.ToString("f") with what you
               see in the Windows Explorer property sheet for a file that was last
               written to on the other side of the DST transition. For example, suppose
               the file was last modified on October 17, 2003, during DST but DST is not
               currently in effect. Explorer's file properties reports Thursday, October
               17, 2003, 8:45:38 AM, but .NETs FileInfo reports Thursday, October 17,
               2003, 9:45 AM.
             </para>
            
             <para>
               Win32 says, "Thursday, October 17, 2002 8:45:38 AM PST". Note: Pacific
               STANDARD Time. Even though October 17 of that year occurred during Pacific
               Daylight Time, Win32 displays the time as standard time because that's
               what time it is NOW.
             </para>
            
             <para>
               .NET BCL assumes that the current DST rules were in place at the time in
               question.  So, .NET says, "Well, if the rules in effect now were also in
               effect on October 17, 2003, then that would be daylight time" so it
               displays "Thursday, October 17, 2003, 9:45 AM PDT" - daylight time.
             </para>
            
             <para>
               So .NET gives a value which is more intuitively correct, but is also
               potentially incorrect, and which is not invertible. Win32 gives a value
               which is intuitively incorrect, but is strictly correct.
             </para>
            
             <para>
               Because of this funkiness, this library adds one hour to the LastModified
               time on the extracted file, if necessary.  That is to say, if the time in
               question had occurred in what the .NET Base Class Library assumed to be
               DST. This assumption may be wrong given the constantly changing DST rules,
               but it is the best we can do.
             </para>
            
             </remarks>
            
        </member>
        <member name="P:Ionic.Zip.ZipEntry.ModifiedTime">
             <summary>
             Last Modified time for the file represented by the entry.
             </summary>
            
             <remarks>
            
             <para>
               This value corresponds to the "last modified" time in the NTFS file times
               as described in <see
               href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">the Zip
               specification</see>.  When getting this property, the value may be
               different from <see cref="P:Ionic.Zip.ZipEntry.LastModified" />.  When setting the property,
               the <see cref="P:Ionic.Zip.ZipEntry.LastModified"/> property also gets set, but with a lower
               precision.
             </para>
            
             <para>
               Let me explain. It's going to take a while, so get
               comfortable. Originally, waaaaay back in 1989 when the ZIP specification
               was originally described by the esteemed Mr. Phil Katz, the dominant
               operating system of the time was MS-DOS. MSDOS stored file times with a
               2-second precision, because, c'mon, <em>who is ever going to need better
               resolution than THAT?</em> And so ZIP files, regardless of the platform on
               which the zip file was created, store file times in exactly <see
               href="http://www.vsft.com/hal/dostime.htm">the same format that DOS used
               in 1989</see>.
             </para>
            
             <para>
               Since then, the ZIP spec has evolved, but the internal format for file
               timestamps remains the same.  Despite the fact that the way times are
               stored in a zip file is rooted in DOS heritage, any program on any
               operating system can format a time in this way, and most zip tools and
               libraries DO - they round file times to the nearest even second and store
               it just like DOS did 25+ years ago.
             </para>
            
             <para>
               PKWare extended the ZIP specification to allow a zip file to store what
               are called "NTFS Times" and "Unix(tm) times" for a file.  These are the
               <em>last write</em>, <em>last access</em>, and <em>file creation</em>
               times of a particular file. These metadata are not actually specific
               to NTFS or Unix. They are tracked for each file by NTFS and by various
               Unix filesystems, but they are also tracked by other filesystems, too.
               The key point is that the times are <em>formatted in the zip file</em>
               in the same way that NTFS formats the time (ticks since win32 epoch),
               or in the same way that Unix formats the time (seconds since Unix
               epoch). As with the DOS time, any tool or library running on any
               operating system is capable of formatting a time in one of these ways
               and embedding it into the zip file.
             </para>
            
             <para>
               These extended times are higher precision quantities than the DOS time.
               As described above, the (DOS) LastModified has a precision of 2 seconds.
               The Unix time is stored with a precision of 1 second. The NTFS time is
               stored with a precision of 0.0000001 seconds. The quantities are easily
               convertible, except for the loss of precision you may incur.
             </para>
            
             <para>
               A zip archive can store the {C,A,M} times in NTFS format, in Unix format,
               or not at all.  Often a tool running on Unix or Mac will embed the times
               in Unix format (1 second precision), while WinZip running on Windows might
               embed the times in NTFS format (precision of of 0.0000001 seconds).  When
               reading a zip file with these "extended" times, in either format,
               DotNetZip represents the values with the
               <c>ModifiedTime</c>, <c>AccessedTime</c> and <c>CreationTime</c>
               properties on the <c>ZipEntry</c>.
             </para>
            
             <para>
               While any zip application or library, regardless of the platform it
               runs on, could use any of the time formats allowed by the ZIP
               specification, not all zip tools or libraries do support all these
               formats.  Storing the higher-precision times for each entry is
               optional for zip files, and many tools and libraries don't use the
               higher precision quantities at all. The old DOS time, represented by
               <see cref="P:Ionic.Zip.ZipEntry.LastModified"/>, is guaranteed to be present, though it
               sometimes unset.
             </para>
            
             <para>
               Ok, getting back to the question about how the <c>LastModified</c>
               property relates to this <c>ModifiedTime</c>
               property... <c>LastModified</c> is always set, while
               <c>ModifiedTime</c> is not. (The other times stored in the <em>NTFS
               times extension</em>, <c>CreationTime</c> and <c>AccessedTime</c> also
               may not be set on an entry that is read from an existing zip file.)
               When reading a zip file, then <c>LastModified</c> takes the DOS time
               that is stored with the file. If the DOS time has been stored as zero
               in the zipfile, then this library will use <c>DateTime.Now</c> for the
               <c>LastModified</c> value.  If the ZIP file was created by an evolved
               tool, then there will also be higher precision NTFS or Unix times in
               the zip file.  In that case, this library will read those times, and
               set <c>LastModified</c> and <c>ModifiedTime</c> to the same value, the
               one corresponding to the last write time of the file.  If there are no
               higher precision times stored for the entry, then <c>ModifiedTime</c>
               remains unset (likewise <c>AccessedTime</c> and <c>CreationTime</c>),
               and <c>LastModified</c> keeps its DOS time.
             </para>
            
             <para>
               When creating zip files with this library, by default the extended time
               properties (<c>ModifiedTime</c>, <c>AccessedTime</c>, and
               <c>CreationTime</c>) are set on the ZipEntry instance, and these data are
               stored in the zip archive for each entry, in NTFS format. If you add an
               entry from an actual filesystem file, then the entry gets the actual file
               times for that file, to NTFS-level precision.  If you add an entry from a
               stream, or a string, then the times get the value <c>DateTime.Now</c>.  In
               this case <c>LastModified</c> and <c>ModifiedTime</c> will be identical,
               to 2 seconds of precision.  You can explicitly set the
               <c>CreationTime</c>, <c>AccessedTime</c>, and <c>ModifiedTime</c> of an
               entry using the property setters.  If you want to set all of those
               quantities, it's more efficient to use the <see
               cref="M:Ionic.Zip.ZipEntry.SetEntryTimes(System.DateTime,System.DateTime,System.DateTime)"/> method.  Those
               changes are not made permanent in the zip file until you call <see
               cref="M:Ionic.Zip.ZipFile.Save"/> or one of its cousins.
             </para>
            
             <para>
               When creating a zip file, you can override the default behavior of
               this library for formatting times in the zip file, disabling the
               embedding of file times in NTFS format or enabling the storage of file
               times in Unix format, or both.  You may want to do this, for example,
               when creating a zip file on Windows, that will be consumed on a Mac,
               by an application that is not hip to the "NTFS times" format. To do
               this, use the <see cref="P:Ionic.Zip.ZipEntry.EmitTimesInWindowsFormatWhenSaving"/> and
               <see cref="P:Ionic.Zip.ZipEntry.EmitTimesInUnixFormatWhenSaving"/> properties.  A valid zip
               file may store the file times in both formats.  But, there are no
               guarantees that a program running on Mac or Linux will gracefully
               handle the NTFS-formatted times when Unix times are present, or that a
               non-DotNetZip-powered application running on Windows will be able to
               handle file times in Unix format. DotNetZip will always do something
               reasonable; other libraries or tools may not. When in doubt, test.
             </para>
            
             <para>
               I'll bet you didn't think one person could type so much about time, eh?
               And reading it was so enjoyable, too!  Well, in appreciation, <see
               href="http://cheeso.members.winisp.net/DotNetZipDonate.aspx">maybe you
               should donate</see>?
             </para>
             </remarks>
            
             <seealso cref="P:Ionic.Zip.ZipEntry.AccessedTime"/>
             <seealso cref="P:Ionic.Zip.ZipEntry.CreationTime"/>
             <seealso cref="P:Ionic.Zip.ZipEntry.LastModified"/>
             <seealso cref="M:Ionic.Zip.ZipEntry.SetEntryTimes(System.DateTime,System.DateTime,System.DateTime)"/>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.AccessedTime">
            <summary>
            Last Access time for the file represented by the entry.
            </summary>
            <remarks>
            This value may or may not be meaningful.  If the <c>ZipEntry</c> was read from an existing
            Zip archive, this information may not be available. For an explanation of why, see
            <see cref="P:Ionic.Zip.ZipEntry.ModifiedTime"/>.
            </remarks>
            <seealso cref="P:Ionic.Zip.ZipEntry.ModifiedTime"/>
            <seealso cref="P:Ionic.Zip.ZipEntry.CreationTime"/>
            <seealso cref="M:Ionic.Zip.ZipEntry.SetEntryTimes(System.DateTime,System.DateTime,System.DateTime)"/>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.CreationTime">
             <summary>
             The file creation time for the file represented by the entry.
             </summary>
            
             <remarks>
             This value may or may not be meaningful.  If the <c>ZipEntry</c> was read
             from an existing zip archive, and the creation time was not set on the entry
             when the zip file was created, then this property may be meaningless. For an
             explanation of why, see <see cref="P:Ionic.Zip.ZipEntry.ModifiedTime"/>.
             </remarks>
             <seealso cref="P:Ionic.Zip.ZipEntry.ModifiedTime"/>
             <seealso cref="P:Ionic.Zip.ZipEntry.AccessedTime"/>
             <seealso cref="M:Ionic.Zip.ZipEntry.SetEntryTimes(System.DateTime,System.DateTime,System.DateTime)"/>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.SetEntryTimes(System.DateTime,System.DateTime,System.DateTime)">
             <summary>
               Sets the NTFS Creation, Access, and Modified times for the given entry.
             </summary>
            
             <remarks>
             <para>
               When adding an entry from a file or directory, the Creation, Access, and
               Modified times for the given entry are automatically set from the
               filesystem values. When adding an entry from a stream or string, the
               values are implicitly set to DateTime.Now.  The application may wish to
               set these values to some arbitrary value, before saving the archive, and
               can do so using the various setters.  If you want to set all of the times,
               this method is more efficient.
             </para>
            
             <para>
               The values you set here will be retrievable with the <see
               cref="P:Ionic.Zip.ZipEntry.ModifiedTime"/>, <see cref="P:Ionic.Zip.ZipEntry.CreationTime"/> and <see
               cref="P:Ionic.Zip.ZipEntry.AccessedTime"/> properties.
             </para>
            
             <para>
               When this method is called, if both <see
               cref="P:Ionic.Zip.ZipEntry.EmitTimesInWindowsFormatWhenSaving"/> and <see
               cref="P:Ionic.Zip.ZipEntry.EmitTimesInUnixFormatWhenSaving"/> are false, then the
               <c>EmitTimesInWindowsFormatWhenSaving</c> flag is automatically set.
             </para>
            
             <para>
               DateTime values provided here without a DateTimeKind are assumed to be Local Time.
             </para>
            
             </remarks>
             <param name="created">the creation time of the entry.</param>
             <param name="accessed">the last access time of the entry.</param>
             <param name="modified">the last modified time of the entry.</param>
            
             <seealso cref="P:Ionic.Zip.ZipEntry.EmitTimesInWindowsFormatWhenSaving" />
             <seealso cref="P:Ionic.Zip.ZipEntry.EmitTimesInUnixFormatWhenSaving" />
             <seealso cref="P:Ionic.Zip.ZipEntry.AccessedTime"/>
             <seealso cref="P:Ionic.Zip.ZipEntry.CreationTime"/>
             <seealso cref="P:Ionic.Zip.ZipEntry.ModifiedTime"/>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.EmitTimesInWindowsFormatWhenSaving">
             <summary>
               Specifies whether the Creation, Access, and Modified times for the given
               entry will be emitted in "Windows format" when the zip archive is saved.
             </summary>
            
             <remarks>
             <para>
               An application creating a zip archive can use this flag to explicitly
               specify that the file times for the entry should or should not be stored
               in the zip archive in the format used by Windows. The default value of
               this property is <c>true</c>.
             </para>
            
             <para>
               When adding an entry from a file or directory, the Creation (<see
               cref="P:Ionic.Zip.ZipEntry.CreationTime"/>), Access (<see cref="P:Ionic.Zip.ZipEntry.AccessedTime"/>), and Modified
               (<see cref="P:Ionic.Zip.ZipEntry.ModifiedTime"/>) times for the given entry are automatically
               set from the filesystem values. When adding an entry from a stream or
               string, all three values are implicitly set to DateTime.Now.  Applications
               can also explicitly set those times by calling <see
               cref="M:Ionic.Zip.ZipEntry.SetEntryTimes(System.DateTime,System.DateTime,System.DateTime)" />.
             </para>
            
             <para>
               <see
               href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">PKWARE's
               zip specification</see> describes multiple ways to format these times in a
               zip file. One is the format Windows applications normally use: 100ns ticks
               since Jan 1, 1601 UTC.  The other is a format Unix applications typically
               use: seconds since January 1, 1970 UTC.  Each format can be stored in an
               "extra field" in the zip entry when saving the zip archive. The former
               uses an extra field with a Header Id of 0x000A, while the latter uses a
               header ID of 0x5455.
             </para>
            
             <para>
               Not all zip tools and libraries can interpret these fields.  Windows
               compressed folders is one that can read the Windows Format timestamps,
               while I believe the <see href="http://www.info-zip.org/">Infozip</see>
               tools can read the Unix format timestamps. Although the time values are
               easily convertible, subject to a loss of precision, some tools and
               libraries may be able to read only one or the other. DotNetZip can read or
               write times in either or both formats.
             </para>
            
             <para>
               The times stored are taken from <see cref="P:Ionic.Zip.ZipEntry.ModifiedTime"/>, <see
               cref="P:Ionic.Zip.ZipEntry.AccessedTime"/>, and <see cref="P:Ionic.Zip.ZipEntry.CreationTime"/>.
             </para>
            
             <para>
               This property is not mutually exclusive from the <see
               cref="P:Ionic.Zip.ZipEntry.EmitTimesInUnixFormatWhenSaving"/> property.  It is
               possible that a zip entry can embed the timestamps in both forms, one
               form, or neither.  But, there are no guarantees that a program running on
               Mac or Linux will gracefully handle NTFS Formatted times, or that a
               non-DotNetZip-powered application running on Windows will be able to
               handle file times in Unix format. When in doubt, test.
             </para>
            
             <para>
               Normally you will use the <see
               cref="P:Ionic.Zip.ZipFile.EmitTimesInWindowsFormatWhenSaving">ZipFile.EmitTimesInWindowsFormatWhenSaving</see>
               property, to specify the behavior for all entries in a zip, rather than
               the property on each individual entry.
             </para>
            
             </remarks>
            
             <seealso cref="M:Ionic.Zip.ZipEntry.SetEntryTimes(System.DateTime,System.DateTime,System.DateTime)"/>
             <seealso cref="P:Ionic.Zip.ZipEntry.EmitTimesInUnixFormatWhenSaving"/>
             <seealso cref="P:Ionic.Zip.ZipEntry.CreationTime"/>
             <seealso cref="P:Ionic.Zip.ZipEntry.AccessedTime"/>
             <seealso cref="P:Ionic.Zip.ZipEntry.ModifiedTime"/>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.EmitTimesInUnixFormatWhenSaving">
             <summary>
               Specifies whether the Creation, Access, and Modified times for the given
               entry will be emitted in &quot;Unix(tm) format&quot; when the zip archive is saved.
             </summary>
            
             <remarks>
             <para>
               An application creating a zip archive can use this flag to explicitly
               specify that the file times for the entry should or should not be stored
               in the zip archive in the format used by Unix. By default this flag is
               <c>false</c>, meaning the Unix-format times are not stored in the zip
               archive.
             </para>
            
             <para>
               When adding an entry from a file or directory, the Creation (<see
               cref="P:Ionic.Zip.ZipEntry.CreationTime"/>), Access (<see cref="P:Ionic.Zip.ZipEntry.AccessedTime"/>), and Modified
               (<see cref="P:Ionic.Zip.ZipEntry.ModifiedTime"/>) times for the given entry are automatically
               set from the filesystem values. When adding an entry from a stream or
               string, all three values are implicitly set to DateTime.Now.  Applications
               can also explicitly set those times by calling <see
               cref="M:Ionic.Zip.ZipEntry.SetEntryTimes(System.DateTime,System.DateTime,System.DateTime)"/>.
             </para>
            
             <para>
               <see
               href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">PKWARE's
               zip specification</see> describes multiple ways to format these times in a
               zip file. One is the format Windows applications normally use: 100ns ticks
               since Jan 1, 1601 UTC.  The other is a format Unix applications typically
               use: seconds since Jan 1, 1970 UTC.  Each format can be stored in an
               "extra field" in the zip entry when saving the zip archive. The former
               uses an extra field with a Header Id of 0x000A, while the latter uses a
               header ID of 0x5455.
             </para>
            
             <para>
               Not all tools and libraries can interpret these fields.  Windows
               compressed folders is one that can read the Windows Format timestamps,
               while I believe the <see href="http://www.info-zip.org/">Infozip</see>
               tools can read the Unix format timestamps. Although the time values are
               easily convertible, subject to a loss of precision, some tools and
               libraries may be able to read only one or the other. DotNetZip can read or
               write times in either or both formats.
             </para>
            
             <para>
               The times stored are taken from <see cref="P:Ionic.Zip.ZipEntry.ModifiedTime"/>, <see
               cref="P:Ionic.Zip.ZipEntry.AccessedTime"/>, and <see cref="P:Ionic.Zip.ZipEntry.CreationTime"/>.
             </para>
            
             <para>
               This property is not mutually exclusive from the <see
               cref="P:Ionic.Zip.ZipEntry.EmitTimesInWindowsFormatWhenSaving"/> property.  It is
               possible that a zip entry can embed the timestamps in both forms, one
               form, or neither.  But, there are no guarantees that a program running on
               Mac or Linux will gracefully handle NTFS Formatted times, or that a
               non-DotNetZip-powered application running on Windows will be able to
               handle file times in Unix format. When in doubt, test.
             </para>
            
             <para>
               Normally you will use the <see
               cref="P:Ionic.Zip.ZipFile.EmitTimesInUnixFormatWhenSaving">ZipFile.EmitTimesInUnixFormatWhenSaving</see>
               property, to specify the behavior for all entries, rather than the
               property on each individual entry.
             </para>
             </remarks>
            
             <seealso cref="M:Ionic.Zip.ZipEntry.SetEntryTimes(System.DateTime,System.DateTime,System.DateTime)"/>
             <seealso cref="P:Ionic.Zip.ZipEntry.EmitTimesInWindowsFormatWhenSaving"/>
             <seealso cref="P:Ionic.Zip.ZipFile.EmitTimesInUnixFormatWhenSaving"/>
             <seealso cref="P:Ionic.Zip.ZipEntry.CreationTime"/>
             <seealso cref="P:Ionic.Zip.ZipEntry.AccessedTime"/>
             <seealso cref="P:Ionic.Zip.ZipEntry.ModifiedTime"/>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.Timestamp">
             <summary>
             The type of timestamp attached to the ZipEntry.
             </summary>
            
             <remarks>
             This property is valid only for a ZipEntry that was read from a zip archive.
             It indicates the type of timestamp attached to the entry.
             </remarks>
            
             <seealso cref="P:Ionic.Zip.ZipEntry.EmitTimesInWindowsFormatWhenSaving"/>
             <seealso cref="P:Ionic.Zip.ZipEntry.EmitTimesInUnixFormatWhenSaving"/>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.Attributes">
             <summary>
               The file attributes for the entry.
             </summary>
            
             <remarks>
            
             <para>
               The <see cref="T:System.IO.FileAttributes">attributes</see> in NTFS include
               ReadOnly, Archive, Hidden, System, and Indexed.  When adding a
               <c>ZipEntry</c> to a ZipFile, these attributes are set implicitly when
               adding an entry from the filesystem.  When adding an entry from a stream
               or string, the Attributes are not set implicitly.  Regardless of the way
               an entry was added to a <c>ZipFile</c>, you can set the attributes
               explicitly if you like.
             </para>
            
             <para>
               When reading a <c>ZipEntry</c> from a <c>ZipFile</c>, the attributes are
               set according to the data stored in the <c>ZipFile</c>. If you extract the
               entry from the archive to a filesystem file, DotNetZip will set the
               attributes on the resulting file accordingly.
             </para>
            
             <para>
               The attributes can be set explicitly by the application.  For example the
               application may wish to set the <c>FileAttributes.ReadOnly</c> bit for all
               entries added to an archive, so that on unpack, this attribute will be set
               on the extracted file.  Any changes you make to this property are made
               permanent only when you call a <c>Save()</c> method on the <c>ZipFile</c>
               instance that contains the ZipEntry.
             </para>
            
             <para>
               For example, an application may wish to zip up a directory and set the
               ReadOnly bit on every file in the archive, so that upon later extraction,
               the resulting files will be marked as ReadOnly.  Not every extraction tool
               respects these attributes, but if you unpack with DotNetZip, as for
               example in a self-extracting archive, then the attributes will be set as
               they are stored in the <c>ZipFile</c>.
             </para>
            
             <para>
               These attributes may not be interesting or useful if the resulting archive
               is extracted on a non-Windows platform.  How these attributes get used
               upon extraction depends on the platform and tool used.
             </para>
            
             <para>
               This property is only partially supported in the Silverlight version
               of the library: applications can read attributes on entries within
               ZipFiles. But extracting entries within Silverlight will not set the
               attributes on the extracted files.
             </para>
            
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.LocalFileName">
             <summary>
               The name of the filesystem file, referred to by the ZipEntry.
             </summary>
            
             <remarks>
              <para>
                This property specifies the thing-to-be-zipped on disk, and is set only
                when the <c>ZipEntry</c> is being created from a filesystem file.  If the
                <c>ZipFile</c> is instantiated by reading an existing .zip archive, then
                the LocalFileName will be <c>null</c> (<c>Nothing</c> in VB).
              </para>
            
              <para>
                When it is set, the value of this property may be different than <see
                cref="P:Ionic.Zip.ZipEntry.FileName"/>, which is the path used in the archive itself.  If you
                call <c>Zip.AddFile("foop.txt", AlternativeDirectory)</c>, then the path
                used for the <c>ZipEntry</c> within the zip archive will be different
                than this path.
              </para>
            
              <para>
               If the entry is being added from a stream, then this is null (Nothing in VB).
              </para>
            
             </remarks>
             <seealso cref="P:Ionic.Zip.ZipEntry.FileName"/>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.FileName">
             <summary>
               The name of the file contained in the ZipEntry.
             </summary>
            
             <remarks>
            
             <para>
               This is the name of the entry in the <c>ZipFile</c> itself.  When creating
               a zip archive, if the <c>ZipEntry</c> has been created from a filesystem
               file, via a call to <see cref="M:Ionic.Zip.ZipFile.AddFile(System.String,System.String)"/> or <see
               cref="M:Ionic.Zip.ZipFile.AddItem(System.String,System.String)"/>, or a related overload, the value
               of this property is derived from the name of that file. The
               <c>FileName</c> property does not include drive letters, and may include a
               different directory path, depending on the value of the
               <c>directoryPathInArchive</c> parameter used when adding the entry into
               the <c>ZipFile</c>.
             </para>
            
             <para>
               In some cases there is no related filesystem file - for example when a
               <c>ZipEntry</c> is created using <see cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,System.String)"/> or one of the similar overloads.  In this case, the value of
               this property is derived from the fileName and the directory path passed
               to that method.
             </para>
            
             <para>
               When reading a zip file, this property takes the value of the entry name
               as stored in the zip file. If you extract such an entry, the extracted
               file will take the name given by this property.
             </para>
            
             <para>
               Applications can set this property when creating new zip archives or when
               reading existing archives. When setting this property, the actual value
               that is set will replace backslashes with forward slashes, in accordance
               with <see
               href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">the Zip
               specification</see>, for compatibility with Unix(tm) and ... get
               this.... Amiga!
             </para>
            
             <para>
               If an application reads a <c>ZipFile</c> via <see
               cref="M:Ionic.Zip.ZipFile.Read(System.String)"/> or a related overload, and then explicitly
               sets the FileName on an entry contained within the <c>ZipFile</c>, and
               then calls <see cref="M:Ionic.Zip.ZipFile.Save"/>, the application will effectively
               rename the entry within the zip archive.
             </para>
            
             <para>
               If an application sets the value of <c>FileName</c>, then calls
               <c>Extract()</c> on the entry, the entry is extracted to a file using the
               newly set value as the filename.  The <c>FileName</c> value is made
               permanent in the zip archive only <em>after</em> a call to one of the
               <c>ZipFile.Save()</c> methods on the <c>ZipFile</c> that contains the
               ZipEntry.
             </para>
            
             <para>
               If an application attempts to set the <c>FileName</c> to a value that
               would result in a duplicate entry in the <c>ZipFile</c>, an exception is
               thrown.
             </para>
            
             <para>
               When a <c>ZipEntry</c> is contained within a <c>ZipFile</c>, applications
               cannot rename the entry within the context of a <c>foreach</c> (<c>For
               Each</c> in VB) loop, because of the way the <c>ZipFile</c> stores
               entries.  If you need to enumerate through all the entries and rename one
               or more of them, use <see
               cref="P:Ionic.Zip.ZipFile.EntriesSorted">ZipFile.EntriesSorted</see> as the
               collection.  See also, <see
               cref="M:Ionic.Zip.ZipFile.GetEnumerator">ZipFile.GetEnumerator()</see>.
             </para>
            
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.InputStream">
             <summary>
             The stream that provides content for the ZipEntry.
             </summary>
            
             <remarks>
            
             <para>
               The application can use this property to set the input stream for an
               entry on a just-in-time basis. Imagine a scenario where the application
               creates a <c>ZipFile</c> comprised of content obtained from hundreds of
               files, via calls to <c>AddFile()</c>. The DotNetZip library opens streams
               on these files on a just-in-time basis, only when writing the entry out to
               an external store within the scope of a <c>ZipFile.Save()</c> call.  Only
               one input stream is opened at a time, as each entry is being written out.
             </para>
            
             <para>
               Now imagine a different application that creates a <c>ZipFile</c>
               with content obtained from hundreds of streams, added through <see
               cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,System.IO.Stream)"/>.  Normally the
               application would supply an open stream to that call.  But when large
               numbers of streams are being added, this can mean many open streams at one
               time, unnecessarily.
             </para>
            
             <para>
               To avoid this, call <see cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,Ionic.Zip.OpenDelegate,Ionic.Zip.CloseDelegate)"/> and specify delegates that open and close the stream at
               the time of Save.
             </para>
            
            
             <para>
               Setting the value of this property when the entry was not added from a
               stream (for example, when the <c>ZipEntry</c> was added with <see
               cref="M:Ionic.Zip.ZipFile.AddFile(System.String)"/> or <see
               cref="M:Ionic.Zip.ZipFile.AddDirectory(System.String)"/>, or when the entry was added by
               reading an existing zip archive) will throw an exception.
             </para>
            
             </remarks>
            
        </member>
        <member name="P:Ionic.Zip.ZipEntry.InputStreamWasJitProvided">
             <summary>
               A flag indicating whether the InputStream was provided Just-in-time.
             </summary>
            
             <remarks>
            
             <para>
               When creating a zip archive, an application can obtain content for one or
               more of the <c>ZipEntry</c> instances from streams, using the <see
               cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,System.IO.Stream)"/> method.  At the time
               of calling that method, the application can supply null as the value of
               the stream parameter.  By doing so, the application indicates to the
               library that it will provide a stream for the entry on a just-in-time
               basis, at the time one of the <c>ZipFile.Save()</c> methods is called and
               the data for the various entries are being compressed and written out.
             </para>
            
             <para>
               In this case, the application can set the <see cref="P:Ionic.Zip.ZipEntry.InputStream"/>
               property, typically within the SaveProgress event (event type: <see
               cref="F:Ionic.Zip.ZipProgressEventType.Saving_BeforeWriteEntry"/>) for that entry.
             </para>
            
             <para>
               The application will later want to call Close() and Dispose() on that
               stream.  In the SaveProgress event, when the event type is <see
               cref="F:Ionic.Zip.ZipProgressEventType.Saving_AfterWriteEntry"/>, the application can
               do so.  This flag indicates that the stream has been provided by the
               application on a just-in-time basis and that it is the application's
               responsibility to call Close/Dispose on that stream.
             </para>
            
             </remarks>
             <seealso cref="P:Ionic.Zip.ZipEntry.InputStream"/>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.Source">
            <summary>
            An enum indicating the source of the ZipEntry.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.VersionNeeded">
             <summary>
             The version of the zip engine needed to read the ZipEntry.
             </summary>
            
             <remarks>
             <para>
               This is a readonly property, indicating the version of <a
               href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">the Zip
               specification</a> that the extracting tool or library must support to
               extract the given entry.  Generally higher versions indicate newer
               features.  Older zip engines obviously won't know about new features, and
               won't be able to extract entries that depend on those newer features.
             </para>
            
             <list type="table">
             <listheader>
             <term>value</term>
             <description>Features</description>
             </listheader>
            
             <item>
             <term>20</term>
             <description>a basic Zip Entry, potentially using PKZIP encryption.
             </description>
             </item>
            
             <item>
             <term>45</term>
             <description>The ZIP64 extension is used on the entry.
             </description>
             </item>
            
             <item>
             <term>46</term>
             <description> File is compressed using BZIP2 compression*</description>
             </item>
            
             <item>
             <term>50</term>
             <description> File is encrypted using PkWare's DES, 3DES, (broken) RC2 or RC4</description>
             </item>
            
             <item>
             <term>51</term>
             <description> File is encrypted using PKWare's AES encryption or corrected RC2 encryption.</description>
             </item>
            
             <item>
             <term>52</term>
             <description> File is encrypted using corrected RC2-64 encryption**</description>
             </item>
            
             <item>
             <term>61</term>
             <description> File is encrypted using non-OAEP key wrapping***</description>
             </item>
            
             <item>
             <term>63</term>
             <description> File is compressed using LZMA, PPMd+, Blowfish, or Twofish</description>
             </item>
            
             </list>
            
             <para>
               There are other values possible, not listed here. DotNetZip supports
               regular PKZip encryption, and ZIP64 extensions.  DotNetZip cannot extract
               entries that require a zip engine higher than 45.
             </para>
            
             <para>
               This value is set upon reading an existing zip file, or after saving a zip
               archive.
             </para>
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.Comment">
             <summary>
             The comment attached to the ZipEntry.
             </summary>
            
             <remarks>
             <para>
               Each entry in a zip file can optionally have a comment associated to
               it. The comment might be displayed by a zip tool during extraction, for
               example.
             </para>
            
             <para>
               By default, the <c>Comment</c> is encoded in IBM437 code page. You can
               specify an alternative with <see cref="P:Ionic.Zip.ZipEntry.AlternateEncoding"/> and
              <see cref="P:Ionic.Zip.ZipEntry.AlternateEncodingUsage"/>.
             </para>
             </remarks>
             <seealso cref="P:Ionic.Zip.ZipEntry.AlternateEncoding"/>
             <seealso cref="P:Ionic.Zip.ZipEntry.AlternateEncodingUsage"/>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.RequiresZip64">
             <summary>
             Indicates whether the entry requires ZIP64 extensions.
             </summary>
            
             <remarks>
            
             <para>
               This property is null (Nothing in VB) until a <c>Save()</c> method on the
               containing <see cref="T:Ionic.Zip.ZipFile"/> instance has been called. The property is
               non-null (<c>HasValue</c> is true) only after a <c>Save()</c> method has
               been called.
             </para>
            
             <para>
               After the containing <c>ZipFile</c> has been saved, the Value of this
               property is true if any of the following three conditions holds: the
               uncompressed size of the entry is larger than 0xFFFFFFFF; the compressed
               size of the entry is larger than 0xFFFFFFFF; the relative offset of the
               entry within the zip archive is larger than 0xFFFFFFFF.  These quantities
               are not known until a <c>Save()</c> is attempted on the zip archive and
               the compression is applied.
             </para>
            
             <para>
               If none of the three conditions holds, then the <c>Value</c> is false.
             </para>
            
             <para>
               A <c>Value</c> of false does not indicate that the entry, as saved in the
               zip archive, does not use ZIP64.  It merely indicates that ZIP64 is
               <em>not required</em>.  An entry may use ZIP64 even when not required if
               the <see cref="P:Ionic.Zip.ZipFile.UseZip64WhenSaving"/> property on the containing
               <c>ZipFile</c> instance is set to <see cref="F:Ionic.Zip.Zip64Option.Always"/>, or if
               the <see cref="P:Ionic.Zip.ZipFile.UseZip64WhenSaving"/> property on the containing
               <c>ZipFile</c> instance is set to <see cref="F:Ionic.Zip.Zip64Option.AsNecessary"/>
               and the output stream was not seekable.
             </para>
            
             </remarks>
             <seealso cref="P:Ionic.Zip.ZipEntry.OutputUsedZip64"/>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.OutputUsedZip64">
             <summary>
               Indicates whether the entry actually used ZIP64 extensions, as it was most
               recently written to the output file or stream.
             </summary>
            
             <remarks>
            
             <para>
               This Nullable property is null (Nothing in VB) until a <c>Save()</c>
               method on the containing <see cref="T:Ionic.Zip.ZipFile"/> instance has been
               called. <c>HasValue</c> is true only after a <c>Save()</c> method has been
               called.
             </para>
            
             <para>
               The value of this property for a particular <c>ZipEntry</c> may change
               over successive calls to <c>Save()</c> methods on the containing ZipFile,
               even if the file that corresponds to the <c>ZipEntry</c> does not. This
               may happen if other entries contained in the <c>ZipFile</c> expand,
               causing the offset for this particular entry to exceed 0xFFFFFFFF.
             </para>
             </remarks>
             <seealso cref="P:Ionic.Zip.ZipEntry.RequiresZip64"/>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.BitField">
             <summary>
               The bitfield for the entry as defined in the zip spec. You probably
               never need to look at this.
             </summary>
            
             <remarks>
             <para>
               You probably do not need to concern yourself with the contents of this
               property, but in case you do:
             </para>
            
             <list type="table">
             <listheader>
             <term>bit</term>
             <description>meaning</description>
             </listheader>
            
             <item>
             <term>0</term>
             <description>set if encryption is used.</description>
             </item>
            
             <item>
             <term>1-2</term>
             <description>
             set to determine whether normal, max, fast deflation.  DotNetZip library
             always leaves these bits unset when writing (indicating "normal"
             deflation"), but can read an entry with any value here.
             </description>
             </item>
            
             <item>
             <term>3</term>
             <description>
             Indicates that the Crc32, Compressed and Uncompressed sizes are zero in the
             local header.  This bit gets set on an entry during writing a zip file, when
             it is saved to a non-seekable output stream.
             </description>
             </item>
            
            
             <item>
             <term>4</term>
             <description>reserved for "enhanced deflating". This library doesn't do enhanced deflating.</description>
             </item>
            
             <item>
             <term>5</term>
             <description>set to indicate the zip is compressed patched data.  This library doesn't do that.</description>
             </item>
            
             <item>
             <term>6</term>
             <description>
             set if PKWare's strong encryption is used (must also set bit 1 if bit 6 is
             set). This bit is not set if WinZip's AES encryption is set.</description>
             </item>
            
             <item>
             <term>7</term>
             <description>not used</description>
             </item>
            
             <item>
             <term>8</term>
             <description>not used</description>
             </item>
            
             <item>
             <term>9</term>
             <description>not used</description>
             </item>
            
             <item>
             <term>10</term>
             <description>not used</description>
             </item>
            
             <item>
             <term>11</term>
             <description>
             Language encoding flag (EFS).  If this bit is set, the filename and comment
             fields for this file must be encoded using UTF-8. This library currently
             does not support UTF-8.
             </description>
             </item>
            
             <item>
             <term>12</term>
             <description>Reserved by PKWARE for enhanced compression.</description>
             </item>
            
             <item>
             <term>13</term>
             <description>
               Used when encrypting the Central Directory to indicate selected data
               values in the Local Header are masked to hide their actual values.  See
               the section in <a
               href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">the Zip
               specification</a> describing the Strong Encryption Specification for
               details.
             </description>
             </item>
            
             <item>
             <term>14</term>
             <description>Reserved by PKWARE.</description>
             </item>
            
             <item>
             <term>15</term>
             <description>Reserved by PKWARE.</description>
             </item>
            
             </list>
            
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.CompressionMethod">
             <summary>
               The compression method employed for this ZipEntry.
             </summary>
            
             <remarks>
            
             <para>
               <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">The
               Zip specification</see> allows a variety of compression methods.  This
               library supports just two: 0x08 = Deflate.  0x00 = Store (no compression),
               for reading or writing.
             </para>
            
             <para>
               When reading an entry from an existing zipfile, the value you retrieve
               here indicates the compression method used on the entry by the original
               creator of the zip.  When writing a zipfile, you can specify either 0x08
               (Deflate) or 0x00 (None).  If you try setting something else, you will get
               an exception.
             </para>
            
             <para>
               You may wish to set <c>CompressionMethod</c> to <c>CompressionMethod.None</c> (0)
               when zipping already-compressed data like a jpg, png, or mp3 file.
               This can save time and cpu cycles.
             </para>
            
             <para>
               When setting this property on a <c>ZipEntry</c> that is read from an
               existing zip file, calling <c>ZipFile.Save()</c> will cause the new
               CompressionMethod to be used on the entry in the newly saved zip file.
             </para>
            
             <para>
               Setting this property may have the side effect of modifying the
               <c>CompressionLevel</c> property. If you set the <c>CompressionMethod</c> to a
               value other than <c>None</c>, and <c>CompressionLevel</c> is previously
               set to <c>None</c>, then <c>CompressionLevel</c> will be set to
               <c>Default</c>.
             </para>
             </remarks>
            
             <seealso cref="P:Ionic.Zip.ZipEntry.CompressionMethod"/>
            
             <example>
               In this example, the first entry added to the zip archive uses the default
               behavior - compression is used where it makes sense.  The second entry,
               the MP3 file, is added to the archive without being compressed.
             <code>
             using (ZipFile zip = new ZipFile(ZipFileToCreate))
             {
               ZipEntry e1= zip.AddFile(@"notes\Readme.txt");
               ZipEntry e2= zip.AddFile(@"music\StopThisTrain.mp3");
               e2.CompressionMethod = CompressionMethod.None;
               zip.Save();
             }
             </code>
            
             <code lang="VB">
             Using zip As New ZipFile(ZipFileToCreate)
               zip.AddFile("notes\Readme.txt")
               Dim e2 as ZipEntry = zip.AddFile("music\StopThisTrain.mp3")
               e2.CompressionMethod = CompressionMethod.None
               zip.Save
             End Using
             </code>
             </example>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.CompressionLevel">
             <summary>
               Sets the compression level to be used for the entry when saving the zip
               archive. This applies only for CompressionMethod = DEFLATE.
             </summary>
            
             <remarks>
              <para>
                When using the DEFLATE compression method, Varying the compression
                level used on entries can affect the size-vs-speed tradeoff when
                compression and decompressing data streams or files.
              </para>
            
              <para>
                If you do not set this property, the default compression level is used,
                which normally gives a good balance of compression efficiency and
                compression speed.  In some tests, using <c>BestCompression</c> can
                double the time it takes to compress, while delivering just a small
                increase in compression efficiency.  This behavior will vary with the
                type of data you compress.  If you are in doubt, just leave this setting
                alone, and accept the default.
              </para>
            
              <para>
                When setting this property on a <c>ZipEntry</c> that is read from an
                existing zip file, calling <c>ZipFile.Save()</c> will cause the new
                <c>CompressionLevel</c> to be used on the entry in the newly saved zip file.
              </para>
            
              <para>
                Setting this property may have the side effect of modifying the
                <c>CompressionMethod</c> property. If you set the <c>CompressionLevel</c>
                to a value other than <c>None</c>, <c>CompressionMethod</c> will be set
                to <c>Deflate</c>, if it was previously <c>None</c>.
              </para>
            
              <para>
                Setting this property has no effect if the <c>CompressionMethod</c> is something
                other than <c>Deflate</c> or <c>None</c>.
              </para>
             </remarks>
            
             <seealso cref="P:Ionic.Zip.ZipEntry.CompressionMethod"/>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.CompressedSize">
             <summary>
               The compressed size of the file, in bytes, within the zip archive.
             </summary>
            
             <remarks>
               When reading a <c>ZipFile</c>, this value is read in from the existing
               zip file. When creating or updating a <c>ZipFile</c>, the compressed
               size is computed during compression.  Therefore the value on a
               <c>ZipEntry</c> is valid after a call to <c>Save()</c> (or one of its
               overloads) in that case.
             </remarks>
            
             <seealso cref="P:Ionic.Zip.ZipEntry.UncompressedSize"/>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.UncompressedSize">
             <summary>
               The size of the file, in bytes, before compression, or after extraction.
             </summary>
            
             <remarks>
               When reading a <c>ZipFile</c>, this value is read in from the existing
               zip file. When creating or updating a <c>ZipFile</c>, the uncompressed
               size is computed during compression.  Therefore the value on a
               <c>ZipEntry</c> is valid after a call to <c>Save()</c> (or one of its
               overloads) in that case.
             </remarks>
            
             <seealso cref="P:Ionic.Zip.ZipEntry.CompressedSize"/>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.CompressionRatio">
             <summary>
             The ratio of compressed size to uncompressed size of the ZipEntry.
             </summary>
            
             <remarks>
             <para>
               This is a ratio of the compressed size to the uncompressed size of the
               entry, expressed as a double in the range of 0 to 100+. A value of 100
               indicates no compression at all.  It could be higher than 100 when the
               compression algorithm actually inflates the data, as may occur for small
               files, or uncompressible data that is encrypted.
             </para>
            
             <para>
               You could format it for presentation to a user via a format string of
               "{3,5:F0}%" to see it as a percentage.
             </para>
            
             <para>
               If the size of the original uncompressed file is 0, implying a
               denominator of 0, the return value will be zero.
             </para>
            
             <para>
               This property is valid after reading in an existing zip file, or after
               saving the <c>ZipFile</c> that contains the ZipEntry. You cannot know the
               effect of a compression transform until you try it.
             </para>
            
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.Crc">
             <summary>
             The 32-bit CRC (Cyclic Redundancy Check) on the contents of the ZipEntry.
             </summary>
            
             <remarks>
            
             <para> You probably don't need to concern yourself with this. It is used
             internally by DotNetZip to verify files or streams upon extraction.  </para>
            
             <para> The value is a <see href="http://en.wikipedia.org/wiki/CRC32">32-bit
             CRC</see> using 0xEDB88320 for the polynomial. This is the same CRC-32 used in
             PNG, MPEG-2, and other protocols and formats.  It is a read-only property; when
             creating a Zip archive, the CRC for each entry is set only after a call to
             <c>Save()</c> on the containing ZipFile. When reading an existing zip file, the value
             of this property reflects the stored CRC for the entry.  </para>
            
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.IsDirectory">
            <summary>
            True if the entry is a directory (not a file).
            This is a readonly property on the entry.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.UsesEncryption">
             <summary>
             A derived property that is <c>true</c> if the entry uses encryption.
             </summary>
            
             <remarks>
             <para>
               This is a readonly property on the entry.  When reading a zip file,
               the value for the <c>ZipEntry</c> is determined by the data read
               from the zip file.  After saving a ZipFile, the value of this
               property for each <c>ZipEntry</c> indicates whether encryption was
               actually used (which will have been true if the <see
               cref="P:Ionic.Zip.ZipEntry.Password"/> was set and the <see cref="P:Ionic.Zip.ZipEntry.Encryption"/> property
               was something other than <see cref="F:Ionic.Zip.EncryptionAlgorithm.None"/>.
             </para>
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.Encryption">
             <summary>
               Set this to specify which encryption algorithm to use for the entry when
               saving it to a zip archive.
             </summary>
            
             <remarks>
            
             <para>
               Set this property in order to encrypt the entry when the <c>ZipFile</c> is
               saved. When setting this property, you must also set a <see
               cref="P:Ionic.Zip.ZipEntry.Password"/> on the entry.  If you set a value other than <see
               cref="F:Ionic.Zip.EncryptionAlgorithm.None"/> on this property and do not set a
               <c>Password</c> then the entry will not be encrypted. The <c>ZipEntry</c>
               data is encrypted as the <c>ZipFile</c> is saved, when you call <see
               cref="M:Ionic.Zip.ZipFile.Save"/> or one of its cousins on the containing
               <c>ZipFile</c> instance. You do not need to specify the <c>Encryption</c>
               when extracting entries from an archive.
             </para>
            
             <para>
               The Zip specification from PKWare defines a set of encryption algorithms,
               and the data formats for the zip archive that support them, and PKWare
               supports those algorithms in the tools it produces. Other vendors of tools
               and libraries, such as WinZip or Xceed, typically support <em>a
               subset</em> of the algorithms specified by PKWare. These tools can
               sometimes support additional different encryption algorithms and data
               formats, not specified by PKWare. The AES Encryption specified and
               supported by WinZip is the most popular example. This library supports a
               subset of the complete set of algorithms specified by PKWare and other
               vendors.
             </para>
            
             <para>
               There is no common, ubiquitous multi-vendor standard for strong encryption
               within zip files. There is broad support for so-called "traditional" Zip
               encryption, sometimes called Zip 2.0 encryption, as <see
               href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">specified
               by PKWare</see>, but this encryption is considered weak and
               breakable. This library currently supports the Zip 2.0 "weak" encryption,
               and also a stronger WinZip-compatible AES encryption, using either 128-bit
               or 256-bit key strength. If you want DotNetZip to support an algorithm
               that is not currently supported, call the author of this library and maybe
               we can talk business.
             </para>
            
             <para>
               The <see cref="T:Ionic.Zip.ZipFile"/> class also has a <see
               cref="P:Ionic.Zip.ZipFile.Encryption"/> property.  In most cases you will use
               <em>that</em> property when setting encryption. This property takes
               precedence over any <c>Encryption</c> set on the <c>ZipFile</c> itself.
               Typically, you would use the per-entry Encryption when most entries in the
               zip archive use one encryption algorithm, and a few entries use a
               different one.  If all entries in the zip file use the same Encryption,
               then it is simpler to just set this property on the ZipFile itself, when
               creating a zip archive.
             </para>
            
             <para>
               Some comments on updating archives: If you read a <c>ZipFile</c>, you can
               modify the Encryption on an encrypted entry: you can remove encryption
               from an entry that was encrypted; you can encrypt an entry that was not
               encrypted previously; or, you can change the encryption algorithm.  The
               changes in encryption are not made permanent until you call Save() on the
               <c>ZipFile</c>.  To effect changes in encryption, the entry content is
               streamed through several transformations, depending on the modification
               the application has requested. For example if the entry is not encrypted
               and the application sets <c>Encryption</c> to <c>PkzipWeak</c>, then at
               the time of <c>Save()</c>, the original entry is read and decompressed,
               then re-compressed and encrypted.  Conversely, if the original entry is
               encrypted with <c>PkzipWeak</c> encryption, and the application sets the
               <c>Encryption</c> property to <c>WinZipAes128</c>, then at the time of
               <c>Save()</c>, the original entry is decrypted via PKZIP encryption and
               decompressed, then re-compressed and re-encrypted with AES.  This all
               happens automatically within the library, but it can be time-consuming for
               large entries.
             </para>
            
             <para>
               Additionally, when updating archives, it is not possible to change the
               password when changing the encryption algorithm.  To change both the
               algorithm and the password, you need to Save() the zipfile twice.  First
               set the <c>Encryption</c> to None, then call <c>Save()</c>.  Then set the
               <c>Encryption</c> to the new value (not "None"), then call <c>Save()</c>
               once again.
             </para>
            
             <para>
               The WinZip AES encryption algorithms are not supported on the .NET Compact
               Framework.
             </para>
             </remarks>
            
             <example>
             <para>
               This example creates a zip archive that uses encryption, and then extracts
               entries from the archive.  When creating the zip archive, the ReadMe.txt
               file is zipped without using a password or encryption.  The other file
               uses encryption.
             </para>
             <code>
             // Create a zip archive with AES Encryption.
             using (ZipFile zip = new ZipFile())
             {
                 zip.AddFile("ReadMe.txt")
                 ZipEntry e1= zip.AddFile("2008-Regional-Sales-Report.pdf");
                 e1.Encryption= EncryptionAlgorithm.WinZipAes256;
                 e1.Password= "Top.Secret.No.Peeking!";
                 zip.Save("EncryptedArchive.zip");
             }
            
             // Extract a zip archive that uses AES Encryption.
             // You do not need to specify the algorithm during extraction.
             using (ZipFile zip = ZipFile.Read("EncryptedArchive.zip"))
             {
                 // Specify the password that is used during extraction, for
                 // all entries that require a password:
                 zip.Password= "Top.Secret.No.Peeking!";
                 zip.ExtractAll("extractDirectory");
             }
             </code>
            
             <code lang="VB">
             ' Create a zip that uses Encryption.
             Using zip As New ZipFile()
                 zip.AddFile("ReadMe.txt")
                 Dim e1 as ZipEntry
                 e1= zip.AddFile("2008-Regional-Sales-Report.pdf")
                 e1.Encryption= EncryptionAlgorithm.WinZipAes256
                 e1.Password= "Top.Secret.No.Peeking!"
                 zip.Save("EncryptedArchive.zip")
             End Using
            
             ' Extract a zip archive that uses AES Encryption.
             ' You do not need to specify the algorithm during extraction.
             Using (zip as ZipFile = ZipFile.Read("EncryptedArchive.zip"))
                 ' Specify the password that is used during extraction, for
                 ' all entries that require a password:
                 zip.Password= "Top.Secret.No.Peeking!"
                 zip.ExtractAll("extractDirectory")
             End Using
             </code>
            
             </example>
            
             <exception cref="T:System.InvalidOperationException">
             Thrown in the setter if EncryptionAlgorithm.Unsupported is specified.
             </exception>
            
             <seealso cref="P:Ionic.Zip.ZipEntry.Password">ZipEntry.Password</seealso>
             <seealso cref="P:Ionic.Zip.ZipFile.Encryption">ZipFile.Encryption</seealso>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.Password">
             <summary>
             The Password to be used when encrypting a <c>ZipEntry</c> upon
             <c>ZipFile.Save()</c>, or when decrypting an entry upon Extract().
             </summary>
            
             <remarks>
             <para>
               This is a write-only property on the entry. Set this to request that the
               entry be encrypted when writing the zip archive, or set it to specify the
               password to be used when extracting an existing entry that is encrypted.
             </para>
            
             <para>
               The password set here is implicitly used to encrypt the entry during the
               <see cref="M:Ionic.Zip.ZipFile.Save"/> operation, or to decrypt during the <see
               cref="M:Ionic.Zip.ZipEntry.Extract"/> or <see cref="M:Ionic.Zip.ZipEntry.OpenReader"/> operation.  If you set
               the Password on a <c>ZipEntry</c> after calling <c>Save()</c>, there is no
               effect.
             </para>
            
             <para>
               Consider setting the <see cref="P:Ionic.Zip.ZipEntry.Encryption"/> property when using a
               password. Answering concerns that the standard password protection
               supported by all zip tools is weak, WinZip has extended the ZIP
               specification with a way to use AES Encryption to protect entries in the
               Zip file. Unlike the "PKZIP 2.0" encryption specified in the PKZIP
               specification, <see href=
               "http://en.wikipedia.org/wiki/Advanced_Encryption_Standard">AES
               Encryption</see> uses a standard, strong, tested, encryption
               algorithm. DotNetZip can create zip archives that use WinZip-compatible
               AES encryption, if you set the <see cref="P:Ionic.Zip.ZipEntry.Encryption"/> property. But,
               archives created that use AES encryption may not be readable by all other
               tools and libraries. For example, Windows Explorer cannot read a
               "compressed folder" (a zip file) that uses AES encryption, though it can
               read a zip file that uses "PKZIP encryption."
             </para>
            
             <para>
               The <see cref="T:Ionic.Zip.ZipFile"/> class also has a <see cref="P:Ionic.Zip.ZipFile.Password"/>
               property.  This property takes precedence over any password set on the
               ZipFile itself.  Typically, you would use the per-entry Password when most
               entries in the zip archive use one password, and a few entries use a
               different password.  If all entries in the zip file use the same password,
               then it is simpler to just set this property on the ZipFile itself,
               whether creating a zip archive or extracting a zip archive.
             </para>
            
             <para>
               Some comments on updating archives: If you read a <c>ZipFile</c>, you
               cannot modify the password on any encrypted entry, except by extracting
               the entry with the original password (if any), removing the original entry
               via <see cref="M:Ionic.Zip.ZipFile.RemoveEntry(Ionic.Zip.ZipEntry)"/>, and then adding a new
               entry with a new Password.
             </para>
            
             <para>
               For example, suppose you read a <c>ZipFile</c>, and there is an encrypted
               entry.  Setting the Password property on that <c>ZipEntry</c> and then
               calling <c>Save()</c> on the <c>ZipFile</c> does not update the password
               on that entry in the archive.  Neither is an exception thrown. Instead,
               what happens during the <c>Save()</c> is the existing entry is copied
               through to the new zip archive, in its original encrypted form. Upon
               re-reading that archive, the entry can be decrypted with its original
               password.
             </para>
            
             <para>
               If you read a ZipFile, and there is an un-encrypted entry, you can set the
               <c>Password</c> on the entry and then call Save() on the ZipFile, and get
               encryption on that entry.
             </para>
            
             </remarks>
            
             <example>
             <para>
               This example creates a zip file with two entries, and then extracts the
               entries from the zip file.  When creating the zip file, the two files are
               added to the zip file using password protection. Each entry uses a
               different password.  During extraction, each file is extracted with the
               appropriate password.
             </para>
             <code>
             // create a file with encryption
             using (ZipFile zip = new ZipFile())
             {
                 ZipEntry entry;
                 entry= zip.AddFile("Declaration.txt");
                 entry.Password= "123456!";
                 entry = zip.AddFile("Report.xls");
                 entry.Password= "1Secret!";
                 zip.Save("EncryptedArchive.zip");
             }
            
             // extract entries that use encryption
             using (ZipFile zip = ZipFile.Read("EncryptedArchive.zip"))
             {
                 ZipEntry entry;
                 entry = zip["Declaration.txt"];
                 entry.Password = "123456!";
                 entry.Extract("extractDir");
                 entry = zip["Report.xls"];
                 entry.Password = "1Secret!";
                 entry.Extract("extractDir");
             }
            
             </code>
            
             <code lang="VB">
             Using zip As New ZipFile
                 Dim entry as ZipEntry
                 entry= zip.AddFile("Declaration.txt")
                 entry.Password= "123456!"
                 entry = zip.AddFile("Report.xls")
                 entry.Password= "1Secret!"
                 zip.Save("EncryptedArchive.zip")
             End Using
            
            
             ' extract entries that use encryption
             Using (zip as ZipFile = ZipFile.Read("EncryptedArchive.zip"))
                 Dim entry as ZipEntry
                 entry = zip("Declaration.txt")
                 entry.Password = "123456!"
                 entry.Extract("extractDir")
                 entry = zip("Report.xls")
                 entry.Password = "1Secret!"
                 entry.Extract("extractDir")
             End Using
            
             </code>
            
             </example>
            
             <seealso cref="P:Ionic.Zip.ZipEntry.Encryption"/>
             <seealso cref="P:Ionic.Zip.ZipFile.Password">ZipFile.Password</seealso>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.ExtractExistingFile">
             <summary>
             The action the library should take when extracting a file that already exists.
             </summary>
            
             <remarks>
               <para>
                 This property affects the behavior of the Extract methods (one of the
                 <c>Extract()</c> or <c>ExtractWithPassword()</c> overloads), when
                 extraction would would overwrite an existing filesystem file. If you do
                 not set this property, the library throws an exception when extracting
                 an entry would overwrite an existing file.
               </para>
            
               <para>
                 This property has no effect when extracting to a stream, or when the file to be
                 extracted does not already exist.
               </para>
            
             </remarks>
             <seealso cref="P:Ionic.Zip.ZipFile.ExtractExistingFile"/>
            
             <example>
               This example shows how to set the <c>ExtractExistingFile</c> property in
               an <c>ExtractProgress</c> event, in response to user input. The
               <c>ExtractProgress</c> event is invoked if and only if the
               <c>ExtractExistingFile</c> property was previously set to
               <c>ExtractExistingFileAction.InvokeExtractProgressEvent</c>.
             <code lang="C#">
             public static void ExtractProgress(object sender, ExtractProgressEventArgs e)
             {
                 if (e.EventType == ZipProgressEventType.Extracting_BeforeExtractEntry)
                     Console.WriteLine("extract {0} ", e.CurrentEntry.FileName);
            
                 else if (e.EventType == ZipProgressEventType.Extracting_ExtractEntryWouldOverwrite)
                 {
                     ZipEntry entry = e.CurrentEntry;
                     string response = null;
                     // Ask the user if he wants overwrite the file
                     do
                     {
                         Console.Write("Overwrite {0} in {1} ? (y/n/C) ", entry.FileName, e.ExtractLocation);
                         response = Console.ReadLine();
                         Console.WriteLine();
            
                     } while (response != null &amp;&amp; response[0]!='Y' &amp;&amp;
                              response[0]!='N' &amp;&amp; response[0]!='C');
            
                     if  (response[0]=='C')
                         e.Cancel = true;
                     else if (response[0]=='Y')
                         entry.ExtractExistingFile = ExtractExistingFileAction.OverwriteSilently;
                     else
                         entry.ExtractExistingFile= ExtractExistingFileAction.DoNotOverwrite;
                 }
             }
             </code>
             </example>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.ZipErrorAction">
             <summary>
               The action to take when an error is encountered while
               opening or reading files as they are saved into a zip archive.
             </summary>
            
             <remarks>
              <para>
                 Errors can occur within a call to <see
                 cref="M:Ionic.Zip.ZipFile.Save">ZipFile.Save</see>, as the various files contained
                 in a ZipFile are being saved into the zip archive.  During the
                 <c>Save</c>, DotNetZip will perform a <c>File.Open</c> on the file
                 associated to the ZipEntry, and then will read the entire contents of
                 the file as it is zipped. Either the open or the Read may fail, because
                 of lock conflicts or other reasons.  Using this property, you can
                 specify the action to take when such errors occur.
              </para>
            
              <para>
                 Typically you will NOT set this property on individual ZipEntry
                 instances.  Instead, you will set the <see
                 cref="P:Ionic.Zip.ZipFile.ZipErrorAction">ZipFile.ZipErrorAction</see> property on
                 the ZipFile instance, before adding any entries to the
                 <c>ZipFile</c>. If you do this, errors encountered on behalf of any of
                 the entries in the ZipFile will be handled the same way.
              </para>
            
              <para>
                 But, if you use a <see cref="E:Ionic.Zip.ZipFile.ZipError"/> handler, you will want
                 to set this property on the <c>ZipEntry</c> within the handler, to
                 communicate back to DotNetZip what you would like to do with the
                 particular error.
              </para>
            
             </remarks>
             <seealso cref="P:Ionic.Zip.ZipFile.ZipErrorAction"/>
             <seealso cref="E:Ionic.Zip.ZipFile.ZipError"/>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.IncludedInMostRecentSave">
            <summary>
            Indicates whether the entry was included in the most recent save.
            </summary>
            <remarks>
            An entry can be excluded or skipped from a save if there is an error
            opening or reading the entry.
            </remarks>
            <seealso cref="P:Ionic.Zip.ZipEntry.ZipErrorAction"/>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.SetCompression">
             <summary>
               A callback that allows the application to specify the compression to use
               for a given entry that is about to be added to the zip archive.
             </summary>
            
             <remarks>
             <para>
               See <see cref="P:Ionic.Zip.ZipFile.SetCompression" />
             </para>
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.AlternateEncoding">
            <summary>
              Specifies the alternate text encoding used by this ZipEntry
            </summary>
            <remarks>
              <para>
                The default text encoding used in Zip files for encoding filenames and
                comments is IBM437, which is something like a superset of ASCII.  In
                cases where this is insufficient, applications can specify an
                alternate encoding.
              </para>
              <para>
                When creating a zip file, the usage of the alternate encoding is
                governed by the <see cref="P:Ionic.Zip.ZipEntry.AlternateEncodingUsage"/> property.
                Typically you would set both properties to tell DotNetZip to employ an
                encoding that is not IBM437 in the zipfile you are creating.
              </para>
              <para>
                Keep in mind that because the ZIP specification states that the only
                valid encodings to use are IBM437 and UTF-8, if you use something
                other than that, then zip tools and libraries may not be able to
                successfully read the zip archive you generate.
              </para>
              <para>
                The zip specification states that applications should presume that
                IBM437 is in use, except when a special bit is set, which indicates
                UTF-8. There is no way to specify an arbitrary code page, within the
                zip file itself. When you create a zip file encoded with gb2312 or
                ibm861 or anything other than IBM437 or UTF-8, then the application
                that reads the zip file needs to "know" which code page to use. In
                some cases, the code page used when reading is chosen implicitly. For
                example, WinRar uses the ambient code page for the host desktop
                operating system. The pitfall here is that if you create a zip in
                Copenhagen and send it to Tokyo, the reader of the zipfile may not be
                able to decode successfully.
              </para>
            </remarks>
            <example>
              This example shows how to create a zipfile encoded with a
              language-specific encoding:
            <code>
              using (var zip = new ZipFile())
              {
                 zip.AlternateEnoding = System.Text.Encoding.GetEncoding("ibm861");
                 zip.AlternateEnodingUsage = ZipOption.Always;
                 zip.AddFileS(arrayOfFiles);
                 zip.Save("Myarchive-Encoded-in-IBM861.zip");
              }
            </code>
            </example>
            <seealso cref="P:Ionic.Zip.ZipFile.AlternateEncodingUsage" />
        </member>
        <member name="P:Ionic.Zip.ZipEntry.AlternateEncodingUsage">
            <summary>
              Describes if and when this instance should apply
              AlternateEncoding to encode the FileName and Comment, when
              saving.
            </summary>
            <seealso cref="P:Ionic.Zip.ZipFile.AlternateEncoding" />
        </member>
        <member name="P:Ionic.Zip.ZipEntry.IsText">
             <summary>
               Indicates whether an entry is marked as a text file. Be careful when
               using on this property. Unless you have a good reason, you should
               probably ignore this property.
             </summary>
            
             <remarks>
             <para>
               The ZIP format includes a provision for specifying whether an entry in
               the zip archive is a text or binary file.  This property exposes that
               metadata item. Be careful when using this property: It's not clear
               that this property as a firm meaning, across tools and libraries.
             </para>
            
             <para>
               To be clear, when reading a zip file, the property value may or may
               not be set, and its value may or may not be valid.  Not all entries
               that you may think of as "text" entries will be so marked, and entries
               marked as "text" are not guaranteed in any way to be text entries.
               Whether the value is set and set correctly depends entirely on the
               application that produced the zip file.
             </para>
            
             <para>
               There are many zip tools available, and when creating zip files, some
               of them "respect" the IsText metadata field, and some of them do not.
               Unfortunately, even when an application tries to do "the right thing",
               it's not always clear what "the right thing" is.
             </para>
            
             <para>
               There's no firm definition of just what it means to be "a text file",
               and the zip specification does not help in this regard. Twenty years
               ago, text was ASCII, each byte was less than 127. IsText meant, all
               bytes in the file were less than 127.  These days, it is not the case
               that all text files have all bytes less than 127.  Any unicode file
               may have bytes that are above 0x7f.  The zip specification has nothing
               to say on this topic. Therefore, it's not clear what IsText really
               means.
             </para>
            
             <para>
               This property merely tells a reading application what is stored in the
               metadata for an entry, without guaranteeing its validity or its
               meaning.
             </para>
            
             <para>
               When DotNetZip is used to create a zipfile, it attempts to set this
               field "correctly." For example, if a file ends in ".txt", this field
               will be set. Your application may override that default setting.  When
               writing a zip file, you must set the property before calling
               <c>Save()</c> on the ZipFile.
             </para>
            
             <para>
               When reading a zip file, a more general way to decide just what kind
               of file is contained in a particular entry is to use the file type
               database stored in the operating system.  The operating system stores
               a table that says, a file with .jpg extension is a JPG image file, a
               file with a .xml extension is an XML document, a file with a .txt is a
               pure ASCII text document, and so on.  To get this information on
               Windows, <see
               href="http://www.codeproject.com/KB/cs/GetFileTypeAndIcon.aspx"> you
               need to read and parse the registry.</see> </para>
             </remarks>
            
             <example>
             <code>
             using (var zip = new ZipFile())
             {
                 var e = zip.UpdateFile("Descriptions.mme", "");
                 e.IsText = true;
                 zip.Save(zipPath);
             }
             </code>
            
             <code lang="VB">
             Using zip As New ZipFile
                 Dim e2 as ZipEntry = zip.AddFile("Descriptions.mme", "")
                 e.IsText= True
                 zip.Save(zipPath)
             End Using
             </code>
             </example>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.ToString">
            <summary>Provides a string representation of the instance.</summary>
            <returns>a string representation of the instance.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.ReadEntry(Ionic.Zip.ZipContainer,System.Boolean)">
            <summary>
              Reads one <c>ZipEntry</c> from the given stream.  The content for
              the entry does not get decompressed or decrypted.  This method
              basically reads metadata, and seeks.
            </summary>
            <param name="zc">the ZipContainer this entry belongs to.</param>
            <param name="first">
              true of this is the first entry being read from the stream.
            </param>
            <returns>the <c>ZipEntry</c> read from the stream.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.FindExtraFieldSegment(System.Byte[],System.Int32,System.UInt16)">
            <summary>
              Finds a particular segment in the given extra field.
              This is used when modifying a previously-generated
              extra field, in particular when removing the AES crypto
              segment in the extra field.
            </summary>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.ProcessExtraField(System.IO.Stream,System.Int16)">
            <summary>
              At current cursor position in the stream, read the extra
              field, and set the properties on the ZipEntry instance
              appropriately.  This can be called when processing the
              Extra field in the Central Directory, or in the local
              header.
            </summary>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.GetEncodedFileNameBytes">
            <summary>
              generate and return a byte array that encodes the filename
              for the entry.
            </summary>
            <remarks>
              <para>
                side effects: generate and store into _CommentBytes the
                byte array for any comment attached to the entry. Also
                sets _actualEncoding to indicate the actual encoding
                used. The same encoding is used for both filename and
                comment.
              </para>
            </remarks>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.PrepSourceStream">
             <summary>
               Stores the position of the entry source stream, or, if the position is
               already stored, seeks to that position.
             </summary>
            
             <remarks>
             <para>
               This method is called in prep for reading the source stream.  If PKZIP
               encryption is used, then we need to calc the CRC32 before doing the
               encryption, because the CRC is used in the 12th byte of the PKZIP
               encryption header.  So, we need to be able to seek backward in the source
               when saving the ZipEntry. This method is called from the place that
               calculates the CRC, and also from the method that does the encryption of
               the file data.
             </para>
            
             <para>
               The first time through, this method sets the _sourceStreamOriginalPosition
               field. Subsequent calls to this method seek to that position.
             </para>
             </remarks>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.CopyMetaData(Ionic.Zip.ZipEntry)">
            <summary>
            Copy metadata that may have been changed by the app.  We do this when
            resetting the zipFile instance.  If the app calls Save() on a ZipFile, then
            tries to party on that file some more, we may need to Reset() it , which
            means re-reading the entries and then copying the metadata.  I think.
            </summary>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.SetInputAndFigureFileLength(System.IO.Stream@)">
            <summary>
              Set the input stream and get its length, if possible.  The length is
              used for progress updates, AND, to allow an optimization in case of
              a stream/file of zero length. In that case we skip the Encrypt and
              compression Stream. (like DeflateStream or BZip2OutputStream)
            </summary>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.PrepOutputStream(System.IO.Stream,System.Int64,Ionic.Zip.CountingStream@,System.IO.Stream@,System.IO.Stream@,Ionic.Crc.CrcCalculatorStream@)">
            <summary>
              Prepare the given stream for output - wrap it in a CountingStream, and
              then in a CRC stream, and an encryptor and deflator as appropriate.
            </summary>
            <remarks>
              <para>
                Previously this was used in ZipEntry.Write(), but in an effort to
                introduce some efficiencies in that method I've refactored to put the
                code inline.  This method still gets called by ZipOutputStream.
              </para>
            </remarks>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.Extract">
             <summary>
               Extract the entry to the filesystem, starting at the current
               working directory.
             </summary>
            
             <overloads>
               This method has a bunch of overloads! One of them is sure to
               be the right one for you... If you don't like these, check
               out the <c>ExtractWithPassword()</c> methods.
             </overloads>
            
             <seealso cref="P:Ionic.Zip.ZipEntry.ExtractExistingFile"/>
             <seealso cref="M:Ionic.Zip.ZipEntry.Extract(Ionic.Zip.ExtractExistingFileAction)"/>
            
             <remarks>
            
             <para>
               This method extracts an entry from a zip file into the current
               working directory.  The path of the entry as extracted is the full
               path as specified in the zip archive, relative to the current
               working directory.  After the file is extracted successfully, the
               file attributes and timestamps are set.
             </para>
            
             <para>
               The action taken when extraction an entry would overwrite an
               existing file is determined by the <see cref="P:Ionic.Zip.ZipEntry.ExtractExistingFile"
               /> property.
             </para>
            
             <para>
               Within the call to <c>Extract()</c>, the content for the entry is
               written into a filesystem file, and then the last modified time of the
               file is set according to the <see cref="P:Ionic.Zip.ZipEntry.LastModified"/> property on
               the entry. See the remarks the <see cref="P:Ionic.Zip.ZipEntry.LastModified"/> property for
               some details about the last modified time.
             </para>
            
             </remarks>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.Extract(Ionic.Zip.ExtractExistingFileAction)">
             <summary>
               Extract the entry to a file in the filesystem, using the specified
               behavior when extraction would overwrite an existing file.
             </summary>
            
             <remarks>
             <para>
               See the remarks on the <see cref="P:Ionic.Zip.ZipEntry.LastModified"/> property, for some
               details about how the last modified time of the file is set after
               extraction.
             </para>
             </remarks>
            
             <param name="extractExistingFile">
               The action to take if extraction would overwrite an existing file.
             </param>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.Extract(System.IO.Stream)">
             <summary>
               Extracts the entry to the specified stream.
             </summary>
            
             <remarks>
             <para>
               The caller can specify any write-able stream, for example a <see
               cref="T:System.IO.FileStream"/>, a <see
               cref="T:System.IO.MemoryStream"/>, or ASP.NET's
               <c>Response.OutputStream</c>.  The content will be decrypted and
               decompressed as necessary. If the entry is encrypted and no password
               is provided, this method will throw.
             </para>
             <para>
               The position on the stream is not reset by this method before it extracts.
               You may want to call stream.Seek() before calling ZipEntry.Extract().
             </para>
             </remarks>
            
             <param name="stream">
               the stream to which the entry should be extracted.
             </param>
            
        </member>
        <member name="M:Ionic.Zip.ZipEntry.Extract(System.String)">
             <summary>
               Extract the entry to the filesystem, starting at the specified base
               directory.
             </summary>
            
             <param name="baseDirectory">the pathname of the base directory</param>
            
             <seealso cref="P:Ionic.Zip.ZipEntry.ExtractExistingFile"/>
             <seealso cref="M:Ionic.Zip.ZipEntry.Extract(System.String,Ionic.Zip.ExtractExistingFileAction)"/>
            
             <example>
             This example extracts only the entries in a zip file that are .txt files,
             into a directory called "textfiles".
             <code lang="C#">
             using (ZipFile zip = ZipFile.Read("PackedDocuments.zip"))
             {
               foreach (string s1 in zip.EntryFilenames)
               {
                 if (s1.EndsWith(".txt"))
                 {
                   zip[s1].Extract("textfiles");
                 }
               }
             }
             </code>
             <code lang="VB">
               Using zip As ZipFile = ZipFile.Read("PackedDocuments.zip")
                   Dim s1 As String
                   For Each s1 In zip.EntryFilenames
                       If s1.EndsWith(".txt") Then
                           zip(s1).Extract("textfiles")
                       End If
                   Next
               End Using
             </code>
             </example>
            
             <remarks>
            
             <para>
               Using this method, existing entries in the filesystem will not be
               overwritten. If you would like to force the overwrite of existing
               files, see the <see cref="P:Ionic.Zip.ZipEntry.ExtractExistingFile"/> property, or call
               <see cref="M:Ionic.Zip.ZipEntry.Extract(System.String,Ionic.Zip.ExtractExistingFileAction)"/>.
             </para>
            
             <para>
               See the remarks on the <see cref="P:Ionic.Zip.ZipEntry.LastModified"/> property, for some
               details about how the last modified time of the created file is set.
             </para>
             </remarks>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.Extract(System.String,Ionic.Zip.ExtractExistingFileAction)">
             <summary>
               Extract the entry to the filesystem, starting at the specified base
               directory, and using the specified behavior when extraction would
               overwrite an existing file.
             </summary>
            
             <remarks>
             <para>
               See the remarks on the <see cref="P:Ionic.Zip.ZipEntry.LastModified"/> property, for some
               details about how the last modified time of the created file is set.
             </para>
             </remarks>
            
             <example>
             <code lang="C#">
             String sZipPath = "Airborne.zip";
             String sFilePath = "Readme.txt";
             String sRootFolder = "Digado";
             using (ZipFile zip = ZipFile.Read(sZipPath))
             {
               if (zip.EntryFileNames.Contains(sFilePath))
               {
                 // use the string indexer on the zip file
                 zip[sFileName].Extract(sRootFolder,
                                        ExtractExistingFileAction.OverwriteSilently);
               }
             }
             </code>
            
             <code lang="VB">
             Dim sZipPath as String = "Airborne.zip"
             Dim sFilePath As String = "Readme.txt"
             Dim sRootFolder As String = "Digado"
             Using zip As ZipFile = ZipFile.Read(sZipPath)
               If zip.EntryFileNames.Contains(sFilePath)
                 ' use the string indexer on the zip file
                 zip(sFilePath).Extract(sRootFolder, _
                                        ExtractExistingFileAction.OverwriteSilently)
               End If
             End Using
             </code>
             </example>
            
             <param name="baseDirectory">the pathname of the base directory</param>
             <param name="extractExistingFile">
             The action to take if extraction would overwrite an existing file.
             </param>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.ExtractWithPassword(System.String)">
             <summary>
               Extract the entry to the filesystem, using the current working directory
               and the specified password.
             </summary>
            
             <overloads>
               This method has a bunch of overloads! One of them is sure to be
               the right one for you...
             </overloads>
            
             <seealso cref="P:Ionic.Zip.ZipEntry.ExtractExistingFile"/>
             <seealso cref="M:Ionic.Zip.ZipEntry.ExtractWithPassword(Ionic.Zip.ExtractExistingFileAction,System.String)"/>
            
             <remarks>
            
             <para>
               Existing entries in the filesystem will not be overwritten. If you
               would like to force the overwrite of existing files, see the <see
               cref="P:Ionic.Zip.ZipEntry.ExtractExistingFile"/>property, or call
               <see
               cref="M:Ionic.Zip.ZipEntry.ExtractWithPassword(Ionic.Zip.ExtractExistingFileAction,System.String)"/>.
             </para>
            
             <para>
               See the remarks on the <see cref="P:Ionic.Zip.ZipEntry.LastModified"/> property for some
               details about how the "last modified" time of the created file is
               set.
             </para>
             </remarks>
            
             <example>
               In this example, entries that use encryption are extracted using a
               particular password.
             <code>
             using (var zip = ZipFile.Read(FilePath))
             {
                 foreach (ZipEntry e in zip)
                 {
                     if (e.UsesEncryption)
                         e.ExtractWithPassword("Secret!");
                     else
                         e.Extract();
                 }
             }
             </code>
             <code lang="VB">
             Using zip As ZipFile = ZipFile.Read(FilePath)
                 Dim e As ZipEntry
                 For Each e In zip
                     If (e.UsesEncryption)
                       e.ExtractWithPassword("Secret!")
                     Else
                       e.Extract
                     End If
                 Next
             End Using
             </code>
             </example>
             <param name="password">The Password to use for decrypting the entry.</param>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.ExtractWithPassword(System.String,System.String)">
             <summary>
               Extract the entry to the filesystem, starting at the specified base
               directory, and using the specified password.
             </summary>
            
             <seealso cref="P:Ionic.Zip.ZipEntry.ExtractExistingFile"/>
             <seealso cref="M:Ionic.Zip.ZipEntry.ExtractWithPassword(System.String,Ionic.Zip.ExtractExistingFileAction,System.String)"/>
            
             <remarks>
             <para>
               Existing entries in the filesystem will not be overwritten. If you
               would like to force the overwrite of existing files, see the <see
               cref="P:Ionic.Zip.ZipEntry.ExtractExistingFile"/>property, or call
               <see
               cref="M:Ionic.Zip.ZipEntry.ExtractWithPassword(Ionic.Zip.ExtractExistingFileAction,System.String)"/>.
             </para>
            
             <para>
               See the remarks on the <see cref="P:Ionic.Zip.ZipEntry.LastModified"/> property, for some
               details about how the last modified time of the created file is set.
             </para>
             </remarks>
            
             <param name="baseDirectory">The pathname of the base directory.</param>
             <param name="password">The Password to use for decrypting the entry.</param>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.ExtractWithPassword(Ionic.Zip.ExtractExistingFileAction,System.String)">
             <summary>
               Extract the entry to a file in the filesystem, relative to the
               current directory, using the specified behavior when extraction
               would overwrite an existing file.
             </summary>
            
             <remarks>
             <para>
               See the remarks on the <see cref="P:Ionic.Zip.ZipEntry.LastModified"/> property, for some
               details about how the last modified time of the created file is set.
             </para>
             </remarks>
            
             <param name="password">The Password to use for decrypting the entry.</param>
            
             <param name="extractExistingFile">
             The action to take if extraction would overwrite an existing file.
             </param>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.ExtractWithPassword(System.String,Ionic.Zip.ExtractExistingFileAction,System.String)">
             <summary>
               Extract the entry to the filesystem, starting at the specified base
               directory, and using the specified behavior when extraction would
               overwrite an existing file.
             </summary>
            
             <remarks>
               See the remarks on the <see cref="P:Ionic.Zip.ZipEntry.LastModified"/> property, for some
               details about how the last modified time of the created file is set.
             </remarks>
            
             <param name="baseDirectory">the pathname of the base directory</param>
            
             <param name="extractExistingFile">The action to take if extraction would
             overwrite an existing file.</param>
            
             <param name="password">The Password to use for decrypting the entry.</param>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.ExtractWithPassword(System.IO.Stream,System.String)">
             <summary>
               Extracts the entry to the specified stream, using the specified
               Password.  For example, the caller could extract to Console.Out, or
               to a MemoryStream.
             </summary>
            
             <remarks>
             <para>
               The caller can specify any write-able stream, for example a <see
               cref="T:System.IO.FileStream"/>, a <see
               cref="T:System.IO.MemoryStream"/>, or ASP.NET's
               <c>Response.OutputStream</c>.  The content will be decrypted and
               decompressed as necessary. If the entry is encrypted and no password
               is provided, this method will throw.
             </para>
             <para>
               The position on the stream is not reset by this method before it extracts.
               You may want to call stream.Seek() before calling ZipEntry.Extract().
             </para>
             </remarks>
            
            
             <param name="stream">
               the stream to which the entry should be extracted.
             </param>
             <param name="password">
               The password to use for decrypting the entry.
             </param>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.OpenReader">
             <summary>
               Opens a readable stream corresponding to the zip entry in the
               archive.  The stream decompresses and decrypts as necessary, as it
               is read.
             </summary>
            
             <remarks>
            
             <para>
               DotNetZip offers a variety of ways to extract entries from a zip
               file.  This method allows an application to extract an entry by
               reading a <see cref="T:System.IO.Stream"/>.
             </para>
            
             <para>
               The return value is of type <see
               cref="T:Ionic.Crc.CrcCalculatorStream"/>.  Use it as you would any
               stream for reading.  When an application calls <see
               cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)"/> on that stream, it will
               receive data from the zip entry that is decrypted and decompressed
               as necessary.
             </para>
            
             <para>
               <c>CrcCalculatorStream</c> adds one additional feature: it keeps a
               CRC32 checksum on the bytes of the stream as it is read.  The CRC
               value is available in the <see
               cref="P:Ionic.Crc.CrcCalculatorStream.Crc"/> property on the
               <c>CrcCalculatorStream</c>.  When the read is complete, your
               application
               <em>should</em> check this CRC against the <see cref="P:Ionic.Zip.ZipEntry.Crc"/>
               property on the <c>ZipEntry</c> to validate the content of the
               ZipEntry. You don't have to validate the entry using the CRC, but
               you should, to verify integrity. Check the example for how to do
               this.
             </para>
            
             <para>
               If the entry is protected with a password, then you need to provide
               a password prior to calling <see cref="M:Ionic.Zip.ZipEntry.OpenReader"/>, either by
               setting the <see cref="P:Ionic.Zip.ZipEntry.Password"/> property on the entry, or the
               <see cref="P:Ionic.Zip.ZipFile.Password"/> property on the <c>ZipFile</c>
               itself. Or, you can use <see cref="M:Ionic.Zip.ZipEntry.OpenReader(System.String)" />, the
               overload of OpenReader that accepts a password parameter.
             </para>
            
             <para>
               If you want to extract entry data into a write-able stream that is
               already opened, like a <see cref="T:System.IO.FileStream"/>, do not
               use this method. Instead, use <see cref="M:Ionic.Zip.ZipEntry.Extract(System.IO.Stream)"/>.
             </para>
            
             <para>
               Your application may use only one stream created by OpenReader() at
               a time, and you should not call other Extract methods before
               completing your reads on a stream obtained from OpenReader().  This
               is because there is really only one source stream for the compressed
               content.  A call to OpenReader() seeks in the source stream, to the
               beginning of the compressed content.  A subsequent call to
               OpenReader() on a different entry will seek to a different position
               in the source stream, as will a call to Extract() or one of its
               overloads.  This will corrupt the state for the decompressing stream
               from the original call to OpenReader().
             </para>
            
             <para>
                The <c>OpenReader()</c> method works only when the ZipEntry is
                obtained from an instance of <c>ZipFile</c>. This method will throw
                an exception if the ZipEntry is obtained from a <see
                cref="T:Ionic.Zip.ZipInputStream"/>.
             </para>
             </remarks>
            
             <example>
               This example shows how to open a zip archive, then read in a named
               entry via a stream. After the read loop is complete, the code
               compares the calculated during the read loop with the expected CRC
               on the <c>ZipEntry</c>, to verify the extraction.
             <code>
             using (ZipFile zip = new ZipFile(ZipFileToRead))
             {
               ZipEntry e1= zip["Elevation.mp3"];
               using (Ionic.Zlib.CrcCalculatorStream s = e1.OpenReader())
               {
                 byte[] buffer = new byte[4096];
                 int n, totalBytesRead= 0;
                 do {
                   n = s.Read(buffer,0, buffer.Length);
                   totalBytesRead+=n;
                 } while (n&gt;0);
                  if (s.Crc32 != e1.Crc32)
                   throw new Exception(string.Format("The Zip Entry failed the CRC Check. (0x{0:X8}!=0x{1:X8})", s.Crc32, e1.Crc32));
                  if (totalBytesRead != e1.UncompressedSize)
                   throw new Exception(string.Format("We read an unexpected number of bytes. ({0}!={1})", totalBytesRead, e1.UncompressedSize));
               }
             }
             </code>
             <code lang="VB">
               Using zip As New ZipFile(ZipFileToRead)
                   Dim e1 As ZipEntry = zip.Item("Elevation.mp3")
                   Using s As Ionic.Zlib.CrcCalculatorStream = e1.OpenReader
                       Dim n As Integer
                       Dim buffer As Byte() = New Byte(4096) {}
                       Dim totalBytesRead As Integer = 0
                       Do
                           n = s.Read(buffer, 0, buffer.Length)
                           totalBytesRead = (totalBytesRead + n)
                       Loop While (n &gt; 0)
                       If (s.Crc32 &lt;&gt; e1.Crc32) Then
                           Throw New Exception(String.Format("The Zip Entry failed the CRC Check. (0x{0:X8}!=0x{1:X8})", s.Crc32, e1.Crc32))
                       End If
                       If (totalBytesRead &lt;&gt; e1.UncompressedSize) Then
                           Throw New Exception(String.Format("We read an unexpected number of bytes. ({0}!={1})", totalBytesRead, e1.UncompressedSize))
                       End If
                   End Using
               End Using
             </code>
             </example>
             <seealso cref="M:Ionic.Zip.ZipEntry.Extract(System.IO.Stream)"/>
             <returns>The Stream for reading.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.OpenReader(System.String)">
             <summary>
               Opens a readable stream for an encrypted zip entry in the archive.
               The stream decompresses and decrypts as necessary, as it is read.
             </summary>
            
             <remarks>
             <para>
               See the documentation on the <see cref="M:Ionic.Zip.ZipEntry.OpenReader"/> method for
               full details. This overload allows the application to specify a
               password for the <c>ZipEntry</c> to be read.
             </para>
             </remarks>
            
             <param name="password">The password to use for decrypting the entry.</param>
             <returns>The Stream for reading.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.ValidateOutput(System.String,System.IO.Stream,System.String@)">
            <summary>
            Validates that the args are consistent.
            </summary>
            <remarks>
            Only one of {baseDir, outStream} can be non-null.
            If baseDir is non-null, then the outputFile is created.
            </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.AttributesIndicateDirectory">
            <summary>
            True if the referenced entry is a directory.
            </summary>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.ReadDirEntry(Ionic.Zip.ZipFile,System.Collections.Generic.Dictionary{System.String,System.Object})">
             <summary>
               Reads one entry from the zip directory structure in the zip file.
             </summary>
            
             <param name="zf">
               The zipfile for which a directory entry will be read.  From this param, the
               method gets the ReadStream and the expected text encoding
               (ProvisionalAlternateEncoding) which is used if the entry is not marked
               UTF-8.
             </param>
            
             <param name="previouslySeen">
               a list of previously seen entry names; used to prevent duplicates.
             </param>
            
             <returns>the entry read from the archive.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.IsNotValidZipDirEntrySig(System.Int32)">
            <summary>
            Returns true if the passed-in value is a valid signature for a ZipDirEntry.
            </summary>
            <param name="signature">the candidate 4-byte signature value.</param>
            <returns>true, if the signature is valid according to the PKWare spec.</returns>
        </member>
        <member name="T:Ionic.Zip.ZipEntryTimestamp">
             <summary>
               An enum that specifies the type of timestamp available on the ZipEntry.
             </summary>
            
             <remarks>
            
             <para>
               The last modified time of a file can be stored in multiple ways in
               a zip file, and they are not mutually exclusive:
             </para>
            
             <list type="bullet">
               <item>
                 In the so-called "DOS" format, which has a 2-second precision. Values
                 are rounded to the nearest even second. For example, if the time on the
                 file is 12:34:43, then it will be stored as 12:34:44. This first value
                 is accessible via the <c>LastModified</c> property. This value is always
                 present in the metadata for each zip entry.  In some cases the value is
                 invalid, or zero.
               </item>
            
               <item>
                 In the so-called "Windows" or "NTFS" format, as an 8-byte integer
                 quantity expressed as the number of 1/10 milliseconds (in other words
                 the number of 100 nanosecond units) since January 1, 1601 (UTC).  This
                 format is how Windows represents file times.  This time is accessible
                 via the <c>ModifiedTime</c> property.
               </item>
            
               <item>
                 In the "Unix" format, a 4-byte quantity specifying the number of seconds since
                 January 1, 1970 UTC.
               </item>
            
               <item>
                 In an older format, now deprecated but still used by some current
                 tools. This format is also a 4-byte quantity specifying the number of
                 seconds since January 1, 1970 UTC.
               </item>
            
             </list>
            
             <para>
               This bit field describes which of the formats were found in a <c>ZipEntry</c> that was read.
             </para>
            
             </remarks>
        </member>
        <member name="F:Ionic.Zip.ZipEntryTimestamp.None">
            <summary>
            Default value.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipEntryTimestamp.DOS">
            <summary>
            A DOS timestamp with 2-second precision.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipEntryTimestamp.Windows">
            <summary>
            A Windows timestamp with 100-ns precision.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipEntryTimestamp.Unix">
            <summary>
            A Unix timestamp with 1-second precision.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipEntryTimestamp.InfoZip1">
            <summary>
            A Unix timestamp with 1-second precision, stored in InfoZip v1 format.  This
            format is outdated and is supported for reading archives only.
            </summary>
        </member>
        <member name="T:Ionic.Zip.CompressionMethod">
             <summary>
               The method of compression to use for a particular ZipEntry.
             </summary>
            
             <remarks>
               <see
               href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">PKWare's
               ZIP Specification</see> describes a number of distinct
               cmopression methods that can be used within a zip
               file. DotNetZip supports a subset of them.
             </remarks>
        </member>
        <member name="F:Ionic.Zip.CompressionMethod.None">
            <summary>
            No compression at all. For COM environments, the value is 0 (zero).
            </summary>
        </member>
        <member name="F:Ionic.Zip.CompressionMethod.Deflate">
            <summary>
              DEFLATE compression, as described in <see
              href="http://www.ietf.org/rfc/rfc1951.txt">IETF RFC
              1951</see>.  This is the "normal" compression used in zip
              files. For COM environments, the value is 8.
            </summary>
        </member>
        <member name="T:Ionic.Zip.ZipFile">
             <summary>
               The ZipFile type represents a zip archive file.
             </summary>
            
             <remarks>
             <para>
               This is the main type in the DotNetZip class library. This class reads and
               writes zip files, as defined in the <see
               href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">specification
               for zip files described by PKWare</see>.  The compression for this
               implementation is provided by a managed-code version of Zlib, included with
               DotNetZip in the classes in the Ionic.Zlib namespace.
             </para>
            
             <para>
               This class provides a general purpose zip file capability.  Use it to read,
               create, or update zip files.  When you want to create zip files using a
               <c>Stream</c> type to write the zip file, you may want to consider the <see
               cref="T:Ionic.Zip.ZipOutputStream"/> class.
             </para>
            
             <para>
               Both the <c>ZipOutputStream</c> class and the <c>ZipFile</c> class can
               be used to create zip files. Both of them support many of the common zip
               features, including Unicode, different compression methods and levels,
               and ZIP64. They provide very similar performance when creating zip
               files.
             </para>
            
             <para>
               The <c>ZipFile</c> class is generally easier to use than
               <c>ZipOutputStream</c> and should be considered a higher-level interface.  For
               example, when creating a zip file via calls to the <c>PutNextEntry()</c> and
               <c>Write()</c> methods on the <c>ZipOutputStream</c> class, the caller is
               responsible for opening the file, reading the bytes from the file, writing
               those bytes into the <c>ZipOutputStream</c>, setting the attributes on the
               <c>ZipEntry</c>, and setting the created, last modified, and last accessed
               timestamps on the zip entry. All of these things are done automatically by a
               call to <see cref="M:Ionic.Zip.ZipFile.AddFile(System.String,System.String)">ZipFile.AddFile()</see>.
               For this reason, the <c>ZipOutputStream</c> is generally recommended for use
               only when your application emits arbitrary data, not necessarily data from a
               filesystem file, directly into a zip file, and does so using a <c>Stream</c>
               metaphor.
             </para>
            
             <para>
               Aside from the differences in programming model, there are other
               differences in capability between the two classes.
             </para>
            
             <list type="bullet">
               <item>
                 <c>ZipFile</c> can be used to read and extract zip files, in addition to
                 creating zip files. <c>ZipOutputStream</c> cannot read zip files. If you want
                 to use a stream to read zip files, check out the <see cref="T:Ionic.Zip.ZipInputStream"/> class.
               </item>
            
               <item>
                 <c>ZipOutputStream</c> does not support the creation of segmented or spanned
                 zip files.
               </item>
            
               <item>
                 <c>ZipOutputStream</c> cannot produce a self-extracting archive.
               </item>
             </list>
            
             <para>
               Be aware that the <c>ZipFile</c> class implements the <see
               cref="T:System.IDisposable"/> interface.  In order for <c>ZipFile</c> to
               produce a valid zip file, you use use it within a using clause (<c>Using</c>
               in VB), or call the <c>Dispose()</c> method explicitly.  See the examples
               for how to employ a using clause.
             </para>
            
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipFile.FullScan">
             <summary>
             Indicates whether to perform a full scan of the zip file when reading it.
             </summary>
            
             <remarks>
            
             <para>
               You almost never want to use this property.
             </para>
            
             <para>
               When reading a zip file, if this flag is <c>true</c> (<c>True</c> in
               VB), the entire zip archive will be scanned and searched for entries.
               For large archives, this can take a very, long time. The much more
               efficient default behavior is to read the zip directory, which is
               stored at the end of the zip file. But, in some cases the directory is
               corrupted and you need to perform a full scan of the zip file to
               determine the contents of the zip file. This property lets you do
               that, when necessary.
             </para>
            
             <para>
               This flag is effective only when calling <see
               cref="M:Ionic.Zip.ZipFile.Initialize(System.String)"/>. Normally you would read a ZipFile with the
               static <see cref="M:Ionic.Zip.ZipFile.Read(System.String)">ZipFile.Read</see>
               method. But you can't set the <c>FullScan</c> property on the
               <c>ZipFile</c> instance when you use a static factory method like
               <c>ZipFile.Read</c>.
             </para>
            
             </remarks>
            
             <example>
            
               This example shows how to read a zip file using the full scan approach,
               and then save it, thereby producing a corrected zip file.
            
             <code lang="C#">
             using (var zip = new ZipFile())
             {
                 zip.FullScan = true;
                 zip.Initialize(zipFileName);
                 zip.Save(newName);
             }
             </code>
            
             <code lang="VB">
             Using zip As New ZipFile
                 zip.FullScan = True
                 zip.Initialize(zipFileName)
                 zip.Save(newName)
             End Using
             </code>
             </example>
            
        </member>
        <member name="P:Ionic.Zip.ZipFile.SortEntriesBeforeSaving">
             <summary>
               Whether to sort the ZipEntries before saving the file.
             </summary>
            
             <remarks>
               The default is false.  If you have a large number of zip entries, the sort
               alone can consume significant time.
             </remarks>
            
             <example>
             <code lang="C#">
             using (var zip = new ZipFile())
             {
                 zip.AddFiles(filesToAdd);
                 zip.SortEntriesBeforeSaving = true;
                 zip.Save(name);
             }
             </code>
            
             <code lang="VB">
             Using zip As New ZipFile
                 zip.AddFiles(filesToAdd)
                 zip.SortEntriesBeforeSaving = True
                 zip.Save(name)
             End Using
             </code>
             </example>
            
        </member>
        <member name="P:Ionic.Zip.ZipFile.AddDirectoryWillTraverseReparsePoints">
             <summary>
               Indicates whether NTFS Reparse Points, like junctions, should be
               traversed during calls to <c>AddDirectory()</c>.
             </summary>
            
             <remarks>
               By default, calls to AddDirectory() will traverse NTFS reparse
               points, like mounted volumes, and directory junctions.  An example
               of a junction is the "My Music" directory in Windows Vista.  In some
               cases you may not want DotNetZip to traverse those directories.  In
               that case, set this property to false.
             </remarks>
            
             <example>
             <code lang="C#">
             using (var zip = new ZipFile())
             {
                 zip.AddDirectoryWillTraverseReparsePoints = false;
                 zip.AddDirectory(dirToZip,"fodder");
                 zip.Save(zipFileToCreate);
             }
             </code>
             </example>
        </member>
        <member name="P:Ionic.Zip.ZipFile.BufferSize">
             <summary>
               Size of the IO buffer used while saving.
             </summary>
            
             <remarks>
            
             <para>
               First, let me say that you really don't need to bother with this.  It is
               here to allow for optimizations that you probably won't make! It will work
               fine if you don't set or get this property at all. Ok?
             </para>
            
             <para>
               Now that we have <em>that</em> out of the way, the fine print: This
               property affects the size of the buffer that is used for I/O for each
               entry contained in the zip file. When a file is read in to be compressed,
               it uses a buffer given by the size here.  When you update a zip file, the
               data for unmodified entries is copied from the first zip file to the
               other, through a buffer given by the size here.
             </para>
            
             <para>
               Changing the buffer size affects a few things: first, for larger buffer
               sizes, the memory used by the <c>ZipFile</c>, obviously, will be larger
               during I/O operations.  This may make operations faster for very much
               larger files.  Last, for any given entry, when you use a larger buffer
               there will be fewer progress events during I/O operations, because there's
               one progress event generated for each time the buffer is filled and then
               emptied.
             </para>
            
             <para>
               The default buffer size is 8k.  Increasing the buffer size may speed
               things up as you compress larger files.  But there are no hard-and-fast
               rules here, eh?  You won't know til you test it.  And there will be a
               limit where ever larger buffers actually slow things down.  So as I said
               in the beginning, it's probably best if you don't set or get this property
               at all.
             </para>
            
             </remarks>
            
             <example>
             This example shows how you might set a large buffer size for efficiency when
             dealing with zip entries that are larger than 1gb.
             <code lang="C#">
             using (ZipFile zip = new ZipFile())
             {
                 zip.SaveProgress += this.zip1_SaveProgress;
                 zip.AddDirectory(directoryToZip, "");
                 zip.UseZip64WhenSaving = Zip64Option.Always;
                 zip.BufferSize = 65536*8; // 65536 * 8 = 512k
                 zip.Save(ZipFileToCreate);
             }
             </code>
             </example>
        </member>
        <member name="P:Ionic.Zip.ZipFile.CodecBufferSize">
             <summary>
               Size of the work buffer to use for the ZLIB codec during compression.
             </summary>
            
             <remarks>
               <para>
                 When doing ZLIB or Deflate compression, the library fills a buffer,
                 then passes it to the compressor for compression. Then the library
                 reads out the compressed bytes. This happens repeatedly until there
                 is no more uncompressed data to compress. This property sets the
                 size of the buffer that will be used for chunk-wise compression. In
                 order for the setting to take effect, your application needs to set
                 this property before calling one of the <c>ZipFile.Save()</c>
                 overloads.
               </para>
               <para>
                 Setting this affects the performance and memory efficiency of
                 compression and decompression. For larger files, setting this to a
                 larger size may improve compression performance, but the exact
                 numbers vary depending on available memory, the size of the streams
                 you are compressing, and a bunch of other variables. I don't have
                 good firm recommendations on how to set it.  You'll have to test it
                 yourself. Or just leave it alone and accept the default.
               </para>
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipFile.FlattenFoldersOnExtract">
             <summary>
               Indicates whether extracted files should keep their paths as
               stored in the zip archive.
             </summary>
            
             <remarks>
              <para>
                This property affects Extraction.  It is not used when creating zip
                archives.
              </para>
            
              <para>
                With this property set to <c>false</c>, the default, extracting entries
                from a zip file will create files in the filesystem that have the full
                path associated to the entry within the zip file.  With this property set
                to <c>true</c>, extracting entries from the zip file results in files
                with no path: the folders are "flattened."
              </para>
            
              <para>
                An example: suppose the zip file contains entries /directory1/file1.txt and
                /directory2/file2.txt.  With <c>FlattenFoldersOnExtract</c> set to false,
                the files created will be \directory1\file1.txt and \directory2\file2.txt.
                With the property set to true, the files created are file1.txt and file2.txt.
              </para>
            
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipFile.Strategy">
             <summary>
               The compression strategy to use for all entries.
             </summary>
            
             <remarks>
               Set the Strategy used by the ZLIB-compatible compressor, when
               compressing entries using the DEFLATE method. Different compression
               strategies work better on different sorts of data. The strategy
               parameter can affect the compression ratio and the speed of
               compression but not the correctness of the compresssion.  For more
               information see <see
               cref="T:Ionic.Zlib.CompressionStrategy">Ionic.Zlib.CompressionStrategy</see>.
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipFile.Name">
             <summary>
               The name of the <c>ZipFile</c>, on disk.
             </summary>
            
             <remarks>
            
             <para>
               When the <c>ZipFile</c> instance was created by reading an archive using
               one of the <c>ZipFile.Read</c> methods, this property represents the name
               of the zip file that was read.  When the <c>ZipFile</c> instance was
               created by using the no-argument constructor, this value is <c>null</c>
               (<c>Nothing</c> in VB).
             </para>
            
             <para>
               If you use the no-argument constructor, and you then explicitly set this
               property, when you call <see cref="M:Ionic.Zip.ZipFile.Save"/>, this name will
               specify the name of the zip file created.  Doing so is equivalent to
               calling <see cref="M:Ionic.Zip.ZipFile.Save(System.String)"/>.  When instantiating a
               <c>ZipFile</c> by reading from a stream or byte array, the <c>Name</c>
               property remains <c>null</c>.  When saving to a stream, the <c>Name</c>
               property is implicitly set to <c>null</c>.
             </para>
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipFile.CompressionLevel">
             <summary>
               Sets the compression level to be used for entries subsequently added to
               the zip archive.
             </summary>
            
             <remarks>
              <para>
                Varying the compression level used on entries can affect the
                size-vs-speed tradeoff when compression and decompressing data streams
                or files.
              </para>
            
              <para>
                As with some other properties on the <c>ZipFile</c> class, like <see
                cref="P:Ionic.Zip.ZipFile.Password"/>, <see cref="P:Ionic.Zip.ZipFile.Encryption"/>, and <see
                cref="P:Ionic.Zip.ZipFile.ZipErrorAction"/>, setting this property on a <c>ZipFile</c>
                instance will cause the specified <c>CompressionLevel</c> to be used on all
                <see cref="T:Ionic.Zip.ZipEntry"/> items that are subsequently added to the
                <c>ZipFile</c> instance. If you set this property after you have added
                items to the <c>ZipFile</c>, but before you have called <c>Save()</c>,
                those items will not use the specified compression level.
              </para>
            
              <para>
                If you do not set this property, the default compression level is used,
                which normally gives a good balance of compression efficiency and
                compression speed.  In some tests, using <c>BestCompression</c> can
                double the time it takes to compress, while delivering just a small
                increase in compression efficiency.  This behavior will vary with the
                type of data you compress.  If you are in doubt, just leave this setting
                alone, and accept the default.
              </para>
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipFile.CompressionMethod">
            <summary>
              The compression method for the zipfile.
            </summary>
            <remarks>
              <para>
                By default, the compression method is <c>CompressionMethod.Deflate.</c>
              </para>
            </remarks>
            <seealso cref="T:Ionic.Zip.CompressionMethod" />
        </member>
        <member name="P:Ionic.Zip.ZipFile.Comment">
             <summary>
               A comment attached to the zip archive.
             </summary>
            
             <remarks>
            
             <para>
               This property is read/write. It allows the application to specify a
               comment for the <c>ZipFile</c>, or read the comment for the
               <c>ZipFile</c>.  After setting this property, changes are only made
               permanent when you call a <c>Save()</c> method.
             </para>
            
             <para>
               According to <see
               href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">PKWARE's
               zip specification</see>, the comment is not encrypted, even if there is a
               password set on the zip file.
             </para>
            
             <para>
               The specification does not describe how to indicate the encoding used
               on a comment string. Many "compliant" zip tools and libraries use
               IBM437 as the code page for comments; DotNetZip, too, follows that
               practice.  On the other hand, there are situations where you want a
               Comment to be encoded with something else, for example using code page
               950 "Big-5 Chinese". To fill that need, DotNetZip will encode the
               comment following the same procedure it follows for encoding
               filenames: (a) if <see cref="P:Ionic.Zip.ZipFile.AlternateEncodingUsage"/> is
               <c>Never</c>, it uses the default encoding (IBM437). (b) if <see
               cref="P:Ionic.Zip.ZipFile.AlternateEncodingUsage"/> is <c>Always</c>, it always uses the
               alternate encoding (<see cref="P:Ionic.Zip.ZipFile.AlternateEncoding"/>). (c) if <see
               cref="P:Ionic.Zip.ZipFile.AlternateEncodingUsage"/> is <c>AsNecessary</c>, it uses the
               alternate encoding only if the default encoding is not sufficient for
               encoding the comment - in other words if decoding the result does not
               produce the original string.  This decision is taken at the time of
               the call to <c>ZipFile.Save()</c>.
             </para>
            
             <para>
               When creating a zip archive using this library, it is possible to change
               the value of <see cref="P:Ionic.Zip.ZipFile.AlternateEncoding" /> between each
               entry you add, and between adding entries and the call to
               <c>Save()</c>. Don't do this.  It will likely result in a zip file that is
               not readable by any tool or application.  For best interoperability, leave
               <see cref="P:Ionic.Zip.ZipFile.AlternateEncoding"/> alone, or specify it only
               once, before adding any entries to the <c>ZipFile</c> instance.
             </para>
            
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipFile.EmitTimesInWindowsFormatWhenSaving">
             <summary>
               Specifies whether the Creation, Access, and Modified times for entries
               added to the zip file will be emitted in &#147;Windows format&#148;
               when the zip archive is saved.
             </summary>
            
             <remarks>
             <para>
               An application creating a zip archive can use this flag to explicitly
               specify that the file times for the entries should or should not be stored
               in the zip archive in the format used by Windows. By default this flag is
               <c>true</c>, meaning the Windows-format times are stored in the zip
               archive.
             </para>
            
             <para>
               When adding an entry from a file or directory, the Creation (<see
               cref="P:Ionic.Zip.ZipEntry.CreationTime"/>), Access (<see
               cref="P:Ionic.Zip.ZipEntry.AccessedTime"/>), and Modified (<see
               cref="P:Ionic.Zip.ZipEntry.ModifiedTime"/>) times for the given entry are
               automatically set from the filesystem values. When adding an entry from a
               stream or string, all three values are implicitly set to
               <c>DateTime.Now</c>.  Applications can also explicitly set those times by
               calling <see cref="M:Ionic.Zip.ZipEntry.SetEntryTimes(System.DateTime,System.DateTime,System.DateTime)"/>.
             </para>
            
             <para>
               <see
               href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">PKWARE's
               zip specification</see> describes multiple ways to format these times in a
               zip file. One is the format Windows applications normally use: 100ns ticks
               since January 1, 1601 UTC.  The other is a format Unix applications typically
               use: seconds since January 1, 1970 UTC.  Each format can be stored in an
               "extra field" in the zip entry when saving the zip archive. The former
               uses an extra field with a Header Id of 0x000A, while the latter uses a
               header ID of 0x5455, although you probably don't need to know that.
             </para>
            
             <para>
               Not all tools and libraries can interpret these fields.  Windows
               compressed folders is one that can read the Windows Format timestamps,
               while I believe <see href="http://www.info-zip.org/">the Infozip
               tools</see> can read the Unix format timestamps. Some tools and libraries
               may be able to read only one or the other. DotNetZip can read or write
               times in either or both formats.
             </para>
            
             <para>
               The times stored are taken from <see cref="P:Ionic.Zip.ZipEntry.ModifiedTime"/>, <see
               cref="P:Ionic.Zip.ZipEntry.AccessedTime"/>, and <see cref="P:Ionic.Zip.ZipEntry.CreationTime"/>.
             </para>
            
             <para>
               The value set here applies to all entries subsequently added to the
               <c>ZipFile</c>.
             </para>
            
             <para>
               This property is not mutually exclusive of the <see
               cref="P:Ionic.Zip.ZipFile.EmitTimesInUnixFormatWhenSaving" /> property. It is possible and
               legal and valid to produce a zip file that contains timestamps encoded in
               the Unix format as well as in the Windows format, in addition to the <see
               cref="P:Ionic.Zip.ZipEntry.LastModified">LastModified</see> time attached to each
               entry in the archive, a time that is always stored in "DOS format". And,
               notwithstanding the names PKWare uses for these time formats, any of them
               can be read and written by any computer, on any operating system.  But,
               there are no guarantees that a program running on Mac or Linux will
               gracefully handle a zip file with "Windows" formatted times, or that an
               application that does not use DotNetZip but runs on Windows will be able to
               handle file times in Unix format.
             </para>
            
             <para>
               When in doubt, test.  Sorry, I haven't got a complete list of tools and
               which sort of timestamps they can use and will tolerate.  If you get any
               good information and would like to pass it on, please do so and I will
               include that information in this documentation.
             </para>
             </remarks>
            
             <example>
               This example shows how to save a zip file that contains file timestamps
               in a format normally used by Unix.
             <code lang="C#">
             using (var zip = new ZipFile())
             {
                 // produce a zip file the Mac will like
                 zip.EmitTimesInWindowsFormatWhenSaving = false;
                 zip.EmitTimesInUnixFormatWhenSaving = true;
                 zip.AddDirectory(directoryToZip, "files");
                 zip.Save(outputFile);
             }
             </code>
            
             <code lang="VB">
             Using zip As New ZipFile
                 '' produce a zip file the Mac will like
                 zip.EmitTimesInWindowsFormatWhenSaving = False
                 zip.EmitTimesInUnixFormatWhenSaving = True
                 zip.AddDirectory(directoryToZip, "files")
                 zip.Save(outputFile)
             End Using
             </code>
             </example>
            
             <seealso cref="P:Ionic.Zip.ZipEntry.EmitTimesInWindowsFormatWhenSaving" />
             <seealso cref="P:Ionic.Zip.ZipFile.EmitTimesInUnixFormatWhenSaving" />
        </member>
        <member name="P:Ionic.Zip.ZipFile.EmitTimesInUnixFormatWhenSaving">
             <summary>
             Specifies whether the Creation, Access, and Modified times
             for entries added to the zip file will be emitted in "Unix(tm)
             format" when the zip archive is saved.
             </summary>
            
             <remarks>
             <para>
               An application creating a zip archive can use this flag to explicitly
               specify that the file times for the entries should or should not be stored
               in the zip archive in the format used by Unix. By default this flag is
               <c>false</c>, meaning the Unix-format times are not stored in the zip
               archive.
             </para>
            
             <para>
               When adding an entry from a file or directory, the Creation (<see
               cref="P:Ionic.Zip.ZipEntry.CreationTime"/>), Access (<see
               cref="P:Ionic.Zip.ZipEntry.AccessedTime"/>), and Modified (<see
               cref="P:Ionic.Zip.ZipEntry.ModifiedTime"/>) times for the given entry are
               automatically set from the filesystem values. When adding an entry from a
               stream or string, all three values are implicitly set to DateTime.Now.
               Applications can also explicitly set those times by calling <see
               cref="M:Ionic.Zip.ZipEntry.SetEntryTimes(System.DateTime,System.DateTime,System.DateTime)"/>.
             </para>
            
             <para>
               <see
               href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">PKWARE's
               zip specification</see> describes multiple ways to format these times in a
               zip file. One is the format Windows applications normally use: 100ns ticks
               since January 1, 1601 UTC.  The other is a format Unix applications
               typically use: seconds since January 1, 1970 UTC.  Each format can be
               stored in an "extra field" in the zip entry when saving the zip
               archive. The former uses an extra field with a Header Id of 0x000A, while
               the latter uses a header ID of 0x5455, although you probably don't need to
               know that.
             </para>
            
             <para>
               Not all tools and libraries can interpret these fields.  Windows
               compressed folders is one that can read the Windows Format timestamps,
               while I believe the <see href="http://www.info-zip.org/">Infozip</see>
               tools can read the Unix format timestamps. Some tools and libraries may be
               able to read only one or the other.  DotNetZip can read or write times in
               either or both formats.
             </para>
            
             <para>
               The times stored are taken from <see cref="P:Ionic.Zip.ZipEntry.ModifiedTime"/>, <see
               cref="P:Ionic.Zip.ZipEntry.AccessedTime"/>, and <see cref="P:Ionic.Zip.ZipEntry.CreationTime"/>.
             </para>
            
             <para>
               This property is not mutually exclusive of the <see
               cref="P:Ionic.Zip.ZipFile.EmitTimesInWindowsFormatWhenSaving" /> property. It is possible and
               legal and valid to produce a zip file that contains timestamps encoded in
               the Unix format as well as in the Windows format, in addition to the <see
               cref="P:Ionic.Zip.ZipEntry.LastModified">LastModified</see> time attached to each
               entry in the zip archive, a time that is always stored in "DOS
               format". And, notwithstanding the names PKWare uses for these time
               formats, any of them can be read and written by any computer, on any
               operating system.  But, there are no guarantees that a program running on
               Mac or Linux will gracefully handle a zip file with "Windows" formatted
               times, or that an application that does not use DotNetZip but runs on
               Windows will be able to handle file times in Unix format.
             </para>
            
             <para>
               When in doubt, test.  Sorry, I haven't got a complete list of tools and
               which sort of timestamps they can use and will tolerate.  If you get any
               good information and would like to pass it on, please do so and I will
               include that information in this documentation.
             </para>
             </remarks>
            
             <seealso cref="P:Ionic.Zip.ZipEntry.EmitTimesInUnixFormatWhenSaving" />
             <seealso cref="P:Ionic.Zip.ZipFile.EmitTimesInWindowsFormatWhenSaving" />
        </member>
        <member name="P:Ionic.Zip.ZipFile.Verbose">
             <summary>
               Indicates whether verbose output is sent to the <see
               cref="P:Ionic.Zip.ZipFile.StatusMessageTextWriter"/> during <c>AddXxx()</c> and
               <c>ReadXxx()</c> operations.
             </summary>
            
             <remarks>
               This is a <em>synthetic</em> property.  It returns true if the <see
               cref="P:Ionic.Zip.ZipFile.StatusMessageTextWriter"/> is non-null.
             </remarks>
        </member>
        <member name="M:Ionic.Zip.ZipFile.ContainsEntry(System.String)">
             <summary>
               Returns true if an entry by the given name exists in the ZipFile.
             </summary>
            
             <param name='name'>the name of the entry to find</param>
             <returns>true if an entry with the given name exists; otherwise false.
             </returns>
        </member>
        <member name="P:Ionic.Zip.ZipFile.CaseSensitiveRetrieval">
             <summary>
               Indicates whether to perform case-sensitive matching on the filename when
               retrieving entries in the zipfile via the string-based indexer.
             </summary>
            
             <remarks>
               The default value is <c>false</c>, which means don't do case-sensitive
               matching. In other words, retrieving zip["ReadMe.Txt"] is the same as
               zip["readme.txt"].  It really makes sense to set this to <c>true</c> only
               if you are not running on Windows, which has case-insensitive
               filenames. But since this library is not built for non-Windows platforms,
               in most cases you should just leave this property alone.
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipFile.UseUnicodeAsNecessary">
             <summary>
               Indicates whether to encode entry filenames and entry comments using Unicode
               (UTF-8).
             </summary>
            
             <remarks>
             <para>
               <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">The
               PKWare zip specification</see> provides for encoding file names and file
               comments in either the IBM437 code page, or in UTF-8.  This flag selects
               the encoding according to that specification.  By default, this flag is
               false, and filenames and comments are encoded into the zip file in the
               IBM437 codepage.  Setting this flag to true will specify that filenames
               and comments that cannot be encoded with IBM437 will be encoded with
               UTF-8.
             </para>
            
             <para>
               Zip files created with strict adherence to the PKWare specification with
               respect to UTF-8 encoding can contain entries with filenames containing
               any combination of Unicode characters, including the full range of
               characters from Chinese, Latin, Hebrew, Greek, Cyrillic, and many other
               alphabets.  However, because at this time, the UTF-8 portion of the PKWare
               specification is not broadly supported by other zip libraries and
               utilities, such zip files may not be readable by your favorite zip tool or
               archiver. In other words, interoperability will decrease if you set this
               flag to true.
             </para>
            
             <para>
               In particular, Zip files created with strict adherence to the PKWare
               specification with respect to UTF-8 encoding will not work well with
               Explorer in Windows XP or Windows Vista, because Windows compressed
               folders, as far as I know, do not support UTF-8 in zip files.  Vista can
               read the zip files, but shows the filenames incorrectly. Unpacking from
               Windows Vista Explorer will result in filenames that have rubbish
               characters in place of the high-order UTF-8 bytes.
             </para>
            
             <para>
               Also, zip files that use UTF-8 encoding will not work well with Java
               applications that use the java.util.zip classes, as of v5.0 of the Java
               runtime. The Java runtime does not correctly implement the PKWare
               specification in this regard.
             </para>
            
             <para>
               As a result, we have the unfortunate situation that "correct" behavior by
               the DotNetZip library with regard to Unicode encoding of filenames during
               zip creation will result in zip files that are readable by strictly
               compliant and current tools (for example the most recent release of the
               commercial WinZip tool); but these zip files will not be readable by
               various other tools or libraries, including Windows Explorer.
             </para>
            
             <para>
               The DotNetZip library can read and write zip files with UTF8-encoded
               entries, according to the PKware spec.  If you use DotNetZip for both
               creating and reading the zip file, and you use UTF-8, there will be no
               loss of information in the filenames. For example, using a self-extractor
               created by this library will allow you to unpack files correctly with no
               loss of information in the filenames.
             </para>
            
             <para>
               If you do not set this flag, it will remain false.  If this flag is false,
               your <c>ZipFile</c> will encode all filenames and comments using the
               IBM437 codepage.  This can cause "loss of information" on some filenames,
               but the resulting zipfile will be more interoperable with other
               utilities. As an example of the loss of information, diacritics can be
               lost.  The o-tilde character will be down-coded to plain o.  The c with a
               cedilla (Unicode 0xE7) used in Portugese will be downcoded to a c.
               Likewise, the O-stroke character (Unicode 248), used in Danish and
               Norwegian, will be down-coded to plain o. Chinese characters cannot be
               represented in codepage IBM437; when using the default encoding, Chinese
               characters in filenames will be represented as ?. These are all examples
               of "information loss".
             </para>
            
             <para>
               The loss of information associated to the use of the IBM437 encoding is
               inconvenient, and can also lead to runtime errors. For example, using
               IBM437, any sequence of 4 Chinese characters will be encoded as ????.  If
               your application creates a <c>ZipFile</c>, then adds two files, each with
               names of four Chinese characters each, this will result in a duplicate
               filename exception.  In the case where you add a single file with a name
               containing four Chinese characters, calling Extract() on the entry that
               has question marks in the filename will result in an exception, because
               the question mark is not legal for use within filenames on Windows.  These
               are just a few examples of the problems associated to loss of information.
             </para>
            
             <para>
               This flag is independent of the encoding of the content within the entries
               in the zip file. Think of the zip file as a container - it supports an
               encoding.  Within the container are other "containers" - the file entries
               themselves.  The encoding within those entries is independent of the
               encoding of the zip archive container for those entries.
             </para>
            
             <para>
               Rather than specify the encoding in a binary fashion using this flag, an
               application can specify an arbitrary encoding via the <see
               cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/> property.  Setting the encoding
               explicitly when creating zip archives will result in non-compliant zip
               files that, curiously, are fairly interoperable.  The challenge is, the
               PKWare specification does not provide for a way to specify that an entry
               in a zip archive uses a code page that is neither IBM437 nor UTF-8.
               Therefore if you set the encoding explicitly when creating a zip archive,
               you must take care upon reading the zip archive to use the same code page.
               If you get it wrong, the behavior is undefined and may result in incorrect
               filenames, exceptions, stomach upset, hair loss, and acne.
             </para>
             </remarks>
             <seealso cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>
        </member>
        <member name="P:Ionic.Zip.ZipFile.UseZip64WhenSaving">
             <summary>
               Specify whether to use ZIP64 extensions when saving a zip archive.
             </summary>
            
             <remarks>
            
             <para>
               When creating a zip file, the default value for the property is <see
               cref="F:Ionic.Zip.Zip64Option.Never"/>. <see cref="F:Ionic.Zip.Zip64Option.AsNecessary"/> is
               safest, in the sense that you will not get an Exception if a pre-ZIP64
               limit is exceeded.
             </para>
            
             <para>
               You may set the property at any time before calling Save().
             </para>
            
             <para>
               When reading a zip file via the <c>Zipfile.Read()</c> method, DotNetZip
               will properly read ZIP64-endowed zip archives, regardless of the value of
               this property.  DotNetZip will always read ZIP64 archives.  This property
               governs only whether DotNetZip will write them. Therefore, when updating
               archives, be careful about setting this property after reading an archive
               that may use ZIP64 extensions.
             </para>
            
             <para>
               An interesting question is, if you have set this property to
               <c>AsNecessary</c>, and then successfully saved, does the resulting
               archive use ZIP64 extensions or not?  To learn this, check the <see
               cref="P:Ionic.Zip.ZipFile.OutputUsedZip64"/> property, after calling <c>Save()</c>.
             </para>
            
             <para>
               Have you thought about
               <see href="http://cheeso.members.winisp.net/DotNetZipDonate.aspx">donating</see>?
             </para>
            
             </remarks>
             <seealso cref="P:Ionic.Zip.ZipFile.RequiresZip64"/>
        </member>
        <member name="P:Ionic.Zip.ZipFile.RequiresZip64">
             <summary>
               Indicates whether the archive requires ZIP64 extensions.
             </summary>
            
             <remarks>
            
             <para>
               This property is <c>null</c> (or <c>Nothing</c> in VB) if the archive has
               not been saved, and there are fewer than 65334 <c>ZipEntry</c> items
               contained in the archive.
             </para>
            
             <para>
               The <c>Value</c> is true if any of the following four conditions holds:
               the uncompressed size of any entry is larger than 0xFFFFFFFF; the
               compressed size of any entry is larger than 0xFFFFFFFF; the relative
               offset of any entry within the zip archive is larger than 0xFFFFFFFF; or
               there are more than 65534 entries in the archive.  (0xFFFFFFFF =
               4,294,967,295).  The result may not be known until a <c>Save()</c> is attempted
               on the zip archive.  The Value of this <see cref="T:System.Nullable"/>
               property may be set only AFTER one of the Save() methods has been called.
             </para>
            
             <para>
               If none of the four conditions holds, and the archive has been saved, then
               the <c>Value</c> is false.
             </para>
            
             <para>
               A <c>Value</c> of false does not indicate that the zip archive, as saved,
               does not use ZIP64.  It merely indicates that ZIP64 is not required.  An
               archive may use ZIP64 even when not required if the <see
               cref="P:Ionic.Zip.ZipFile.UseZip64WhenSaving"/> property is set to <see
               cref="F:Ionic.Zip.Zip64Option.Always"/>, or if the <see
               cref="P:Ionic.Zip.ZipFile.UseZip64WhenSaving"/> property is set to <see
               cref="F:Ionic.Zip.Zip64Option.AsNecessary"/> and the output stream was not
               seekable. Use the <see cref="P:Ionic.Zip.ZipFile.OutputUsedZip64"/> property to determine if
               the most recent <c>Save()</c> method resulted in an archive that utilized
               the ZIP64 extensions.
             </para>
            
             </remarks>
             <seealso cref="P:Ionic.Zip.ZipFile.UseZip64WhenSaving"/>
             <seealso cref="P:Ionic.Zip.ZipFile.OutputUsedZip64"/>
        </member>
        <member name="P:Ionic.Zip.ZipFile.OutputUsedZip64">
             <summary>
               Indicates whether the most recent <c>Save()</c> operation used ZIP64 extensions.
             </summary>
            
             <remarks>
             <para>
               The use of ZIP64 extensions within an archive is not always necessary, and
               for interoperability concerns, it may be desired to NOT use ZIP64 if
               possible.  The <see cref="P:Ionic.Zip.ZipFile.UseZip64WhenSaving"/> property can be
               set to use ZIP64 extensions only when necessary.  In those cases,
               Sometimes applications want to know whether a Save() actually used ZIP64
               extensions.  Applications can query this read-only property to learn
               whether ZIP64 has been used in a just-saved <c>ZipFile</c>.
             </para>
            
             <para>
               The value is <c>null</c> (or <c>Nothing</c> in VB) if the archive has not
               been saved.
             </para>
            
             <para>
               Non-null values (<c>HasValue</c> is true) indicate whether ZIP64
               extensions were used during the most recent <c>Save()</c> operation.  The
               ZIP64 extensions may have been used as required by any particular entry
               because of its uncompressed or compressed size, or because the archive is
               larger than 4294967295 bytes, or because there are more than 65534 entries
               in the archive, or because the <c>UseZip64WhenSaving</c> property was set
               to <see cref="F:Ionic.Zip.Zip64Option.Always"/>, or because the
               <c>UseZip64WhenSaving</c> property was set to <see
               cref="F:Ionic.Zip.Zip64Option.AsNecessary"/> and the output stream was not seekable.
               The value of this property does not indicate the reason the ZIP64
               extensions were used.
             </para>
            
             </remarks>
             <seealso cref="P:Ionic.Zip.ZipFile.UseZip64WhenSaving"/>
             <seealso cref="P:Ionic.Zip.ZipFile.RequiresZip64"/>
        </member>
        <member name="P:Ionic.Zip.ZipFile.InputUsesZip64">
             <summary>
               Indicates whether the most recent <c>Read()</c> operation read a zip file that uses
               ZIP64 extensions.
             </summary>
            
             <remarks>
               This property will return null (Nothing in VB) if you've added an entry after reading
               the zip file.
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding">
             <summary>
               The text encoding to use when writing new entries to the <c>ZipFile</c>,
               for those entries that cannot be encoded with the default (IBM437)
               encoding; or, the text encoding that was used when reading the entries
               from the <c>ZipFile</c>.
             </summary>
            
             <remarks>
             <para>
               In <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">its
               zip specification</see>, PKWare describes two options for encoding
               filenames and comments: using IBM437 or UTF-8.  But, some archiving tools
               or libraries do not follow the specification, and instead encode
               characters using the system default code page.  For example, WinRAR when
               run on a machine in Shanghai may encode filenames with the Big-5 Chinese
               (950) code page.  This behavior is contrary to the Zip specification, but
               it occurs anyway.
             </para>
            
             <para>
               When using DotNetZip to write zip archives that will be read by one of
               these other archivers, set this property to specify the code page to use
               when encoding the <see cref="P:Ionic.Zip.ZipEntry.FileName"/> and <see
               cref="P:Ionic.Zip.ZipEntry.Comment"/> for each <c>ZipEntry</c> in the zip file, for
               values that cannot be encoded with the default codepage for zip files,
               IBM437.  This is why this property is "provisional".  In all cases, IBM437
               is used where possible, in other words, where no loss of data would
               result. It is possible, therefore, to have a given entry with a
               <c>Comment</c> encoded in IBM437 and a <c>FileName</c> encoded with the
               specified "provisional" codepage.
             </para>
            
             <para>
               Be aware that a zip file created after you've explicitly set the <see
               cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" /> property to a value other than
               IBM437 may not be compliant to the PKWare specification, and may not be
               readable by compliant archivers.  On the other hand, many (most?)
               archivers are non-compliant and can read zip files created in arbitrary
               code pages.  The trick is to use or specify the proper codepage when
               reading the zip.
             </para>
            
             <para>
               When creating a zip archive using this library, it is possible to change
               the value of <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" /> between each
               entry you add, and between adding entries and the call to
               <c>Save()</c>. Don't do this. It will likely result in a zipfile that is
               not readable.  For best interoperability, either leave <see
               cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" /> alone, or specify it only once,
               before adding any entries to the <c>ZipFile</c> instance.  There is one
               exception to this recommendation, described later.
             </para>
            
             <para>
               When using an arbitrary, non-UTF8 code page for encoding, there is no
               standard way for the creator application - whether DotNetZip, WinZip,
               WinRar, or something else - to formally specify in the zip file which
               codepage has been used for the entries. As a result, readers of zip files
               are not able to inspect the zip file and determine the codepage that was
               used for the entries contained within it.  It is left to the application
               or user to determine the necessary codepage when reading zip files encoded
               this way.  In other words, if you explicitly specify the codepage when you
               create the zipfile, you must explicitly specify the same codepage when
               reading the zipfile.
             </para>
            
             <para>
               The way you specify the code page to use when reading a zip file varies
               depending on the tool or library you use to read the zip.  In DotNetZip,
               you use a ZipFile.Read() method that accepts an encoding parameter.  It
               isn't possible with Windows Explorer, as far as I know, to specify an
               explicit codepage to use when reading a zip.  If you use an incorrect
               codepage when reading a zipfile, you will get entries with filenames that
               are incorrect, and the incorrect filenames may even contain characters
               that are not legal for use within filenames in Windows. Extracting entries
               with illegal characters in the filenames will lead to exceptions. It's too
               bad, but this is just the way things are with code pages in zip
               files. Caveat Emptor.
             </para>
            
             <para>
               Example: Suppose you create a zipfile that contains entries with
               filenames that have Danish characters.  If you use <see
               cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" /> equal to "iso-8859-1" (cp 28591),
               the filenames will be correctly encoded in the zip.  But, to read that
               zipfile correctly, you have to specify the same codepage at the time you
               read it. If try to read that zip file with Windows Explorer or another
               application that is not flexible with respect to the codepage used to
               decode filenames in zipfiles, you will get a filename like "Inf.txt".
             </para>
            
             <para>
               When using DotNetZip to read a zip archive, and the zip archive uses an
               arbitrary code page, you must specify the encoding to use before or when
               the <c>Zipfile</c> is READ.  This means you must use a <c>ZipFile.Read()</c>
               method that allows you to specify a System.Text.Encoding parameter.  Setting
               the ProvisionalAlternateEncoding property after your application has read in
               the zip archive will not affect the entry names of entries that have already
               been read in.
             </para>
            
             <para>
               And now, the exception to the rule described above.  One strategy for
               specifying the code page for a given zip file is to describe the code page
               in a human-readable form in the Zip comment. For example, the comment may
               read "Entries in this archive are encoded in the Big5 code page".  For
               maximum interoperability, the zip comment in this case should be encoded
               in the default, IBM437 code page.  In this case, the zip comment is
               encoded using a different page than the filenames.  To do this, Specify
               <c>ProvisionalAlternateEncoding</c> to your desired region-specific code
               page, once before adding any entries, and then reset
               <c>ProvisionalAlternateEncoding</c> to IBM437 before setting the <see
               cref="P:Ionic.Zip.ZipFile.Comment"/> property and calling Save().
             </para>
             </remarks>
            
             <example>
             This example shows how to read a zip file using the Big-5 Chinese code page
             (950), and extract each entry in the zip file.  For this code to work as
             desired, the <c>Zipfile</c> must have been created using the big5 code page
             (CP950). This is typical, for example, when using WinRar on a machine with
             CP950 set as the default code page.  In that case, the names of entries
             within the Zip archive will be stored in that code page, and reading the zip
             archive must be done using that code page.  If the application did not use
             the correct code page in <c>ZipFile.Read()</c>, then names of entries within the
             zip archive would not be correctly retrieved.
             <code>
             using (var zip = ZipFile.Read(zipFileName, System.Text.Encoding.GetEncoding("big5")))
             {
                 // retrieve and extract an entry using a name encoded with CP950
                 zip[MyDesiredEntry].Extract("unpack");
             }
             </code>
            
             <code lang="VB">
             Using zip As ZipFile = ZipFile.Read(ZipToExtract, System.Text.Encoding.GetEncoding("big5"))
                 ' retrieve and extract an entry using a name encoded with CP950
                 zip(MyDesiredEntry).Extract("unpack")
             End Using
             </code>
             </example>
            
             <seealso cref="P:Ionic.Zip.ZipFile.DefaultEncoding">DefaultEncoding</seealso>
        </member>
        <member name="P:Ionic.Zip.ZipFile.AlternateEncoding">
            <summary>
              A Text Encoding to use when encoding the filenames and comments for
              all the ZipEntry items, during a ZipFile.Save() operation.
            </summary>
            <remarks>
              <para>
                Whether the encoding specified here is used during the save depends
                on <see cref="P:Ionic.Zip.ZipFile.AlternateEncodingUsage"/>.
              </para>
            </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipFile.AlternateEncodingUsage">
            <summary>
              A flag that tells if and when this instance should apply
              AlternateEncoding to encode the filenames and comments associated to
              of ZipEntry objects contained within this instance.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipFile.DefaultEncoding">
            <summary>
            The default text encoding used in zip archives.  It is numeric 437, also
            known as IBM437.
            </summary>
            <seealso cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>
        </member>
        <member name="P:Ionic.Zip.ZipFile.StatusMessageTextWriter">
             <summary>
             Gets or sets the <c>TextWriter</c> to which status messages are delivered
             for the instance.
             </summary>
            
             <remarks>
               If the TextWriter is set to a non-null value, then verbose output is sent
               to the <c>TextWriter</c> during <c>Add</c><c>, Read</c><c>, Save</c> and
               <c>Extract</c> operations.  Typically, console applications might use
               <c>Console.Out</c> and graphical or headless applications might use a
               <c>System.IO.StringWriter</c>. The output of this is suitable for viewing
               by humans.
             </remarks>
            
             <example>
             <para>
               In this example, a console application instantiates a <c>ZipFile</c>, then
               sets the <c>StatusMessageTextWriter</c> to <c>Console.Out</c>.  At that
               point, all verbose status messages for that <c>ZipFile</c> are sent to the
               console.
             </para>
            
             <code lang="C#">
             using (ZipFile zip= ZipFile.Read(FilePath))
             {
               zip.StatusMessageTextWriter= System.Console.Out;
               // messages are sent to the console during extraction
               zip.ExtractAll();
             }
             </code>
            
             <code lang="VB">
             Using zip As ZipFile = ZipFile.Read(FilePath)
               zip.StatusMessageTextWriter= System.Console.Out
               'Status Messages will be sent to the console during extraction
               zip.ExtractAll()
             End Using
             </code>
            
             <para>
               In this example, a Windows Forms application instantiates a
               <c>ZipFile</c>, then sets the <c>StatusMessageTextWriter</c> to a
               <c>StringWriter</c>.  At that point, all verbose status messages for that
               <c>ZipFile</c> are sent to the <c>StringWriter</c>.
             </para>
            
             <code lang="C#">
             var sw = new System.IO.StringWriter();
             using (ZipFile zip= ZipFile.Read(FilePath))
             {
               zip.StatusMessageTextWriter= sw;
               zip.ExtractAll();
             }
             Console.WriteLine("{0}", sw.ToString());
             </code>
            
             <code lang="VB">
             Dim sw as New System.IO.StringWriter
             Using zip As ZipFile = ZipFile.Read(FilePath)
               zip.StatusMessageTextWriter= sw
               zip.ExtractAll()
             End Using
             'Status Messages are now available in sw
            
             </code>
             </example>
        </member>
        <member name="P:Ionic.Zip.ZipFile.TempFileFolder">
             <summary>
               Gets or sets the name for the folder to store the temporary file
               this library writes when saving a zip archive.
             </summary>
            
             <remarks>
             <para>
               This library will create a temporary file when saving a Zip archive to a
               file.  This file is written when calling one of the <c>Save()</c> methods
               that does not save to a stream, or one of the <c>SaveSelfExtractor()</c>
               methods.
             </para>
            
             <para>
               By default, the library will create the temporary file in the directory
               specified for the file itself, via the <see cref="P:Ionic.Zip.ZipFile.Name"/> property or via
               the <see cref="M:Ionic.Zip.ZipFile.Save(System.String)"/> method.
             </para>
            
             <para>
               Setting this property allows applications to override this default
               behavior, so that the library will create the temporary file in the
               specified folder. For example, to have the library create the temporary
               file in the current working directory, regardless where the <c>ZipFile</c>
               is saved, specfy ".".  To revert to the default behavior, set this
               property to <c>null</c> (<c>Nothing</c> in VB).
             </para>
            
             <para>
               When setting the property to a non-null value, the folder specified must
               exist; if it does not an exception is thrown.  The application should have
               write and delete permissions on the folder.  The permissions are not
               explicitly checked ahead of time; if the application does not have the
               appropriate rights, an exception will be thrown at the time <c>Save()</c>
               is called.
             </para>
            
             <para>
               There is no temporary file created when reading a zip archive.  When
               saving to a Stream, there is no temporary file created.  For example, if
               the application is an ASP.NET application and calls <c>Save()</c>
               specifying the <c>Response.OutputStream</c> as the output stream, there is
               no temporary file created.
             </para>
             </remarks>
            
             <exception cref="T:System.IO.FileNotFoundException">
             Thrown when setting the property if the directory does not exist.
             </exception>
            
        </member>
        <member name="P:Ionic.Zip.ZipFile.Password">
             <summary>
             Sets the password to be used on the <c>ZipFile</c> instance.
             </summary>
            
             <remarks>
            
             <para>
               When writing a zip archive, this password is applied to the entries, not
               to the zip archive itself. It applies to any <c>ZipEntry</c> subsequently
               added to the <c>ZipFile</c>, using one of the <c>AddFile</c>,
               <c>AddDirectory</c>, <c>AddEntry</c>, or <c>AddItem</c> methods, etc.
               When reading a zip archive, this property applies to any entry
               subsequently extracted from the <c>ZipFile</c> using one of the Extract
               methods on the <c>ZipFile</c> class.
             </para>
            
             <para>
               When writing a zip archive, keep this in mind: though the password is set
               on the ZipFile object, according to the Zip spec, the "directory" of the
               archive - in other words the list of entries or files contained in the archive - is
               not encrypted with the password, or protected in any way.  If you set the
               Password property, the password actually applies to individual entries
               that are added to the archive, subsequent to the setting of this property.
               The list of filenames in the archive that is eventually created will
               appear in clear text, but the contents of the individual files are
               encrypted.  This is how Zip encryption works.
             </para>
            
             <para>
               One simple way around this limitation is to simply double-wrap sensitive
               filenames: Store the files in a zip file, and then store that zip file
               within a second, "outer" zip file.  If you apply a password to the outer
               zip file, then readers will be able to see that the outer zip file
               contains an inner zip file.  But readers will not be able to read the
               directory or file list of the inner zip file.
             </para>
            
             <para>
               If you set the password on the <c>ZipFile</c>, and then add a set of files
               to the archive, then each entry is encrypted with that password.  You may
               also want to change the password between adding different entries. If you
               set the password, add an entry, then set the password to <c>null</c>
               (<c>Nothing</c> in VB), and add another entry, the first entry is
               encrypted and the second is not.  If you call <c>AddFile()</c>, then set
               the <c>Password</c> property, then call <c>ZipFile.Save</c>, the file
               added will not be password-protected, and no warning will be generated.
             </para>
            
             <para>
               When setting the Password, you may also want to explicitly set the <see
               cref="P:Ionic.Zip.ZipFile.Encryption"/> property, to specify how to encrypt the entries added
               to the ZipFile.  If you set the Password to a non-null value and do not
               set <see cref="P:Ionic.Zip.ZipFile.Encryption"/>, then PKZip 2.0 ("Weak") encryption is used.
               This encryption is relatively weak but is very interoperable. If you set
               the password to a <c>null</c> value (<c>Nothing</c> in VB), Encryption is
               reset to None.
             </para>
            
             <para>
               All of the preceding applies to writing zip archives, in other words when
               you use one of the Save methods.  To use this property when reading or an
               existing ZipFile, do the following: set the Password property on the
               <c>ZipFile</c>, then call one of the Extract() overloads on the <see
               cref="T:Ionic.Zip.ZipEntry" />. In this case, the entry is extracted using the
               <c>Password</c> that is specified on the <c>ZipFile</c> instance. If you
               have not set the <c>Password</c> property, then the password is
               <c>null</c>, and the entry is extracted with no password.
             </para>
            
             <para>
               If you set the Password property on the <c>ZipFile</c>, then call
               <c>Extract()</c> an entry that has not been encrypted with a password, the
               password is not used for that entry, and the <c>ZipEntry</c> is extracted
               as normal. In other words, the password is used only if necessary.
             </para>
            
             <para>
               The <see cref="T:Ionic.Zip.ZipEntry"/> class also has a <see
               cref="P:Ionic.Zip.ZipEntry.Password">Password</see> property.  It takes precedence
               over this property on the <c>ZipFile</c>.  Typically, you would use the
               per-entry Password when most entries in the zip archive use one password,
               and a few entries use a different password.  If all entries in the zip
               file use the same password, then it is simpler to just set this property
               on the <c>ZipFile</c> itself, whether creating a zip archive or extracting
               a zip archive.
             </para>
            
             </remarks>
            
             <example>
             <para>
               This example creates a zip file, using password protection for the
               entries, and then extracts the entries from the zip file.  When creating
               the zip file, the Readme.txt file is not protected with a password, but
               the other two are password-protected as they are saved. During extraction,
               each file is extracted with the appropriate password.
             </para>
             <code>
             // create a file with encryption
             using (ZipFile zip = new ZipFile())
             {
                 zip.AddFile("ReadMe.txt");
                 zip.Password= "!Secret1";
                 zip.AddFile("MapToTheSite-7440-N49th.png");
                 zip.AddFile("2008-Regional-Sales-Report.pdf");
                 zip.Save("EncryptedArchive.zip");
             }
            
             // extract entries that use encryption
             using (ZipFile zip = ZipFile.Read("EncryptedArchive.zip"))
             {
                 zip.Password= "!Secret1";
                 zip.ExtractAll("extractDir");
             }
            
             </code>
            
             <code lang="VB">
             Using zip As New ZipFile
                 zip.AddFile("ReadMe.txt")
                 zip.Password = "123456!"
                 zip.AddFile("MapToTheSite-7440-N49th.png")
                 zip.Password= "!Secret1";
                 zip.AddFile("2008-Regional-Sales-Report.pdf")
                 zip.Save("EncryptedArchive.zip")
             End Using
            
            
             ' extract entries that use encryption
             Using (zip as ZipFile = ZipFile.Read("EncryptedArchive.zip"))
                 zip.Password= "!Secret1"
                 zip.ExtractAll("extractDir")
             End Using
            
             </code>
            
             </example>
            
             <seealso cref="P:Ionic.Zip.ZipFile.Encryption">ZipFile.Encryption</seealso>
             <seealso cref="P:Ionic.Zip.ZipEntry.Password">ZipEntry.Password</seealso>
        </member>
        <member name="P:Ionic.Zip.ZipFile.ExtractExistingFile">
             <summary>
               The action the library should take when extracting a file that already
               exists.
             </summary>
            
             <remarks>
             <para>
               This property affects the behavior of the Extract methods (one of the
               <c>Extract()</c> or <c>ExtractWithPassword()</c> overloads), when
               extraction would would overwrite an existing filesystem file. If you do
               not set this property, the library throws an exception when extracting an
               entry would overwrite an existing file.
             </para>
            
             <para>
               This property has no effect when extracting to a stream, or when the file
               to be extracted does not already exist.
             </para>
             </remarks>
             <seealso cref="P:Ionic.Zip.ZipEntry.ExtractExistingFile"/>
        </member>
        <member name="P:Ionic.Zip.ZipFile.ZipErrorAction">
             <summary>
               The action the library should take when an error is encountered while
               opening or reading files as they are saved into a zip archive.
             </summary>
            
             <remarks>
              <para>
                Errors can occur as a file is being saved to the zip archive.  For
                example, the File.Open may fail, or a File.Read may fail, because of
                lock conflicts or other reasons.
              </para>
            
              <para>
                The first problem might occur after having called AddDirectory() on a
                directory that contains a Clipper .dbf file; the file is locked by
                Clipper and cannot be opened for read by another process. An example of
                the second problem might occur when trying to zip a .pst file that is in
                use by Microsoft Outlook. Outlook locks a range on the file, which allows
                other processes to open the file, but not read it in its entirety.
              </para>
            
              <para>
                This property tells DotNetZip what you would like to do in the case of
                these errors.  The primary options are: <c>ZipErrorAction.Throw</c> to
                throw an exception (this is the default behavior if you don't set this
                property); <c>ZipErrorAction.Skip</c> to Skip the file for which there
                was an error and continue saving; <c>ZipErrorAction.Retry</c> to Retry
                the entry that caused the problem; or
                <c>ZipErrorAction.InvokeErrorEvent</c> to invoke an event handler.
              </para>
            
              <para>
                This property is implicitly set to <c>ZipErrorAction.InvokeErrorEvent</c>
                if you add a handler to the <see cref="E:Ionic.Zip.ZipFile.ZipError" /> event.  If you set
                this property to something other than
                <c>ZipErrorAction.InvokeErrorEvent</c>, then the <c>ZipError</c>
                event is implicitly cleared.  What it means is you can set one or the
                other (or neither), depending on what you want, but you never need to set
                both.
              </para>
            
              <para>
                As with some other properties on the <c>ZipFile</c> class, like <see
                cref="P:Ionic.Zip.ZipFile.Password"/>, <see cref="P:Ionic.Zip.ZipFile.Encryption"/>, and <see
                cref="P:Ionic.Zip.ZipFile.CompressionLevel"/>, setting this property on a <c>ZipFile</c>
                instance will cause the specified <c>ZipErrorAction</c> to be used on all
                <see cref="T:Ionic.Zip.ZipEntry"/> items that are subsequently added to the
                <c>ZipFile</c> instance. If you set this property after you have added
                items to the <c>ZipFile</c>, but before you have called <c>Save()</c>,
                those items will not use the specified error handling action.
              </para>
            
              <para>
                If you want to handle any errors that occur with any entry in the zip
                file in the same way, then set this property once, before adding any
                entries to the zip archive.
              </para>
            
              <para>
                If you set this property to <c>ZipErrorAction.Skip</c> and you'd like to
                learn which files may have been skipped after a <c>Save()</c>, you can
                set the <see cref="P:Ionic.Zip.ZipFile.StatusMessageTextWriter" /> on the ZipFile before
                calling <c>Save()</c>. A message will be emitted into that writer for
                each skipped file, if any.
              </para>
            
             </remarks>
            
             <example>
               This example shows how to tell DotNetZip to skip any files for which an
               error is generated during the Save().
             <code lang="VB">
             Public Sub SaveZipFile()
                 Dim SourceFolder As String = "fodder"
                 Dim DestFile As String =  "eHandler.zip"
                 Dim sw as New StringWriter
                 Using zipArchive As ZipFile = New ZipFile
                     ' Tell DotNetZip to skip any files for which it encounters an error
                     zipArchive.ZipErrorAction = ZipErrorAction.Skip
                     zipArchive.StatusMessageTextWriter = sw
                     zipArchive.AddDirectory(SourceFolder)
                     zipArchive.Save(DestFile)
                 End Using
                 ' examine sw here to see any messages
             End Sub
            
             </code>
             </example>
            
             <seealso cref="P:Ionic.Zip.ZipEntry.ZipErrorAction"/>
             <seealso cref="E:Ionic.Zip.ZipFile.ZipError"/>
        </member>
        <member name="P:Ionic.Zip.ZipFile.Encryption">
             <summary>
               The Encryption to use for entries added to the <c>ZipFile</c>.
             </summary>
            
             <remarks>
             <para>
               Set this when creating a zip archive, or when updating a zip archive. The
               specified Encryption is applied to the entries subsequently added to the
               <c>ZipFile</c> instance.  Applications do not need to set the
               <c>Encryption</c> property when reading or extracting a zip archive.
             </para>
            
             <para>
               If you set this to something other than EncryptionAlgorithm.None, you
               will also need to set the <see cref="P:Ionic.Zip.ZipFile.Password"/>.
             </para>
            
             <para>
               As with some other properties on the <c>ZipFile</c> class, like <see
               cref="P:Ionic.Zip.ZipFile.Password"/> and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel"/>, setting this
               property on a <c>ZipFile</c> instance will cause the specified
               <c>EncryptionAlgorithm</c> to be used on all <see cref="T:Ionic.Zip.ZipEntry"/> items
               that are subsequently added to the <c>ZipFile</c> instance. In other
               words, if you set this property after you have added items to the
               <c>ZipFile</c>, but before you have called <c>Save()</c>, those items will
               not be encrypted or protected with a password in the resulting zip
               archive. To get a zip archive with encrypted entries, set this property,
               along with the <see cref="P:Ionic.Zip.ZipFile.Password"/> property, before calling
               <c>AddFile</c>, <c>AddItem</c>, or <c>AddDirectory</c> (etc.) on the
               <c>ZipFile</c> instance.
             </para>
            
             <para>
               If you read a <c>ZipFile</c>, you can modify the <c>Encryption</c> on an
               encrypted entry, only by setting the <c>Encryption</c> property on the
               <c>ZipEntry</c> itself.  Setting the <c>Encryption</c> property on the
               <c>ZipFile</c>, once it has been created via a call to
               <c>ZipFile.Read()</c>, does not affect entries that were previously read.
             </para>
            
             <para>
               For example, suppose you read a <c>ZipFile</c>, and there is an encrypted
               entry.  Setting the <c>Encryption</c> property on that <c>ZipFile</c> and
               then calling <c>Save()</c> on the <c>ZipFile</c> does not update the
               <c>Encryption</c> used for the entries in the archive.  Neither is an
               exception thrown. Instead, what happens during the <c>Save()</c> is that
               all previously existing entries are copied through to the new zip archive,
               with whatever encryption and password that was used when originally
               creating the zip archive. Upon re-reading that archive, to extract
               entries, applications should use the original password or passwords, if
               any.
             </para>
            
             <para>
               Suppose an application reads a <c>ZipFile</c>, and there is an encrypted
               entry.  Setting the <c>Encryption</c> property on that <c>ZipFile</c> and
               then adding new entries (via <c>AddFile()</c>, <c>AddEntry()</c>, etc)
               and then calling <c>Save()</c> on the <c>ZipFile</c> does not update the
               <c>Encryption</c> on any of the entries that had previously been in the
               <c>ZipFile</c>.  The <c>Encryption</c> property applies only to the
               newly-added entries.
             </para>
            
             </remarks>
            
             <example>
             <para>
               This example creates a zip archive that uses encryption, and then extracts
               entries from the archive.  When creating the zip archive, the ReadMe.txt
               file is zipped without using a password or encryption.  The other files
               use encryption.
             </para>
            
             <code>
             // Create a zip archive with AES Encryption.
             using (ZipFile zip = new ZipFile())
             {
                 zip.AddFile("ReadMe.txt");
                 zip.Encryption= EncryptionAlgorithm.WinZipAes256;
                 zip.Password= "Top.Secret.No.Peeking!";
                 zip.AddFile("7440-N49th.png");
                 zip.AddFile("2008-Regional-Sales-Report.pdf");
                 zip.Save("EncryptedArchive.zip");
             }
            
             // Extract a zip archive that uses AES Encryption.
             // You do not need to specify the algorithm during extraction.
             using (ZipFile zip = ZipFile.Read("EncryptedArchive.zip"))
             {
                 zip.Password= "Top.Secret.No.Peeking!";
                 zip.ExtractAll("extractDirectory");
             }
             </code>
            
             <code lang="VB">
             ' Create a zip that uses Encryption.
             Using zip As New ZipFile()
                 zip.Encryption= EncryptionAlgorithm.WinZipAes256
                 zip.Password= "Top.Secret.No.Peeking!"
                 zip.AddFile("ReadMe.txt")
                 zip.AddFile("7440-N49th.png")
                 zip.AddFile("2008-Regional-Sales-Report.pdf")
                 zip.Save("EncryptedArchive.zip")
             End Using
            
             ' Extract a zip archive that uses AES Encryption.
             ' You do not need to specify the algorithm during extraction.
             Using (zip as ZipFile = ZipFile.Read("EncryptedArchive.zip"))
                 zip.Password= "Top.Secret.No.Peeking!"
                 zip.ExtractAll("extractDirectory")
             End Using
             </code>
            
             </example>
            
             <seealso cref="P:Ionic.Zip.ZipFile.Password">ZipFile.Password</seealso>
             <seealso cref="P:Ionic.Zip.ZipEntry.Encryption">ZipEntry.Encryption</seealso>
        </member>
        <member name="P:Ionic.Zip.ZipFile.SetCompression">
             <summary>
               A callback that allows the application to specify the compression level
               to use for entries subsequently added to the zip archive.
             </summary>
            
             <remarks>
            
             <para>
               With this callback, the DotNetZip library allows the application to
               determine whether compression will be used, at the time of the
               <c>Save</c>. This may be useful if the application wants to favor
               speed over size, and wants to defer the decision until the time of
               <c>Save</c>.
             </para>
            
             <para>
               Typically applications set the <see cref="P:Ionic.Zip.ZipFile.CompressionLevel"/> property on
               the <c>ZipFile</c> or on each <c>ZipEntry</c> to determine the level of
               compression used. This is done at the time the entry is added to the
               <c>ZipFile</c>. Setting the property to
               <c>Ionic.Zlib.CompressionLevel.None</c> means no compression will be used.
             </para>
            
             <para>
               This callback allows the application to defer the decision on the
               <c>CompressionLevel</c> to use, until the time of the call to
               <c>ZipFile.Save()</c>. The callback is invoked once per <c>ZipEntry</c>,
               at the time the data for the entry is being written out as part of a
               <c>Save()</c> operation. The application can use whatever criteria it
               likes in determining the level to return.  For example, an application may
               wish that no .mp3 files should be compressed, because they are already
               compressed and the extra compression is not worth the CPU time incurred,
               and so can return <c>None</c> for all .mp3 entries.
             </para>
            
             <para>
               The library determines whether compression will be attempted for an entry
               this way: If the entry is a zero length file, or a directory, no
               compression is used.  Otherwise, if this callback is set, it is invoked
               and the <c>CompressionLevel</c> is set to the return value. If this
               callback has not been set, then the previously set value for
               <c>CompressionLevel</c> is used.
             </para>
            
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipFile.MaxOutputSegmentSize">
             <summary>
             The maximum size of an output segment, when saving a split Zip file.
             </summary>
             <remarks>
               <para>
                 Set this to a non-zero value before calling <see cref="M:Ionic.Zip.ZipFile.Save"/> or <see
                 cref="M:Ionic.Zip.ZipFile.Save(System.String)"/> to specify that the ZipFile should be saved as a
                 split archive, also sometimes called a spanned archive. Some also
                 call them multi-file archives.
               </para>
            
               <para>
                 A split zip archive is saved in a set of discrete filesystem files,
                 rather than in a single file. This is handy when transmitting the
                 archive in email or some other mechanism that has a limit to the size of
                 each file.  The first file in a split archive will be named
                 <c>basename.z01</c>, the second will be named <c>basename.z02</c>, and
                 so on. The final file is named <c>basename.zip</c>. According to the zip
                 specification from PKWare, the minimum value is 65536, for a 64k segment
                 size. The maximum number of segments allows in a split archive is 99.
               </para>
            
               <para>
                 The value of this property determines the maximum size of a split
                 segment when writing a split archive.  For example, suppose you have a
                 <c>ZipFile</c> that would save to a single file of 200k. If you set the
                 <c>MaxOutputSegmentSize</c> to 65536 before calling <c>Save()</c>, you
                 will get four distinct output files. On the other hand if you set this
                 property to 256k, then you will get a single-file archive for that
                 <c>ZipFile</c>.
               </para>
            
               <para>
                 The size of each split output file will be as large as possible, up to
                 the maximum size set here. The zip specification requires that some data
                 fields in a zip archive may not span a split boundary, and an output
                 segment may be smaller than the maximum if necessary to avoid that
                 problem. Also, obviously the final segment of the archive may be smaller
                 than the maximum segment size. Segments will never be larger than the
                 value set with this property.
               </para>
            
               <para>
                 You can save a split Zip file only when saving to a regular filesystem
                 file. It's not possible to save a split zip file as a self-extracting
                 archive, nor is it possible to save a split zip file to a stream. When
                 saving to a SFX or to a Stream, this property is ignored.
               </para>
            
               <para>
                 About interoperability: Split or spanned zip files produced by DotNetZip
                 can be read by WinZip or PKZip, and vice-versa. Segmented zip files may
                 not be readable by other tools, if those other tools don't support zip
                 spanning or splitting.  When in doubt, test.  I don't believe Windows
                 Explorer can extract a split archive.
               </para>
            
               <para>
                 This property has no effect when reading a split archive. You can read
                 a split archive in the normal way with DotNetZip.
               </para>
            
               <para>
                 When saving a zip file, if you want a regular zip file rather than a
                 split zip file, don't set this property, or set it to Zero.
               </para>
            
               <para>
                 If you read a split archive, with <see cref="M:Ionic.Zip.ZipFile.Read(System.String)"/> and
                 then subsequently call <c>ZipFile.Save()</c>, unless you set this
                 property before calling <c>Save()</c>, you will get a normal,
                 single-file archive.
               </para>
             </remarks>
            
             <seealso cref="P:Ionic.Zip.ZipFile.NumberOfSegmentsForMostRecentSave"/>
        </member>
        <member name="P:Ionic.Zip.ZipFile.NumberOfSegmentsForMostRecentSave">
            <summary>
              Returns the number of segments used in the most recent Save() operation.
            </summary>
            <remarks>
              <para>
                This is normally zero, unless you have set the <see
                cref="P:Ionic.Zip.ZipFile.MaxOutputSegmentSize"/> property.  If you have set <see
                cref="P:Ionic.Zip.ZipFile.MaxOutputSegmentSize"/>, and then you save a file, after the call to
                Save() completes, you can read this value to learn the number of segments that
                were created.
              </para>
              <para>
                If you call Save("Archive.zip"), and it creates 5 segments, then you
                will have filesystem files named Archive.z01, Archive.z02, Archive.z03,
                Archive.z04, and Archive.zip, and the value of this property will be 5.
              </para>
            </remarks>
            <seealso cref="P:Ionic.Zip.ZipFile.MaxOutputSegmentSize"/>
        </member>
        <member name="P:Ionic.Zip.ZipFile.ParallelDeflateThreshold">
             <summary>
               The size threshold for an entry, above which a parallel deflate is used.
             </summary>
            
             <remarks>
            
               <para>
                 DotNetZip will use multiple threads to compress any ZipEntry,
                 if the entry is larger than the given size.  Zero means "always
                 use parallel deflate", while -1 means "never use parallel
                 deflate". The default value for this property is 512k. Aside
                 from the special values of 0 and 1, the minimum value is 65536.
               </para>
            
               <para>
                 If the entry size cannot be known before compression, as with a
                 read-forward stream, then Parallel deflate will never be
                 performed, unless the value of this property is zero.
               </para>
            
               <para>
                 A parallel deflate operations will speed up the compression of
                 large files, on computers with multiple CPUs or multiple CPU
                 cores.  For files above 1mb, on a dual core or dual-cpu (2p)
                 machine, the time required to compress the file can be 70% of the
                 single-threaded deflate.  For very large files on 4p machines the
                 compression can be done in 30% of the normal time.  The downside
                 is that parallel deflate consumes extra memory during the deflate,
                 and the deflation is not as effective.
               </para>
            
               <para>
                 Parallel deflate tends to yield slightly less compression when
                 compared to as single-threaded deflate; this is because the original
                 data stream is split into multiple independent buffers, each of which
                 is compressed in parallel.  But because they are treated
                 independently, there is no opportunity to share compression
                 dictionaries.  For that reason, a deflated stream may be slightly
                 larger when compressed using parallel deflate, as compared to a
                 traditional single-threaded deflate. Sometimes the increase over the
                 normal deflate is as much as 5% of the total compressed size. For
                 larger files it can be as small as 0.1%.
               </para>
            
               <para>
                 Multi-threaded compression does not give as much an advantage when
                 using Encryption. This is primarily because encryption tends to slow
                 down the entire pipeline. Also, multi-threaded compression gives less
                 of an advantage when using lower compression levels, for example <see
                 cref="F:Ionic.Zlib.CompressionLevel.BestSpeed"/>.  You may have to
                 perform some tests to determine the best approach for your situation.
               </para>
            
             </remarks>
            
             <seealso cref="P:Ionic.Zip.ZipFile.ParallelDeflateMaxBufferPairs"/>
            
        </member>
        <member name="P:Ionic.Zip.ZipFile.ParallelDeflateMaxBufferPairs">
             <summary>
               The maximum number of buffer pairs to use when performing
               parallel compression.
             </summary>
            
             <remarks>
             <para>
               This property sets an upper limit on the number of memory
               buffer pairs to create when performing parallel
               compression.  The implementation of the parallel
               compression stream allocates multiple buffers to
               facilitate parallel compression.  As each buffer fills up,
               the stream uses <see
               cref="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)">
               ThreadPool.QueueUserWorkItem()</see> to compress those
               buffers in a background threadpool thread. After a buffer
               is compressed, it is re-ordered and written to the output
               stream.
             </para>
            
             <para>
               A higher number of buffer pairs enables a higher degree of
               parallelism, which tends to increase the speed of compression on
               multi-cpu computers.  On the other hand, a higher number of buffer
               pairs also implies a larger memory consumption, more active worker
               threads, and a higher cpu utilization for any compression. This
               property enables the application to limit its memory consumption and
               CPU utilization behavior depending on requirements.
             </para>
            
             <para>
               For each compression "task" that occurs in parallel, there are 2
               buffers allocated: one for input and one for output.  This property
               sets a limit for the number of pairs.  The total amount of storage
               space allocated for buffering will then be (N*S*2), where N is the
               number of buffer pairs, S is the size of each buffer (<see
               cref="P:Ionic.Zip.ZipFile.BufferSize"/>).  By default, DotNetZip allocates 4 buffer
               pairs per CPU core, so if your machine has 4 cores, and you retain
               the default buffer size of 128k, then the
               ParallelDeflateOutputStream will use 4 * 4 * 2 * 128kb of buffer
               memory in total, or 4mb, in blocks of 128kb.  If you then set this
               property to 8, then the number will be 8 * 2 * 128kb of buffer
               memory, or 2mb.
             </para>
            
             <para>
               CPU utilization will also go up with additional buffers, because a
               larger number of buffer pairs allows a larger number of background
               threads to compress in parallel. If you find that parallel
               compression is consuming too much memory or CPU, you can adjust this
               value downward.
             </para>
            
             <para>
               The default value is 16. Different values may deliver better or
               worse results, depending on your priorities and the dynamic
               performance characteristics of your storage and compute resources.
             </para>
            
             <para>
               This property is not the number of buffer pairs to use; it is an
               upper limit. An illustration: Suppose you have an application that
               uses the default value of this property (which is 16), and it runs
               on a machine with 2 CPU cores. In that case, DotNetZip will allocate
               4 buffer pairs per CPU core, for a total of 8 pairs.  The upper
               limit specified by this property has no effect.
             </para>
            
             <para>
               The application can set this value at any time
               before calling <c>ZipFile.Save()</c>.
             </para>
             </remarks>
            
             <seealso cref="P:Ionic.Zip.ZipFile.ParallelDeflateThreshold"/>
            
        </member>
        <member name="M:Ionic.Zip.ZipFile.ToString">
            <summary>Provides a string representation of the instance.</summary>
            <returns>a string representation of the instance.</returns>
        </member>
        <member name="P:Ionic.Zip.ZipFile.LibraryVersion">
             <summary>
             Returns the version number on the DotNetZip assembly.
             </summary>
            
             <remarks>
               <para>
                 This property is exposed as a convenience.  Callers could also get the
                 version value by retrieving GetName().Version on the
                 System.Reflection.Assembly object pointing to the DotNetZip
                 assembly. But sometimes it is not clear which assembly is being loaded.
                 This property makes it clear.
               </para>
               <para>
                 This static property is primarily useful for diagnostic purposes.
               </para>
             </remarks>
        </member>
        <member name="M:Ionic.Zip.ZipFile.#ctor(System.String)">
             <summary>
               Creates a new <c>ZipFile</c> instance, using the specified filename.
             </summary>
            
             <remarks>
             <para>
               Applications can use this constructor to create a new ZipFile for writing,
               or to slurp in an existing zip archive for read and update purposes.
             </para>
            
             <para>
               To create a new zip archive, an application can call this constructor,
               passing the name of a file that does not exist.  The name may be a fully
               qualified path. Then the application can add directories or files to the
               <c>ZipFile</c> via <c>AddDirectory()</c>, <c>AddFile()</c>, <c>AddItem()</c>
               and then write the zip archive to the disk by calling <c>Save()</c>. The
               zip file is not actually opened and written to the disk until the
               application calls <c>ZipFile.Save()</c>.  At that point the new zip file
               with the given name is created.
             </para>
            
             <para>
               If you won't know the name of the <c>Zipfile</c> until the time you call
               <c>ZipFile.Save()</c>, or if you plan to save to a stream (which has no
               name), then you should use the no-argument constructor.
             </para>
            
             <para>
               The application can also call this constructor to read an existing zip
               archive.  passing the name of a valid zip file that does exist. But, it's
               better form to use the static <see cref="M:Ionic.Zip.ZipFile.Read(System.String)"/> method,
               passing the name of the zip file, because using <c>ZipFile.Read()</c> in
               your code communicates very clearly what you are doing.  In either case,
               the file is then read into the <c>ZipFile</c> instance.  The app can then
               enumerate the entries or can modify the zip file, for example adding
               entries, removing entries, changing comments, and so on.
             </para>
            
             <para>
               One advantage to this parameterized constructor: it allows applications to
               use the same code to add items to a zip archive, regardless of whether the
               zip file exists.
             </para>
            
             <para>
               Instances of the <c>ZipFile</c> class are not multi-thread safe.  You may
               not party on a single instance with multiple threads.  You may have
               multiple threads that each use a distinct <c>ZipFile</c> instance, or you
               can synchronize multi-thread access to a single instance.
             </para>
            
             <para>
               By the way, since DotNetZip is so easy to use, don't you think <see
               href="http://cheeso.members.winisp.net/DotNetZipDonate.aspx">you should
               donate $5 or $10</see>?
             </para>
            
             </remarks>
            
             <exception cref="T:Ionic.Zip.ZipException">
             Thrown if name refers to an existing file that is not a valid zip file.
             </exception>
            
             <example>
             This example shows how to create a zipfile, and add a few files into it.
             <code>
             String ZipFileToCreate = "archive1.zip";
             String DirectoryToZip  = "c:\\reports";
             using (ZipFile zip = new ZipFile())
             {
               // Store all files found in the top level directory, into the zip archive.
               String[] filenames = System.IO.Directory.GetFiles(DirectoryToZip);
               zip.AddFiles(filenames, "files");
               zip.Save(ZipFileToCreate);
             }
             </code>
            
             <code lang="VB">
             Dim ZipFileToCreate As String = "archive1.zip"
             Dim DirectoryToZip As String = "c:\reports"
             Using zip As ZipFile = New ZipFile()
                 Dim filenames As String() = System.IO.Directory.GetFiles(DirectoryToZip)
                 zip.AddFiles(filenames, "files")
                 zip.Save(ZipFileToCreate)
             End Using
             </code>
             </example>
            
             <param name="fileName">The filename to use for the new zip archive.</param>
            
        </member>
        <member name="M:Ionic.Zip.ZipFile.#ctor(System.String,System.Text.Encoding)">
             <summary>
               Creates a new <c>ZipFile</c> instance, using the specified name for the
               filename, and the specified Encoding.
             </summary>
            
             <remarks>
             <para>
               See the documentation on the <see cref="M:Ionic.Zip.ZipFile.#ctor(System.String)">ZipFile
               constructor that accepts a single string argument</see> for basic
               information on all the <c>ZipFile</c> constructors.
             </para>
            
             <para>
               The Encoding is used as the default alternate encoding for entries with
               filenames or comments that cannot be encoded with the IBM437 code page.
               This is equivalent to setting the <see
               cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/> property on the <c>ZipFile</c>
               instance after construction.
             </para>
            
             <para>
               Instances of the <c>ZipFile</c> class are not multi-thread safe.  You may
               not party on a single instance with multiple threads.  You may have
               multiple threads that each use a distinct <c>ZipFile</c> instance, or you
               can synchronize multi-thread access to a single instance.
             </para>
            
             </remarks>
            
             <exception cref="T:Ionic.Zip.ZipException">
             Thrown if name refers to an existing file that is not a valid zip file.
             </exception>
            
             <param name="fileName">The filename to use for the new zip archive.</param>
             <param name="encoding">The Encoding is used as the default alternate
             encoding for entries with filenames or comments that cannot be encoded
             with the IBM437 code page. </param>
        </member>
        <member name="M:Ionic.Zip.ZipFile.#ctor">
             <summary>
               Create a zip file, without specifying a target filename or stream to save to.
             </summary>
            
             <remarks>
             <para>
               See the documentation on the <see cref="M:Ionic.Zip.ZipFile.#ctor(System.String)">ZipFile
               constructor that accepts a single string argument</see> for basic
               information on all the <c>ZipFile</c> constructors.
             </para>
            
             <para>
               After instantiating with this constructor and adding entries to the
               archive, the application should call <see cref="M:Ionic.Zip.ZipFile.Save(System.String)"/> or
               <see cref="M:Ionic.Zip.ZipFile.Save(System.IO.Stream)"/> to save to a file or a
               stream, respectively.  The application can also set the <see cref="P:Ionic.Zip.ZipFile.Name"/>
               property and then call the no-argument <see cref="M:Ionic.Zip.ZipFile.Save"/> method.  (This
               is the preferred approach for applications that use the library through
               COM interop.)  If you call the no-argument <see cref="M:Ionic.Zip.ZipFile.Save"/> method
               without having set the <c>Name</c> of the <c>ZipFile</c>, either through
               the parameterized constructor or through the explicit property , the
               Save() will throw, because there is no place to save the file.  </para>
            
             <para>
               Instances of the <c>ZipFile</c> class are not multi-thread safe.  You may
               have multiple threads that each use a distinct <c>ZipFile</c> instance, or
               you can synchronize multi-thread access to a single instance.  </para>
            
             </remarks>
            
             <example>
             This example creates a Zip archive called Backup.zip, containing all the files
             in the directory DirectoryToZip. Files within subdirectories are not zipped up.
             <code>
             using (ZipFile zip = new ZipFile())
             {
               // Store all files found in the top level directory, into the zip archive.
               // note: this code does not recurse subdirectories!
               String[] filenames = System.IO.Directory.GetFiles(DirectoryToZip);
               zip.AddFiles(filenames, "files");
               zip.Save("Backup.zip");
             }
             </code>
            
             <code lang="VB">
             Using zip As New ZipFile
                 ' Store all files found in the top level directory, into the zip archive.
                 ' note: this code does not recurse subdirectories!
                 Dim filenames As String() = System.IO.Directory.GetFiles(DirectoryToZip)
                 zip.AddFiles(filenames, "files")
                 zip.Save("Backup.zip")
             End Using
             </code>
             </example>
        </member>
        <member name="M:Ionic.Zip.ZipFile.#ctor(System.Text.Encoding)">
             <summary>
               Create a zip file, specifying a text Encoding, but without specifying a
               target filename or stream to save to.
             </summary>
            
             <remarks>
             <para>
               See the documentation on the <see cref="M:Ionic.Zip.ZipFile.#ctor(System.String)">ZipFile
               constructor that accepts a single string argument</see> for basic
               information on all the <c>ZipFile</c> constructors.
             </para>
            
             </remarks>
            
             <param name="encoding">
             The Encoding is used as the default alternate encoding for entries with
             filenames or comments that cannot be encoded with the IBM437 code page.
             </param>
        </member>
        <member name="M:Ionic.Zip.ZipFile.#ctor(System.String,System.IO.TextWriter)">
             <summary>
               Creates a new <c>ZipFile</c> instance, using the specified name for the
               filename, and the specified status message writer.
             </summary>
            
             <remarks>
             <para>
               See the documentation on the <see cref="M:Ionic.Zip.ZipFile.#ctor(System.String)">ZipFile
               constructor that accepts a single string argument</see> for basic
               information on all the <c>ZipFile</c> constructors.
             </para>
            
             <para>
               This version of the constructor allows the caller to pass in a TextWriter,
               to which verbose messages will be written during extraction or creation of
               the zip archive.  A console application may wish to pass
               System.Console.Out to get messages on the Console. A graphical or headless
               application may wish to capture the messages in a different
               <c>TextWriter</c>, for example, a <c>StringWriter</c>, and then display
               the messages in a TextBox, or generate an audit log of ZipFile operations.
             </para>
            
             <para>
               To encrypt the data for the files added to the <c>ZipFile</c> instance,
               set the Password property after creating the <c>ZipFile</c> instance.
             </para>
            
             <para>
               Instances of the <c>ZipFile</c> class are not multi-thread safe.  You may
               not party on a single instance with multiple threads.  You may have
               multiple threads that each use a distinct <c>ZipFile</c> instance, or you
               can synchronize multi-thread access to a single instance.
             </para>
            
             </remarks>
            
             <exception cref="T:Ionic.Zip.ZipException">
             Thrown if name refers to an existing file that is not a valid zip file.
             </exception>
            
             <example>
             <code>
             using (ZipFile zip = new ZipFile("Backup.zip", Console.Out))
             {
               // Store all files found in the top level directory, into the zip archive.
               // note: this code does not recurse subdirectories!
               // Status messages will be written to Console.Out
               String[] filenames = System.IO.Directory.GetFiles(DirectoryToZip);
               zip.AddFiles(filenames);
               zip.Save();
             }
             </code>
            
             <code lang="VB">
             Using zip As New ZipFile("Backup.zip", Console.Out)
                 ' Store all files found in the top level directory, into the zip archive.
                 ' note: this code does not recurse subdirectories!
                 ' Status messages will be written to Console.Out
                 Dim filenames As String() = System.IO.Directory.GetFiles(DirectoryToZip)
                 zip.AddFiles(filenames)
                 zip.Save()
             End Using
             </code>
             </example>
            
             <param name="fileName">The filename to use for the new zip archive.</param>
             <param name="statusMessageWriter">A TextWriter to use for writing
             verbose status messages.</param>
        </member>
        <member name="M:Ionic.Zip.ZipFile.#ctor(System.String,System.IO.TextWriter,System.Text.Encoding)">
             <summary>
               Creates a new <c>ZipFile</c> instance, using the specified name for the
               filename, the specified status message writer, and the specified Encoding.
             </summary>
            
             <remarks>
             <para>
               This constructor works like the <see cref="M:Ionic.Zip.ZipFile.#ctor(System.String)">ZipFile
               constructor that accepts a single string argument.</see> See that
               reference for detail on what this constructor does.
             </para>
            
             <para>
               This version of the constructor allows the caller to pass in a
               <c>TextWriter</c>, and an Encoding.  The <c>TextWriter</c> will collect
               verbose messages that are generated by the library during extraction or
               creation of the zip archive.  A console application may wish to pass
               <c>System.Console.Out</c> to get messages on the Console. A graphical or
               headless application may wish to capture the messages in a different
               <c>TextWriter</c>, for example, a <c>StringWriter</c>, and then display
               the messages in a <c>TextBox</c>, or generate an audit log of
               <c>ZipFile</c> operations.
             </para>
            
             <para>
               The <c>Encoding</c> is used as the default alternate encoding for entries
               with filenames or comments that cannot be encoded with the IBM437 code
               page.  This is a equivalent to setting the <see
               cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/> property on the <c>ZipFile</c>
               instance after construction.
             </para>
            
             <para>
               To encrypt the data for the files added to the <c>ZipFile</c> instance,
               set the <c>Password</c> property after creating the <c>ZipFile</c>
               instance.
             </para>
            
             <para>
               Instances of the <c>ZipFile</c> class are not multi-thread safe.  You may
               not party on a single instance with multiple threads.  You may have
               multiple threads that each use a distinct <c>ZipFile</c> instance, or you
               can synchronize multi-thread access to a single instance.
             </para>
            
             </remarks>
            
             <exception cref="T:Ionic.Zip.ZipException">
             Thrown if <c>fileName</c> refers to an existing file that is not a valid zip file.
             </exception>
            
             <param name="fileName">The filename to use for the new zip archive.</param>
             <param name="statusMessageWriter">A TextWriter to use for writing verbose
             status messages.</param>
             <param name="encoding">
             The Encoding is used as the default alternate encoding for entries with
             filenames or comments that cannot be encoded with the IBM437 code page.
             </param>
        </member>
        <member name="M:Ionic.Zip.ZipFile.Initialize(System.String)">
             <summary>
               Initialize a <c>ZipFile</c> instance by reading in a zip file.
             </summary>
            
             <remarks>
            
             <para>
               This method is primarily useful from COM Automation environments, when
               reading or extracting zip files. In COM, it is not possible to invoke
               parameterized constructors for a class. A COM Automation application can
               update a zip file by using the <see cref="M:Ionic.Zip.ZipFile.#ctor">default (no argument)
               constructor</see>, then calling <c>Initialize()</c> to read the contents
               of an on-disk zip archive into the <c>ZipFile</c> instance.
             </para>
            
             <para>
               .NET applications are encouraged to use the <c>ZipFile.Read()</c> methods
               for better clarity.
             </para>
            
             </remarks>
             <param name="fileName">the name of the existing zip file to read in.</param>
        </member>
        <member name="P:Ionic.Zip.ZipFile.Item(System.Int32)">
             <summary>
               This is an integer indexer into the Zip archive.
             </summary>
            
             <remarks>
             <para>
               This property is read-only.
             </para>
            
             <para>
               Internally, the <c>ZipEntry</c> instances that belong to the
               <c>ZipFile</c> are stored in a Dictionary.  When you use this
               indexer the first time, it creates a read-only
               <c>List&lt;ZipEntry&gt;</c> from the Dictionary.Values Collection.
               If at any time you modify the set of entries in the <c>ZipFile</c>,
               either by adding an entry, removing an entry, or renaming an
               entry, a new List will be created, and the numeric indexes for the
               remaining entries may be different.
             </para>
            
             <para>
               This means you cannot rename any ZipEntry from
               inside an enumeration of the zip file.
             </para>
            
             <param name="ix">
               The index value.
             </param>
            
             </remarks>
            
             <returns>
               The <c>ZipEntry</c> within the Zip archive at the specified index. If the
               entry does not exist in the archive, this indexer throws.
             </returns>
            
        </member>
        <member name="P:Ionic.Zip.ZipFile.Item(System.String)">
             <summary>
               This is a name-based indexer into the Zip archive.
             </summary>
            
             <remarks>
             <para>
               This property is read-only.
             </para>
            
             <para>
               The <see cref="P:Ionic.Zip.ZipFile.CaseSensitiveRetrieval"/> property on the <c>ZipFile</c>
               determines whether retrieval via this indexer is done via case-sensitive
               comparisons. By default, retrieval is not case sensitive.  This makes
               sense on Windows, in which filesystems are not case sensitive.
             </para>
            
             <para>
               Regardless of case-sensitivity, it is not always the case that
               <c>this[value].FileName == value</c>. In other words, the <c>FileName</c>
               property of the <c>ZipEntry</c> retrieved with this indexer, may or may
               not be equal to the index value.
             </para>
            
             <para>
               This is because DotNetZip performs a normalization of filenames passed to
               this indexer, before attempting to retrieve the item.  That normalization
               includes: removal of a volume letter and colon, swapping backward slashes
               for forward slashes.  So, <c>zip["dir1\\entry1.txt"].FileName ==
               "dir1/entry.txt"</c>.
             </para>
            
             <para>
               Directory entries in the zip file may be retrieved via this indexer only
               with names that have a trailing slash. DotNetZip automatically appends a
               trailing slash to the names of any directory entries added to a zip.
             </para>
            
             </remarks>
            
             <example>
             This example extracts only the entries in a zip file that are .txt files.
             <code>
             using (ZipFile zip = ZipFile.Read("PackedDocuments.zip"))
             {
               foreach (string s1 in zip.EntryFilenames)
               {
                 if (s1.EndsWith(".txt"))
                   zip[s1].Extract("textfiles");
               }
             }
             </code>
             <code lang="VB">
               Using zip As ZipFile = ZipFile.Read("PackedDocuments.zip")
                   Dim s1 As String
                   For Each s1 In zip.EntryFilenames
                       If s1.EndsWith(".txt") Then
                           zip(s1).Extract("textfiles")
                       End If
                   Next
               End Using
             </code>
             </example>
             <seealso cref="M:Ionic.Zip.ZipFile.RemoveEntry(System.String)"/>
            
             <exception cref="T:System.ArgumentException">
               Thrown if the caller attempts to assign a non-null value to the indexer.
             </exception>
            
             <param name="fileName">
               The name of the file, including any directory path, to retrieve from the
               zip.  The filename match is not case-sensitive by default; you can use the
               <see cref="P:Ionic.Zip.ZipFile.CaseSensitiveRetrieval"/> property to change this behavior. The
               pathname can use forward-slashes or backward slashes.
             </param>
            
             <returns>
               The <c>ZipEntry</c> within the Zip archive, given by the specified
               filename. If the named entry does not exist in the archive, this indexer
               returns <c>null</c> (<c>Nothing</c> in VB).
             </returns>
            
        </member>
        <member name="P:Ionic.Zip.ZipFile.EntryFileNames">
             <summary>
               The list of filenames for the entries contained within the zip archive.
             </summary>
            
             <remarks>
               According to the ZIP specification, the names of the entries use forward
               slashes in pathnames.  If you are scanning through the list, you may have
               to swap forward slashes for backslashes.
             </remarks>
            
             <seealso cref="P:Ionic.Zip.ZipFile.Item(System.String)"/>
            
             <example>
               This example shows one way to test if a filename is already contained
               within a zip archive.
             <code>
             String zipFileToRead= "PackedDocuments.zip";
             string candidate = "DatedMaterial.xps";
             using (ZipFile zip = new ZipFile(zipFileToRead))
             {
               if (zip.EntryFilenames.Contains(candidate))
                 Console.WriteLine("The file '{0}' exists in the zip archive '{1}'",
                                   candidate,
                                   zipFileName);
               else
                 Console.WriteLine("The file, '{0}', does not exist in the zip archive '{1}'",
                                   candidate,
                                   zipFileName);
               Console.WriteLine();
             }
             </code>
             <code lang="VB">
               Dim zipFileToRead As String = "PackedDocuments.zip"
               Dim candidate As String = "DatedMaterial.xps"
               Using zip As ZipFile.Read(ZipFileToRead)
                   If zip.EntryFilenames.Contains(candidate) Then
                       Console.WriteLine("The file '{0}' exists in the zip archive '{1}'", _
                                   candidate, _
                                   zipFileName)
                   Else
                     Console.WriteLine("The file, '{0}', does not exist in the zip archive '{1}'", _
                                   candidate, _
                                   zipFileName)
                   End If
                   Console.WriteLine
               End Using
             </code>
             </example>
            
             <returns>
               The list of strings for the filenames contained within the Zip archive.
             </returns>
            
        </member>
        <member name="P:Ionic.Zip.ZipFile.Entries">
             <summary>
               Returns the readonly collection of entries in the Zip archive.
             </summary>
            
             <remarks>
            
             <para>
               If there are no entries in the current <c>ZipFile</c>, the value returned is a
               non-null zero-element collection.  If there are entries in the zip file,
               the elements are returned in no particular order.
             </para>
             <para>
               This is the implied enumerator on the <c>ZipFile</c> class.  If you use a
               <c>ZipFile</c> instance in a context that expects an enumerator, you will
               get this collection.
             </para>
             </remarks>
             <seealso cref="P:Ionic.Zip.ZipFile.EntriesSorted"/>
        </member>
        <member name="P:Ionic.Zip.ZipFile.EntriesSorted">
             <summary>
               Returns a readonly collection of entries in the Zip archive, sorted by FileName.
             </summary>
            
             <remarks>
               If there are no entries in the current <c>ZipFile</c>, the value returned
               is a non-null zero-element collection.  If there are entries in the zip
               file, the elements are returned sorted by the name of the entry.
             </remarks>
            
             <example>
            
               This example fills a Windows Forms ListView with the entries in a zip file.
            
             <code lang="C#">
             using (ZipFile zip = ZipFile.Read(zipFile))
             {
                 foreach (ZipEntry entry in zip.EntriesSorted)
                 {
                     ListViewItem item = new ListViewItem(n.ToString());
                     n++;
                     string[] subitems = new string[] {
                         entry.FileName.Replace("/","\\"),
                         entry.LastModified.ToString("yyyy-MM-dd HH:mm:ss"),
                         entry.UncompressedSize.ToString(),
                         String.Format("{0,5:F0}%", entry.CompressionRatio),
                         entry.CompressedSize.ToString(),
                         (entry.UsesEncryption) ? "Y" : "N",
                         String.Format("{0:X8}", entry.Crc)};
            
                     foreach (String s in subitems)
                     {
                         ListViewItem.ListViewSubItem subitem = new ListViewItem.ListViewSubItem();
                         subitem.Text = s;
                         item.SubItems.Add(subitem);
                     }
            
                     this.listView1.Items.Add(item);
                 }
             }
             </code>
             </example>
            
             <seealso cref="P:Ionic.Zip.ZipFile.Entries"/>
        </member>
        <member name="P:Ionic.Zip.ZipFile.Count">
            <summary>
            Returns the number of entries in the Zip archive.
            </summary>
        </member>
        <member name="M:Ionic.Zip.ZipFile.RemoveEntry(Ionic.Zip.ZipEntry)">
             <summary>
               Removes the given <c>ZipEntry</c> from the zip archive.
             </summary>
            
             <remarks>
             <para>
               After calling <c>RemoveEntry</c>, the application must call <c>Save</c> to
               make the changes permanent.
             </para>
             </remarks>
            
             <exception cref="T:System.ArgumentException">
               Thrown if the specified <c>ZipEntry</c> does not exist in the <c>ZipFile</c>.
             </exception>
            
             <example>
               In this example, all entries in the zip archive dating from before
               December 31st, 2007, are removed from the archive.  This is actually much
               easier if you use the RemoveSelectedEntries method.  But I needed an
               example for RemoveEntry, so here it is.
             <code>
             String ZipFileToRead = "ArchiveToModify.zip";
             System.DateTime Threshold = new System.DateTime(2007,12,31);
             using (ZipFile zip = ZipFile.Read(ZipFileToRead))
             {
               var EntriesToRemove = new System.Collections.Generic.List&lt;ZipEntry&gt;();
               foreach (ZipEntry e in zip)
               {
                 if (e.LastModified &lt; Threshold)
                 {
                   // We cannot remove the entry from the list, within the context of
                   // an enumeration of said list.
                   // So we add the doomed entry to a list to be removed later.
                   EntriesToRemove.Add(e);
                 }
               }
            
               // actually remove the doomed entries.
               foreach (ZipEntry zombie in EntriesToRemove)
                 zip.RemoveEntry(zombie);
            
               zip.Comment= String.Format("This zip archive was updated at {0}.",
                                          System.DateTime.Now.ToString("G"));
            
               // save with a different name
               zip.Save("Archive-Updated.zip");
             }
             </code>
            
             <code lang="VB">
               Dim ZipFileToRead As String = "ArchiveToModify.zip"
               Dim Threshold As New DateTime(2007, 12, 31)
               Using zip As ZipFile = ZipFile.Read(ZipFileToRead)
                   Dim EntriesToRemove As New System.Collections.Generic.List(Of ZipEntry)
                   Dim e As ZipEntry
                   For Each e In zip
                       If (e.LastModified &lt; Threshold) Then
                           ' We cannot remove the entry from the list, within the context of
                           ' an enumeration of said list.
                           ' So we add the doomed entry to a list to be removed later.
                           EntriesToRemove.Add(e)
                       End If
                   Next
            
                   ' actually remove the doomed entries.
                   Dim zombie As ZipEntry
                   For Each zombie In EntriesToRemove
                       zip.RemoveEntry(zombie)
                   Next
                   zip.Comment = String.Format("This zip archive was updated at {0}.", DateTime.Now.ToString("G"))
                   'save as a different name
                   zip.Save("Archive-Updated.zip")
               End Using
             </code>
             </example>
            
             <param name="entry">
             The <c>ZipEntry</c> to remove from the zip.
             </param>
            
             <seealso cref="!:Ionic.Zip.ZipFile.RemoveSelectedEntries(string)"/>
            
        </member>
        <member name="M:Ionic.Zip.ZipFile.RemoveEntry(System.String)">
             <summary>
             Removes the <c>ZipEntry</c> with the given filename from the zip archive.
             </summary>
            
             <remarks>
             <para>
               After calling <c>RemoveEntry</c>, the application must call <c>Save</c> to
               make the changes permanent.
             </para>
            
             </remarks>
            
             <exception cref="T:System.InvalidOperationException">
               Thrown if the <c>ZipFile</c> is not updatable.
             </exception>
            
             <exception cref="T:System.ArgumentException">
               Thrown if a <c>ZipEntry</c> with the specified filename does not exist in
               the <c>ZipFile</c>.
             </exception>
            
             <example>
            
               This example shows one way to remove an entry with a given filename from
               an existing zip archive.
            
             <code>
             String zipFileToRead= "PackedDocuments.zip";
             string candidate = "DatedMaterial.xps";
             using (ZipFile zip = ZipFile.Read(zipFileToRead))
             {
               if (zip.EntryFilenames.Contains(candidate))
               {
                 zip.RemoveEntry(candidate);
                 zip.Comment= String.Format("The file '{0}' has been removed from this archive.",
                                            Candidate);
                 zip.Save();
               }
             }
             </code>
             <code lang="VB">
               Dim zipFileToRead As String = "PackedDocuments.zip"
               Dim candidate As String = "DatedMaterial.xps"
               Using zip As ZipFile = ZipFile.Read(zipFileToRead)
                   If zip.EntryFilenames.Contains(candidate) Then
                       zip.RemoveEntry(candidate)
                       zip.Comment = String.Format("The file '{0}' has been removed from this archive.", Candidate)
                       zip.Save
                   End If
               End Using
             </code>
             </example>
            
             <param name="fileName">
             The name of the file, including any directory path, to remove from the zip.
             The filename match is not case-sensitive by default; you can use the
             <c>CaseSensitiveRetrieval</c> property to change this behavior. The
             pathname can use forward-slashes or backward slashes.
             </param>
            
        </member>
        <member name="M:Ionic.Zip.ZipFile.Dispose">
             <summary>
               Closes the read and write streams associated
               to the <c>ZipFile</c>, if necessary.
             </summary>
            
             <remarks>
               The Dispose() method is generally employed implicitly, via a <c>using(..) {..}</c>
               statement. (<c>Using...End Using</c> in VB) If you do not employ a using
               statement, insure that your application calls Dispose() explicitly.  For
               example, in a Powershell application, or an application that uses the COM
               interop interface, you must call Dispose() explicitly.
             </remarks>
            
             <example>
             This example extracts an entry selected by name, from the Zip file to the
             Console.
             <code>
             using (ZipFile zip = ZipFile.Read(zipfile))
             {
               foreach (ZipEntry e in zip)
               {
                 if (WantThisEntry(e.FileName))
                   zip.Extract(e.FileName, Console.OpenStandardOutput());
               }
             } // Dispose() is called implicitly here.
             </code>
            
             <code lang="VB">
             Using zip As ZipFile = ZipFile.Read(zipfile)
                 Dim e As ZipEntry
                 For Each e In zip
                   If WantThisEntry(e.FileName) Then
                       zip.Extract(e.FileName, Console.OpenStandardOutput())
                   End If
                 Next
             End Using ' Dispose is implicity called here
             </code>
             </example>
        </member>
        <member name="M:Ionic.Zip.ZipFile.Dispose(System.Boolean)">
             <summary>
               Disposes any managed resources, if the flag is set, then marks the
               instance disposed.  This method is typically not called explicitly from
               application code.
             </summary>
            
             <remarks>
               Applications should call <see cref="M:Ionic.Zip.ZipFile.Dispose">the no-arg Dispose method</see>.
             </remarks>
            
             <param name="disposeManagedResources">
               indicates whether the method should dispose streams or not.
             </param>
        </member>
        <member name="F:Ionic.Zip.ZipFile.BufferSizeDefault">
            <summary>
              Default size of the buffer used for IO.
            </summary>
        </member>
        <member name="M:Ionic.Zip.ZipFile.Read(System.String)">
             <summary>
             Reads a zip file archive and returns the instance.
             </summary>
            
             <remarks>
             <para>
             The stream is read using the default <c>System.Text.Encoding</c>, which is the
             <c>IBM437</c> codepage.
             </para>
             </remarks>
            
             <exception cref="T:System.Exception">
             Thrown if the <c>ZipFile</c> cannot be read. The implementation of this method
             relies on <c>System.IO.File.OpenRead</c>, which can throw a variety of exceptions,
             including specific exceptions if a file is not found, an unauthorized access
             exception, exceptions for poorly formatted filenames, and so on.
             </exception>
            
             <param name="fileName">
             The name of the zip archive to open.  This can be a fully-qualified or relative
             pathname.
             </param>
            
             <seealso cref="M:Ionic.Zip.ZipFile.Read(System.String,Ionic.Zip.ReadOptions)"/>.
            
             <returns>The instance read from the zip archive.</returns>
            
        </member>
        <member name="M:Ionic.Zip.ZipFile.Read(System.String,Ionic.Zip.ReadOptions)">
             <summary>
               Reads a zip file archive from the named filesystem file using the
               specified options.
             </summary>
            
             <remarks>
             <para>
               This version of the <c>Read()</c> method allows the caller to pass
               in a <c>TextWriter</c> an <c>Encoding</c>, via an instance of the
               <c>ReadOptions</c> class.  The <c>ZipFile</c> is read in using the
               specified encoding for entries where UTF-8 encoding is not
               explicitly specified.
             </para>
             </remarks>
            
             <example>
            
             <para>
               This example shows how to read a zip file using the Big-5 Chinese
               code page (950), and extract each entry in the zip file, while
               sending status messages out to the Console.
             </para>
            
             <para>
               For this code to work as intended, the zipfile must have been
               created using the big5 code page (CP950). This is typical, for
               example, when using WinRar on a machine with CP950 set as the
               default code page.  In that case, the names of entries within the
               Zip archive will be stored in that code page, and reading the zip
               archive must be done using that code page.  If the application did
               not use the correct code page in ZipFile.Read(), then names of
               entries within the zip archive would not be correctly retrieved.
             </para>
            
             <code lang="C#">
             string zipToExtract = "MyArchive.zip";
             string extractDirectory = "extract";
             var options = new ReadOptions
             {
               StatusMessageWriter = System.Console.Out,
               Encoding = System.Text.Encoding.GetEncoding(950)
             };
             using (ZipFile zip = ZipFile.Read(zipToExtract, options))
             {
               foreach (ZipEntry e in zip)
               {
                  e.Extract(extractDirectory);
               }
             }
             </code>
            
            
             <code lang="VB">
             Dim zipToExtract as String = "MyArchive.zip"
             Dim extractDirectory as String = "extract"
             Dim options as New ReadOptions
             options.Encoding = System.Text.Encoding.GetEncoding(950)
             options.StatusMessageWriter = System.Console.Out
             Using zip As ZipFile = ZipFile.Read(zipToExtract, options)
                 Dim e As ZipEntry
                 For Each e In zip
                  e.Extract(extractDirectory)
                 Next
             End Using
             </code>
             </example>
            
            
             <example>
            
             <para>
               This example shows how to read a zip file using the default
               code page, to remove entries that have a modified date before a given threshold,
               sending status messages out to a <c>StringWriter</c>.
             </para>
            
             <code lang="C#">
             var options = new ReadOptions
             {
               StatusMessageWriter = new System.IO.StringWriter()
             };
             using (ZipFile zip =  ZipFile.Read("PackedDocuments.zip", options))
             {
               var Threshold = new DateTime(2007,7,4);
               // We cannot remove the entry from the list, within the context of
               // an enumeration of said list.
               // So we add the doomed entry to a list to be removed later.
               // pass 1: mark the entries for removal
               var MarkedEntries = new System.Collections.Generic.List&lt;ZipEntry&gt;();
               foreach (ZipEntry e in zip)
               {
                 if (e.LastModified &lt; Threshold)
                   MarkedEntries.Add(e);
               }
               // pass 2: actually remove the entry.
               foreach (ZipEntry zombie in MarkedEntries)
                  zip.RemoveEntry(zombie);
               zip.Comment = "This archive has been updated.";
               zip.Save();
             }
             // can now use contents of sw, eg store in an audit log
             </code>
            
             <code lang="VB">
             Dim options as New ReadOptions
             options.StatusMessageWriter = New System.IO.StringWriter
             Using zip As ZipFile = ZipFile.Read("PackedDocuments.zip", options)
                 Dim Threshold As New DateTime(2007, 7, 4)
                 ' We cannot remove the entry from the list, within the context of
                 ' an enumeration of said list.
                 ' So we add the doomed entry to a list to be removed later.
                 ' pass 1: mark the entries for removal
                 Dim MarkedEntries As New System.Collections.Generic.List(Of ZipEntry)
                 Dim e As ZipEntry
                 For Each e In zip
                     If (e.LastModified &lt; Threshold) Then
                         MarkedEntries.Add(e)
                     End If
                 Next
                 ' pass 2: actually remove the entry.
                 Dim zombie As ZipEntry
                 For Each zombie In MarkedEntries
                     zip.RemoveEntry(zombie)
                 Next
                 zip.Comment = "This archive has been updated."
                 zip.Save
             End Using
             ' can now use contents of sw, eg store in an audit log
             </code>
             </example>
            
             <exception cref="T:System.Exception">
               Thrown if the zipfile cannot be read. The implementation of
               this method relies on <c>System.IO.File.OpenRead</c>, which
               can throw a variety of exceptions, including specific
               exceptions if a file is not found, an unauthorized access
               exception, exceptions for poorly formatted filenames, and so
               on.
             </exception>
            
             <param name="fileName">
             The name of the zip archive to open.
             This can be a fully-qualified or relative pathname.
             </param>
            
             <param name="options">
             The set of options to use when reading the zip file.
             </param>
            
             <returns>The ZipFile instance read from the zip archive.</returns>
            
             <seealso cref="M:Ionic.Zip.ZipFile.Read(System.IO.Stream,Ionic.Zip.ReadOptions)"/>
            
        </member>
        <member name="M:Ionic.Zip.ZipFile.Read(System.String,System.IO.TextWriter,System.Text.Encoding,System.EventHandler{Ionic.Zip.ReadProgressEventArgs})">
             <summary>
             Reads a zip file archive using the specified text encoding,  the specified
             TextWriter for status messages, and the specified ReadProgress event handler,
             and returns the instance.
             </summary>
            
             <param name="fileName">
             The name of the zip archive to open.
             This can be a fully-qualified or relative pathname.
             </param>
            
             <param name="readProgress">
             An event handler for Read operations.
             </param>
            
             <param name="statusMessageWriter">
             The <c>System.IO.TextWriter</c> to use for writing verbose status messages
             during operations on the zip archive.  A console application may wish to
             pass <c>System.Console.Out</c> to get messages on the Console. A graphical
             or headless application may wish to capture the messages in a different
             <c>TextWriter</c>, such as a <c>System.IO.StringWriter</c>.
             </param>
            
             <param name="encoding">
             The <c>System.Text.Encoding</c> to use when reading in the zip archive. Be
             careful specifying the encoding.  If the value you use here is not the same
             as the Encoding used when the zip archive was created (possibly by a
             different archiver) you will get unexpected results and possibly exceptions.
             </param>
            
             <returns>The instance read from the zip archive.</returns>
            
        </member>
        <member name="M:Ionic.Zip.ZipFile.Read(System.IO.Stream)">
             <summary>
               Reads a zip archive from a stream.
             </summary>
            
             <remarks>
            
             <para>
               When reading from a file, it's probably easier to just use
               <see cref="M:Ionic.Zip.ZipFile.Read(System.String,Ionic.Zip.ReadOptions)">ZipFile.Read(String, ReadOptions)</see>.  This
               overload is useful when when the zip archive content is
               available from an already-open stream. The stream must be
               open and readable and seekable when calling this method.  The
               stream is left open when the reading is completed.
             </para>
            
             <para>
               Using this overload, the stream is read using the default
               <c>System.Text.Encoding</c>, which is the <c>IBM437</c>
               codepage. If you want to specify the encoding to use when
               reading the zipfile content, see
               <see cref="M:Ionic.Zip.ZipFile.Read(System.IO.Stream,Ionic.Zip.ReadOptions)">ZipFile.Read(Stream, ReadOptions)</see>.  This
             </para>
            
             <para>
               Reading of zip content begins at the current position in the
               stream.  This means if you have a stream that concatenates
               regular data and zip data, if you position the open, readable
               stream at the start of the zip data, you will be able to read
               the zip archive using this constructor, or any of the ZipFile
               constructors that accept a <see cref="T:System.IO.Stream" /> as
               input. Some examples of where this might be useful: the zip
               content is concatenated at the end of a regular EXE file, as
               some self-extracting archives do.  (Note: SFX files produced
               by DotNetZip do not work this way; they can be read as normal
               ZIP files). Another example might be a stream being read from
               a database, where the zip content is embedded within an
               aggregate stream of data.
             </para>
            
             </remarks>
            
             <example>
             <para>
               This example shows how to Read zip content from a stream, and
               extract one entry into a different stream. In this example,
               the filename "NameOfEntryInArchive.doc", refers only to the
               name of the entry within the zip archive.  A file by that
               name is not created in the filesystem.  The I/O is done
               strictly with the given streams.
             </para>
            
             <code>
             using (ZipFile zip = ZipFile.Read(InputStream))
             {
                zip.Extract("NameOfEntryInArchive.doc", OutputStream);
             }
             </code>
            
             <code lang="VB">
             Using zip as ZipFile = ZipFile.Read(InputStream)
                zip.Extract("NameOfEntryInArchive.doc", OutputStream)
             End Using
             </code>
             </example>
            
             <param name="zipStream">the stream containing the zip data.</param>
            
             <returns>The ZipFile instance read from the stream</returns>
            
        </member>
        <member name="M:Ionic.Zip.ZipFile.Read(System.IO.Stream,Ionic.Zip.ReadOptions)">
             <summary>
               Reads a zip file archive from the given stream using the
               specified options.
             </summary>
            
             <remarks>
            
             <para>
               When reading from a file, it's probably easier to just use
               <see cref="M:Ionic.Zip.ZipFile.Read(System.String,Ionic.Zip.ReadOptions)">ZipFile.Read(String, ReadOptions)</see>.  This
               overload is useful when when the zip archive content is
               available from an already-open stream. The stream must be
               open and readable and seekable when calling this method.  The
               stream is left open when the reading is completed.
             </para>
            
             <para>
               Reading of zip content begins at the current position in the
               stream.  This means if you have a stream that concatenates
               regular data and zip data, if you position the open, readable
               stream at the start of the zip data, you will be able to read
               the zip archive using this constructor, or any of the ZipFile
               constructors that accept a <see cref="T:System.IO.Stream" /> as
               input. Some examples of where this might be useful: the zip
               content is concatenated at the end of a regular EXE file, as
               some self-extracting archives do.  (Note: SFX files produced
               by DotNetZip do not work this way; they can be read as normal
               ZIP files). Another example might be a stream being read from
               a database, where the zip content is embedded within an
               aggregate stream of data.
             </para>
             </remarks>
            
             <param name="zipStream">the stream containing the zip data.</param>
            
             <param name="options">
               The set of options to use when reading the zip file.
             </param>
            
             <exception cref="T:System.Exception">
               Thrown if the zip archive cannot be read.
             </exception>
            
             <returns>The ZipFile instance read from the stream.</returns>
            
             <seealso cref="M:Ionic.Zip.ZipFile.Read(System.String,Ionic.Zip.ReadOptions)"/>
            
        </member>
        <member name="M:Ionic.Zip.ZipFile.Read(System.IO.Stream,System.IO.TextWriter,System.Text.Encoding,System.EventHandler{Ionic.Zip.ReadProgressEventArgs})">
             <summary>
             Reads a zip archive from a stream, using the specified text Encoding, the
             specified TextWriter for status messages,
             and the specified ReadProgress event handler.
             </summary>
            
             <remarks>
             <para>
             Reading of zip content begins at the current position in the stream.  This
             means if you have a stream that concatenates regular data and zip data, if
             you position the open, readable stream at the start of the zip data, you
             will be able to read the zip archive using this constructor, or any of the
             ZipFile constructors that accept a <see cref="T:System.IO.Stream" /> as
             input. Some examples of where this might be useful: the zip content is
             concatenated at the end of a regular EXE file, as some self-extracting
             archives do.  (Note: SFX files produced by DotNetZip do not work this
             way). Another example might be a stream being read from a database, where
             the zip content is embedded within an aggregate stream of data.
             </para>
             </remarks>
            
             <param name="zipStream">the stream containing the zip data.</param>
            
             <param name="statusMessageWriter">
             The <c>System.IO.TextWriter</c> to which verbose status messages are written
             during operations on the <c>ZipFile</c>.  For example, in a console
             application, System.Console.Out works, and will get a message for each entry
             added to the ZipFile.  If the TextWriter is <c>null</c>, no verbose messages
             are written.
             </param>
            
             <param name="encoding">
             The text encoding to use when reading entries that do not have the UTF-8
             encoding bit set.  Be careful specifying the encoding.  If the value you use
             here is not the same as the Encoding used when the zip archive was created
             (possibly by a different archiver) you will get unexpected results and
             possibly exceptions.  See the <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>
             property for more information.
             </param>
            
             <param name="readProgress">
             An event handler for Read operations.
             </param>
            
             <returns>an instance of ZipFile</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.IsZipFile(System.String)">
             <summary>
             Checks the given file to see if it appears to be a valid zip file.
             </summary>
             <remarks>
            
             <para>
               Calling this method is equivalent to calling <see cref="M:Ionic.Zip.ZipFile.IsZipFile(System.String,System.Boolean)"/> with the testExtract parameter set to false.
             </para>
             </remarks>
            
             <param name="fileName">The file to check.</param>
             <returns>true if the file appears to be a zip file.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.IsZipFile(System.String,System.Boolean)">
             <summary>
             Checks a file to see if it is a valid zip file.
             </summary>
            
             <remarks>
             <para>
               This method opens the specified zip file, reads in the zip archive,
               verifying the ZIP metadata as it reads.
             </para>
            
             <para>
               If everything succeeds, then the method returns true.  If anything fails -
               for example if an incorrect signature or CRC is found, indicating a
               corrupt file, the the method returns false.  This method also returns
               false for a file that does not exist.
             </para>
            
             <para>
               If <paramref name="testExtract"/> is true, as part of its check, this
               method reads in the content for each entry, expands it, and checks CRCs.
               This provides an additional check beyond verifying the zip header and
               directory data.
             </para>
            
             <para>
               If <paramref name="testExtract"/> is true, and if any of the zip entries
               are protected with a password, this method will return false.  If you want
               to verify a <c>ZipFile</c> that has entries which are protected with a
               password, you will need to do that manually.
             </para>
            
             </remarks>
            
             <param name="fileName">The zip file to check.</param>
             <param name="testExtract">true if the caller wants to extract each entry.</param>
             <returns>true if the file contains a valid zip file.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.IsZipFile(System.IO.Stream,System.Boolean)">
             <summary>
             Checks a stream to see if it contains a valid zip archive.
             </summary>
            
             <remarks>
             <para>
             This method reads the zip archive contained in the specified stream, verifying
             the ZIP metadata as it reads.  If testExtract is true, this method also extracts
             each entry in the archive, dumping all the bits into <see cref="F:System.IO.Stream.Null"/>.
             </para>
            
             <para>
             If everything succeeds, then the method returns true.  If anything fails -
             for example if an incorrect signature or CRC is found, indicating a corrupt
             file, the the method returns false.  This method also returns false for a
             file that does not exist.
             </para>
            
             <para>
             If <c>testExtract</c> is true, this method reads in the content for each
             entry, expands it, and checks CRCs.  This provides an additional check
             beyond verifying the zip header data.
             </para>
            
             <para>
             If <c>testExtract</c> is true, and if any of the zip entries are protected
             with a password, this method will return false.  If you want to verify a
             ZipFile that has entries which are protected with a password, you will need
             to do that manually.
             </para>
             </remarks>
            
             <seealso cref="M:Ionic.Zip.ZipFile.IsZipFile(System.String,System.Boolean)"/>
            
             <param name="stream">The stream to check.</param>
             <param name="testExtract">true if the caller wants to extract each entry.</param>
             <returns>true if the stream contains a valid zip archive.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.DeleteFileWithRetry(System.String)">
             <summary>
               Delete file with retry on UnauthorizedAccessException.
             </summary>
            
             <remarks>
               <para>
                 When calling File.Delete() on a file that has been "recently"
                 created, the call sometimes fails with
                 UnauthorizedAccessException. This method simply retries the Delete 3
                 times with a sleep between tries.
               </para>
             </remarks>
            
             <param name='filename'>the name of the file to be deleted</param>
        </member>
        <member name="M:Ionic.Zip.ZipFile.Save">
             <summary>
               Saves the Zip archive to a file, specified by the Name property of the
               <c>ZipFile</c>.
             </summary>
            
             <remarks>
             <para>
               The <c>ZipFile</c> instance is written to storage, typically a zip file
               in a filesystem, only when the caller calls <c>Save</c>.  In the typical
               case, the Save operation writes the zip content to a temporary file, and
               then renames the temporary file to the desired name. If necessary, this
               method will delete a pre-existing file before the rename.
             </para>
            
             <para>
               The <see cref="P:Ionic.Zip.ZipFile.Name"/> property is specified either explicitly,
               or implicitly using one of the parameterized ZipFile constructors.  For
               COM Automation clients, the <c>Name</c> property must be set explicitly,
               because COM Automation clients cannot call parameterized constructors.
             </para>
            
             <para>
               When using a filesystem file for the Zip output, it is possible to call
               <c>Save</c> multiple times on the <c>ZipFile</c> instance. With each
               call the zip content is re-written to the same output file.
             </para>
            
             <para>
               Data for entries that have been added to the <c>ZipFile</c> instance is
               written to the output when the <c>Save</c> method is called. This means
               that the input streams for those entries must be available at the time
               the application calls <c>Save</c>.  If, for example, the application
               adds entries with <c>AddEntry</c> using a dynamically-allocated
               <c>MemoryStream</c>, the memory stream must not have been disposed
               before the call to <c>Save</c>. See the <see
               cref="P:Ionic.Zip.ZipEntry.InputStream"/> property for more discussion of the
               availability requirements of the input stream for an entry, and an
               approach for providing just-in-time stream lifecycle management.
             </para>
            
             </remarks>
            
             <seealso cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,System.IO.Stream)"/>
            
             <exception cref="T:Ionic.Zip.BadStateException">
               Thrown if you haven't specified a location or stream for saving the zip,
               either in the constructor or by setting the Name property, or if you try
               to save a regular zip archive to a filename with a .exe extension.
             </exception>
            
             <exception cref="T:System.OverflowException">
               Thrown if <see cref="P:Ionic.Zip.ZipFile.MaxOutputSegmentSize"/> is non-zero, and the number
               of segments that would be generated for the spanned zip file during the
               save operation exceeds 99.  If this happens, you need to increase the
               segment size.
             </exception>
            
        </member>
        <member name="M:Ionic.Zip.ZipFile.Save(System.String)">
             <summary>
             Save the file to a new zipfile, with the given name.
             </summary>
            
             <remarks>
             <para>
             This method allows the application to explicitly specify the name of the zip
             file when saving. Use this when creating a new zip file, or when
             updating a zip archive.
             </para>
            
             <para>
             An application can also save a zip archive in several places by calling this
             method multiple times in succession, with different filenames.
             </para>
            
             <para>
             The <c>ZipFile</c> instance is written to storage, typically a zip file in a
             filesystem, only when the caller calls <c>Save</c>.  The Save operation writes
             the zip content to a temporary file, and then renames the temporary file
             to the desired name. If necessary, this method will delete a pre-existing file
             before the rename.
             </para>
            
             </remarks>
            
             <exception cref="T:System.ArgumentException">
             Thrown if you specify a directory for the filename.
             </exception>
            
             <param name="fileName">
             The name of the zip archive to save to. Existing files will
             be overwritten with great prejudice.
             </param>
            
             <example>
             This example shows how to create and Save a zip file.
             <code>
             using (ZipFile zip = new ZipFile())
             {
               zip.AddDirectory(@"c:\reports\January");
               zip.Save("January.zip");
             }
             </code>
            
             <code lang="VB">
             Using zip As New ZipFile()
               zip.AddDirectory("c:\reports\January")
               zip.Save("January.zip")
             End Using
             </code>
            
             </example>
            
             <example>
             This example shows how to update a zip file.
             <code>
             using (ZipFile zip = ZipFile.Read("ExistingArchive.zip"))
             {
               zip.AddFile("NewData.csv");
               zip.Save("UpdatedArchive.zip");
             }
             </code>
            
             <code lang="VB">
             Using zip As ZipFile = ZipFile.Read("ExistingArchive.zip")
               zip.AddFile("NewData.csv")
               zip.Save("UpdatedArchive.zip")
             End Using
             </code>
            
             </example>
        </member>
        <member name="M:Ionic.Zip.ZipFile.Save(System.IO.Stream)">
             <summary>
               Save the zip archive to the specified stream.
             </summary>
            
             <remarks>
             <para>
               The <c>ZipFile</c> instance is written to storage - typically a zip file
               in a filesystem, but using this overload, the storage can be anything
               accessible via a writable stream - only when the caller calls <c>Save</c>.
             </para>
            
             <para>
               Use this method to save the zip content to a stream directly.  A common
               scenario is an ASP.NET application that dynamically generates a zip file
               and allows the browser to download it. The application can call
               <c>Save(Response.OutputStream)</c> to write a zipfile directly to the
               output stream, without creating a zip file on the disk on the ASP.NET
               server.
             </para>
            
             <para>
               Be careful when saving a file to a non-seekable stream, including
               <c>Response.OutputStream</c>. When DotNetZip writes to a non-seekable
               stream, the zip archive is formatted in such a way that may not be
               compatible with all zip tools on all platforms.  It's a perfectly legal
               and compliant zip file, but some people have reported problems opening
               files produced this way using the Mac OS archive utility.
             </para>
            
             </remarks>
            
             <example>
            
               This example saves the zipfile content into a MemoryStream, and
               then gets the array of bytes from that MemoryStream.
            
             <code lang="C#">
             using (var zip = new Ionic.Zip.ZipFile())
             {
                 zip.CompressionLevel= Ionic.Zlib.CompressionLevel.BestCompression;
                 zip.Password = "VerySecret.";
                 zip.Encryption = EncryptionAlgorithm.WinZipAes128;
                 zip.AddFile(sourceFileName);
                 MemoryStream output = new MemoryStream();
                 zip.Save(output);
            
                 byte[] zipbytes = output.ToArray();
             }
             </code>
             </example>
            
             <example>
             <para>
               This example shows a pitfall you should avoid. DO NOT read
               from a stream, then try to save to the same stream.  DO
               NOT DO THIS:
             </para>
            
             <code lang="C#">
             using (var fs = new FileSteeam(filename, FileMode.Open))
             {
               using (var zip = Ionic.Zip.ZipFile.Read(inputStream))
               {
                 zip.AddEntry("Name1.txt", "this is the content");
                 zip.Save(inputStream);  // NO NO NO!!
               }
             }
             </code>
            
             <para>
               Better like this:
             </para>
            
             <code lang="C#">
             using (var zip = Ionic.Zip.ZipFile.Read(filename))
             {
                 zip.AddEntry("Name1.txt", "this is the content");
                 zip.Save();  // YES!
             }
             </code>
            
             </example>
            
             <param name="outputStream">
               The <c>System.IO.Stream</c> to write to. It must be
               writable. If you created the ZipFile instanct by calling
               ZipFile.Read(), this stream must not be the same stream
               you passed to ZipFile.Read().
             </param>
        </member>
        <member name="M:Ionic.Zip.ZipFile.AddItem(System.String)">
             <summary>
               Adds an item, either a file or a directory, to a zip file archive.
             </summary>
            
             <remarks>
             <para>
               This method is handy if you are adding things to zip archive and don't
               want to bother distinguishing between directories or files.  Any files are
               added as single entries.  A directory added through this method is added
               recursively: all files and subdirectories contained within the directory
               are added to the <c>ZipFile</c>.
             </para>
            
             <para>
               The name of the item may be a relative path or a fully-qualified
               path. Remember, the items contained in <c>ZipFile</c> instance get written
               to the disk only when you call <see cref="M:Ionic.Zip.ZipFile.Save"/> or a similar
               save method.
             </para>
            
             <para>
               The directory name used for the file within the archive is the same
               as the directory name (potentially a relative path) specified in the
               <paramref name="fileOrDirectoryName"/>.
             </para>
            
             <para>
               For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption"/>, <see
               cref="P:Ionic.Zip.ZipFile.Password"/>, <see cref="P:Ionic.Zip.ZipFile.SetCompression"/>, <see
               cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile"/>,
               <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction"/>, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel"/>, their
               respective values at the time of this call will be applied to the
               <c>ZipEntry</c> added.
             </para>
            
             </remarks>
            
             <seealso cref="M:Ionic.Zip.ZipFile.AddFile(System.String)"/>
             <seealso cref="M:Ionic.Zip.ZipFile.AddDirectory(System.String)"/>
             <seealso cref="M:Ionic.Zip.ZipFile.UpdateItem(System.String)"/>
            
             <overloads>This method has two overloads.</overloads>
             <param name="fileOrDirectoryName">
             the name of the file or directory to add.</param>
            
             <returns>The <c>ZipEntry</c> added.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.AddItem(System.String,System.String)">
             <summary>
               Adds an item, either a file or a directory, to a zip file archive,
               explicitly specifying the directory path to be used in the archive.
             </summary>
            
             <remarks>
             <para>
               If adding a directory, the add is recursive on all files and
               subdirectories contained within it.
             </para>
             <para>
               The name of the item may be a relative path or a fully-qualified path.
               The item added by this call to the <c>ZipFile</c> is not read from the
               disk nor written to the zip file archive until the application calls
               Save() on the <c>ZipFile</c>.
             </para>
            
             <para>
               This version of the method allows the caller to explicitly specify the
               directory path to be used in the archive, which would override the
               "natural" path of the filesystem file.
             </para>
            
             <para>
               Encryption will be used on the file data if the <c>Password</c> has
               been set on the <c>ZipFile</c> object, prior to calling this method.
             </para>
            
             <para>
               For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption"/>, <see
               cref="P:Ionic.Zip.ZipFile.Password"/>, <see cref="P:Ionic.Zip.ZipFile.SetCompression"/>, <see
               cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile"/>,
               <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction"/>, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel"/>, their
               respective values at the time of this call will be applied to the
               <c>ZipEntry</c> added.
             </para>
            
             </remarks>
            
             <exception cref="T:System.IO.FileNotFoundException">
               Thrown if the file or directory passed in does not exist.
             </exception>
            
             <param name="fileOrDirectoryName">the name of the file or directory to add.
             </param>
            
             <param name="directoryPathInArchive">
               The name of the directory path to use within the zip archive.  This path
               need not refer to an extant directory in the current filesystem.  If the
               files within the zip are later extracted, this is the path used for the
               extracted file.  Passing <c>null</c> (<c>Nothing</c> in VB) will use the
               path on the fileOrDirectoryName.  Passing the empty string ("") will
               insert the item at the root path within the archive.
             </param>
            
             <seealso cref="M:Ionic.Zip.ZipFile.AddFile(System.String,System.String)"/>
             <seealso cref="M:Ionic.Zip.ZipFile.AddDirectory(System.String,System.String)"/>
             <seealso cref="M:Ionic.Zip.ZipFile.UpdateItem(System.String,System.String)"/>
            
             <example>
               This example shows how to zip up a set of files into a flat hierarchy,
               regardless of where in the filesystem the files originated. The resulting
               zip archive will contain a toplevel directory named "flat", which itself
               will contain files Readme.txt, MyProposal.docx, and Image1.jpg.  A
               subdirectory under "flat" called SupportFiles will contain all the files
               in the "c:\SupportFiles" directory on disk.
            
             <code>
             String[] itemnames= {
               "c:\\fixedContent\\Readme.txt",
               "MyProposal.docx",
               "c:\\SupportFiles",  // a directory
               "images\\Image1.jpg"
             };
            
             try
             {
               using (ZipFile zip = new ZipFile())
               {
                 for (int i = 1; i &lt; itemnames.Length; i++)
                 {
                   // will add Files or Dirs, recurses and flattens subdirectories
                   zip.AddItem(itemnames[i],"flat");
                 }
                 zip.Save(ZipToCreate);
               }
             }
             catch (System.Exception ex1)
             {
               System.Console.Error.WriteLine("exception: {0}", ex1);
             }
             </code>
            
             <code lang="VB">
               Dim itemnames As String() = _
                 New String() { "c:\fixedContent\Readme.txt", _
                                "MyProposal.docx", _
                                "SupportFiles", _
                                "images\Image1.jpg" }
               Try
                   Using zip As New ZipFile
                       Dim i As Integer
                       For i = 1 To itemnames.Length - 1
                           ' will add Files or Dirs, recursing and flattening subdirectories.
                           zip.AddItem(itemnames(i), "flat")
                       Next i
                       zip.Save(ZipToCreate)
                   End Using
               Catch ex1 As Exception
                   Console.Error.WriteLine("exception: {0}", ex1.ToString())
               End Try
             </code>
             </example>
             <returns>The <c>ZipEntry</c> added.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.AddFile(System.String)">
             <summary>
               Adds a File to a Zip file archive.
             </summary>
             <remarks>
            
             <para>
               This call collects metadata for the named file in the filesystem,
               including the file attributes and the timestamp, and inserts that metadata
               into the resulting ZipEntry.  Only when the application calls Save() on
               the <c>ZipFile</c>, does DotNetZip read the file from the filesystem and
               then write the content to the zip file archive.
             </para>
            
             <para>
               This method will throw an exception if an entry with the same name already
               exists in the <c>ZipFile</c>.
             </para>
            
             <para>
               For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption"/>, <see
               cref="P:Ionic.Zip.ZipFile.Password"/>, <see cref="P:Ionic.Zip.ZipFile.SetCompression"/>, <see
               cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile"/>,
               <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction"/>, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel"/>, their
               respective values at the time of this call will be applied to the
               <c>ZipEntry</c> added.
             </para>
            
             </remarks>
            
             <example>
             <para>
               In this example, three files are added to a Zip archive. The ReadMe.txt
               file will be placed in the root of the archive. The .png file will be
               placed in a folder within the zip called photos\personal.  The pdf file
               will be included into a folder within the zip called Desktop.
             </para>
             <code>
                try
                {
                  using (ZipFile zip = new ZipFile())
                  {
                    zip.AddFile("c:\\photos\\personal\\7440-N49th.png");
                    zip.AddFile("c:\\Desktop\\2008-Regional-Sales-Report.pdf");
                    zip.AddFile("ReadMe.txt");
            
                    zip.Save("Package.zip");
                  }
                }
                catch (System.Exception ex1)
                {
                  System.Console.Error.WriteLine("exception: " + ex1);
                }
             </code>
            
             <code lang="VB">
              Try
                   Using zip As ZipFile = New ZipFile
                       zip.AddFile("c:\photos\personal\7440-N49th.png")
                       zip.AddFile("c:\Desktop\2008-Regional-Sales-Report.pdf")
                       zip.AddFile("ReadMe.txt")
                       zip.Save("Package.zip")
                   End Using
               Catch ex1 As Exception
                   Console.Error.WriteLine("exception: {0}", ex1.ToString)
               End Try
             </code>
             </example>
            
             <overloads>This method has two overloads.</overloads>
            
             <seealso cref="M:Ionic.Zip.ZipFile.AddItem(System.String)"/>
             <seealso cref="M:Ionic.Zip.ZipFile.AddDirectory(System.String)"/>
             <seealso cref="M:Ionic.Zip.ZipFile.UpdateFile(System.String)"/>
            
             <param name="fileName">
               The name of the file to add. It should refer to a file in the filesystem.
               The name of the file may be a relative path or a fully-qualified path.
             </param>
             <returns>The <c>ZipEntry</c> corresponding to the File added.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.AddFile(System.String,System.String)">
             <summary>
               Adds a File to a Zip file archive, potentially overriding the path to be
               used within the zip archive.
             </summary>
            
             <remarks>
             <para>
               The file added by this call to the <c>ZipFile</c> is not written to the
               zip file archive until the application calls Save() on the <c>ZipFile</c>.
             </para>
            
             <para>
               This method will throw an exception if an entry with the same name already
               exists in the <c>ZipFile</c>.
             </para>
            
             <para>
               This version of the method allows the caller to explicitly specify the
               directory path to be used in the archive.
             </para>
            
             <para>
               For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption"/>, <see
               cref="P:Ionic.Zip.ZipFile.Password"/>, <see cref="P:Ionic.Zip.ZipFile.SetCompression"/>, <see
               cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile"/>,
               <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction"/>, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel"/>, their
               respective values at the time of this call will be applied to the
               <c>ZipEntry</c> added.
             </para>
            
             </remarks>
            
             <example>
             <para>
               In this example, three files are added to a Zip archive. The ReadMe.txt
               file will be placed in the root of the archive. The .png file will be
               placed in a folder within the zip called images.  The pdf file will be
               included into a folder within the zip called files\docs, and will be
               encrypted with the given password.
             </para>
             <code>
             try
             {
               using (ZipFile zip = new ZipFile())
               {
                 // the following entry will be inserted at the root in the archive.
                 zip.AddFile("c:\\datafiles\\ReadMe.txt", "");
                 // this image file will be inserted into the "images" directory in the archive.
                 zip.AddFile("c:\\photos\\personal\\7440-N49th.png", "images");
                 // the following will result in a password-protected file called
                 // files\\docs\\2008-Regional-Sales-Report.pdf  in the archive.
                 zip.Password = "EncryptMe!";
                 zip.AddFile("c:\\Desktop\\2008-Regional-Sales-Report.pdf", "files\\docs");
                 zip.Save("Archive.zip");
               }
             }
             catch (System.Exception ex1)
             {
               System.Console.Error.WriteLine("exception: {0}", ex1);
             }
             </code>
            
             <code lang="VB">
               Try
                   Using zip As ZipFile = New ZipFile
                       ' the following entry will be inserted at the root in the archive.
                       zip.AddFile("c:\datafiles\ReadMe.txt", "")
                       ' this image file will be inserted into the "images" directory in the archive.
                       zip.AddFile("c:\photos\personal\7440-N49th.png", "images")
                       ' the following will result in a password-protected file called
                       ' files\\docs\\2008-Regional-Sales-Report.pdf  in the archive.
                       zip.Password = "EncryptMe!"
                       zip.AddFile("c:\Desktop\2008-Regional-Sales-Report.pdf", "files\documents")
                       zip.Save("Archive.zip")
                   End Using
               Catch ex1 As Exception
                   Console.Error.WriteLine("exception: {0}", ex1)
               End Try
             </code>
             </example>
            
             <seealso cref="M:Ionic.Zip.ZipFile.AddItem(System.String,System.String)"/>
             <seealso cref="M:Ionic.Zip.ZipFile.AddDirectory(System.String,System.String)"/>
             <seealso cref="M:Ionic.Zip.ZipFile.UpdateFile(System.String,System.String)"/>
            
             <param name="fileName">
               The name of the file to add.  The name of the file may be a relative path
               or a fully-qualified path.
             </param>
            
             <param name="directoryPathInArchive">
               Specifies a directory path to use to override any path in the fileName.
               This path may, or may not, correspond to a real directory in the current
               filesystem.  If the files within the zip are later extracted, this is the
               path used for the extracted file.  Passing <c>null</c> (<c>Nothing</c> in
               VB) will use the path on the fileName, if any.  Passing the empty string
               ("") will insert the item at the root path within the archive.
             </param>
            
             <returns>The <c>ZipEntry</c> corresponding to the file added.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.RemoveEntries(System.Collections.Generic.ICollection{Ionic.Zip.ZipEntry})">
             <summary>
               This method removes a collection of entries from the <c>ZipFile</c>.
             </summary>
            
             <param name="entriesToRemove">
               A collection of ZipEntry instances from this zip file to be removed. For
               example, you can pass in an array of ZipEntry instances; or you can call
               SelectEntries(), and then add or remove entries from that
               ICollection&lt;ZipEntry&gt; (ICollection(Of ZipEntry) in VB), and pass
               that ICollection to this method.
             </param>
            
             <seealso cref="!:Ionic.Zip.ZipFile.SelectEntries(String)" />
             <seealso cref="!:Ionic.Zip.ZipFile.RemoveSelectedEntries(String)" />
        </member>
        <member name="M:Ionic.Zip.ZipFile.RemoveEntries(System.Collections.Generic.ICollection{System.String})">
             <summary>
               This method removes a collection of entries from the <c>ZipFile</c>, by name.
             </summary>
            
             <param name="entriesToRemove">
               A collection of strings that refer to names of entries to be removed
               from the <c>ZipFile</c>.  For example, you can pass in an array or a
               List of Strings that provide the names of entries to be removed.
             </param>
            
             <seealso cref="!:Ionic.Zip.ZipFile.SelectEntries(String)" />
             <seealso cref="!:Ionic.Zip.ZipFile.RemoveSelectedEntries(String)" />
        </member>
        <member name="M:Ionic.Zip.ZipFile.AddFiles(System.Collections.Generic.IEnumerable{System.String})">
             <summary>
               This method adds a set of files to the <c>ZipFile</c>.
             </summary>
            
             <remarks>
             <para>
               Use this method to add a set of files to the zip archive, in one call.
               For example, a list of files received from
               <c>System.IO.Directory.GetFiles()</c> can be added to a zip archive in one
               call.
             </para>
            
             <para>
               For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption"/>, <see
               cref="P:Ionic.Zip.ZipFile.Password"/>, <see cref="P:Ionic.Zip.ZipFile.SetCompression"/>, <see
               cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile"/>,
               <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction"/>, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel"/>, their
               respective values at the time of this call will be applied to each
               ZipEntry added.
             </para>
             </remarks>
            
             <param name="fileNames">
               The collection of names of the files to add. Each string should refer to a
               file in the filesystem. The name of the file may be a relative path or a
               fully-qualified path.
             </param>
            
             <example>
               This example shows how to create a zip file, and add a few files into it.
             <code>
             String ZipFileToCreate = "archive1.zip";
             String DirectoryToZip = "c:\\reports";
             using (ZipFile zip = new ZipFile())
             {
               // Store all files found in the top level directory, into the zip archive.
               String[] filenames = System.IO.Directory.GetFiles(DirectoryToZip);
               zip.AddFiles(filenames);
               zip.Save(ZipFileToCreate);
             }
             </code>
            
             <code lang="VB">
             Dim ZipFileToCreate As String = "archive1.zip"
             Dim DirectoryToZip As String = "c:\reports"
             Using zip As ZipFile = New ZipFile
                 ' Store all files found in the top level directory, into the zip archive.
                 Dim filenames As String() = System.IO.Directory.GetFiles(DirectoryToZip)
                 zip.AddFiles(filenames)
                 zip.Save(ZipFileToCreate)
             End Using
             </code>
             </example>
            
             <seealso cref="!:Ionic.Zip.ZipFile.AddSelectedFiles(String, String)" />
        </member>
        <member name="M:Ionic.Zip.ZipFile.UpdateFiles(System.Collections.Generic.IEnumerable{System.String})">
             <summary>
               Adds or updates a set of files in the <c>ZipFile</c>.
             </summary>
            
             <remarks>
             <para>
               Any files that already exist in the archive are updated. Any files that
               don't yet exist in the archive are added.
             </para>
            
             <para>
               For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption"/>, <see
               cref="P:Ionic.Zip.ZipFile.Password"/>, <see cref="P:Ionic.Zip.ZipFile.SetCompression"/>, <see
               cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile"/>,
               <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction"/>, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel"/>, their
               respective values at the time of this call will be applied to each
               ZipEntry added.
             </para>
             </remarks>
            
             <param name="fileNames">
               The collection of names of the files to update. Each string should refer to a file in
               the filesystem. The name of the file may be a relative path or a fully-qualified path.
             </param>
            
        </member>
        <member name="M:Ionic.Zip.ZipFile.AddFiles(System.Collections.Generic.IEnumerable{System.String},System.String)">
             <summary>
               Adds a set of files to the <c>ZipFile</c>, using the
               specified directory path in the archive.
             </summary>
            
             <remarks>
             <para>
               Any directory structure that may be present in the
               filenames contained in the list is "flattened" in the
               archive.  Each file in the list is added to the archive in
               the specified top-level directory.
             </para>
            
             <para>
               For <c>ZipFile</c> properties including <see
               cref="P:Ionic.Zip.ZipFile.Encryption"/>, <see cref="P:Ionic.Zip.ZipFile.Password"/>, <see
               cref="P:Ionic.Zip.ZipFile.SetCompression"/>, <see
               cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>, <see
               cref="P:Ionic.Zip.ZipFile.ExtractExistingFile"/>, <see
               cref="P:Ionic.Zip.ZipFile.ZipErrorAction"/>, and <see
               cref="P:Ionic.Zip.ZipFile.CompressionLevel"/>, their respective values at the
               time of this call will be applied to each ZipEntry added.
             </para>
             </remarks>
            
             <param name="fileNames">
               The names of the files to add. Each string should refer to
               a file in the filesystem.  The name of the file may be a
               relative path or a fully-qualified path.
             </param>
            
             <param name="directoryPathInArchive">
               Specifies a directory path to use to override any path in the file name.
               Th is path may, or may not, correspond to a real directory in the current
               filesystem.  If the files within the zip are later extracted, this is the
               path used for the extracted file.  Passing <c>null</c> (<c>Nothing</c> in
               VB) will use the path on each of the <c>fileNames</c>, if any.  Passing
               the empty string ("") will insert the item at the root path within the
               archive.
             </param>
            
             <seealso cref="!:Ionic.Zip.ZipFile.AddSelectedFiles(String, String)" />
        </member>
        <member name="M:Ionic.Zip.ZipFile.AddFiles(System.Collections.Generic.IEnumerable{System.String},System.Boolean,System.String)">
             <summary>
               Adds a set of files to the <c>ZipFile</c>, using the specified directory
               path in the archive, and preserving the full directory structure in the
               filenames.
             </summary>
            
             <remarks>
            
             <para>
               Think of the <paramref name="directoryPathInArchive"/> as a "root" or
               base directory used in the archive for the files that get added.  when
               <paramref name="preserveDirHierarchy"/> is true, the hierarchy of files
               found in the filesystem will be placed, with the hierarchy intact,
               starting at that root in the archive. When <c>preserveDirHierarchy</c>
               is false, the path hierarchy of files is flattned, and the flattened
               set of files gets placed in the root within the archive as specified in
               <c>directoryPathInArchive</c>.
             </para>
            
             <para>
               For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption"/>, <see
               cref="P:Ionic.Zip.ZipFile.Password"/>, <see cref="P:Ionic.Zip.ZipFile.SetCompression"/>, <see
               cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile"/>,
               <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction"/>, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel"/>, their
               respective values at the time of this call will be applied to each
               ZipEntry added.
             </para>
            
             </remarks>
            
             <param name="fileNames">
               The names of the files to add. Each string should refer to a file in the
               filesystem.  The name of the file may be a relative path or a
               fully-qualified path.
             </param>
            
             <param name="directoryPathInArchive">
               Specifies a directory path to use as a prefix for each entry name.
               This path may, or may not, correspond to a real directory in the current
               filesystem.  If the files within the zip are later extracted, this is the
               path used for the extracted file.  Passing <c>null</c> (<c>Nothing</c> in
               VB) will use the path on each of the <c>fileNames</c>, if any.  Passing
               the empty string ("") will insert the item at the root path within the
               archive.
             </param>
            
             <param name="preserveDirHierarchy">
               whether the entries in the zip archive will reflect the directory
               hierarchy that is present in the various filenames.  For example, if
               <paramref name="fileNames"/> includes two paths,
               \Animalia\Chordata\Mammalia\Info.txt and
               \Plantae\Magnoliophyta\Dicotyledon\Info.txt, then calling this method
               with <paramref name="preserveDirHierarchy"/> = <c>false</c> will
               result in an exception because of a duplicate entry name, while
               calling this method with <paramref name="preserveDirHierarchy"/> =
               <c>true</c> will result in the full direcory paths being included in
               the entries added to the ZipFile.
             </param>
             <seealso cref="!:Ionic.Zip.ZipFile.AddSelectedFiles(String, String)" />
        </member>
        <member name="M:Ionic.Zip.ZipFile.UpdateFiles(System.Collections.Generic.IEnumerable{System.String},System.String)">
             <summary>
               Adds or updates a set of files to the <c>ZipFile</c>, using the specified
               directory path in the archive.
             </summary>
            
             <remarks>
            
             <para>
               Any files that already exist in the archive are updated. Any files that
               don't yet exist in the archive are added.
             </para>
            
             <para>
               For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption"/>, <see
               cref="P:Ionic.Zip.ZipFile.Password"/>, <see cref="P:Ionic.Zip.ZipFile.SetCompression"/>, <see
               cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile"/>,
               <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction"/>, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel"/>, their
               respective values at the time of this call will be applied to each
               ZipEntry added.
             </para>
             </remarks>
            
             <param name="fileNames">
               The names of the files to add or update. Each string should refer to a
               file in the filesystem.  The name of the file may be a relative path or a
               fully-qualified path.
             </param>
            
             <param name="directoryPathInArchive">
               Specifies a directory path to use to override any path in the file name.
               This path may, or may not, correspond to a real directory in the current
               filesystem.  If the files within the zip are later extracted, this is the
               path used for the extracted file.  Passing <c>null</c> (<c>Nothing</c> in
               VB) will use the path on each of the <c>fileNames</c>, if any.  Passing
               the empty string ("") will insert the item at the root path within the
               archive.
             </param>
            
             <seealso cref="!:Ionic.Zip.ZipFile.AddSelectedFiles(String, String)" />
        </member>
        <member name="M:Ionic.Zip.ZipFile.UpdateFile(System.String)">
             <summary>
               Adds or Updates a File in a Zip file archive.
             </summary>
            
             <remarks>
             <para>
               This method adds a file to a zip archive, or, if the file already exists
               in the zip archive, this method Updates the content of that given filename
               in the zip archive.  The <c>UpdateFile</c> method might more accurately be
               called "AddOrUpdateFile".
             </para>
            
             <para>
               Upon success, there is no way for the application to learn whether the file
               was added versus updated.
             </para>
            
             <para>
               For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption"/>, <see
               cref="P:Ionic.Zip.ZipFile.Password"/>, <see cref="P:Ionic.Zip.ZipFile.SetCompression"/>, <see
               cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile"/>,
               <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction"/>, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel"/>, their
               respective values at the time of this call will be applied to the
               <c>ZipEntry</c> added.
             </para>
             </remarks>
            
             <example>
            
               This example shows how to Update an existing entry in a zipfile. The first
               call to UpdateFile adds the file to the newly-created zip archive.  The
               second call to UpdateFile updates the content for that file in the zip
               archive.
            
             <code>
             using (ZipFile zip1 = new ZipFile())
             {
               // UpdateFile might more accurately be called "AddOrUpdateFile"
               zip1.UpdateFile("MyDocuments\\Readme.txt");
               zip1.UpdateFile("CustomerList.csv");
               zip1.Comment = "This zip archive has been created.";
               zip1.Save("Content.zip");
             }
            
             using (ZipFile zip2 = ZipFile.Read("Content.zip"))
             {
               zip2.UpdateFile("Updates\\Readme.txt");
               zip2.Comment = "This zip archive has been updated: The Readme.txt file has been changed.";
               zip2.Save();
             }
            
             </code>
             <code lang="VB">
               Using zip1 As New ZipFile
                   ' UpdateFile might more accurately be called "AddOrUpdateFile"
                   zip1.UpdateFile("MyDocuments\Readme.txt")
                   zip1.UpdateFile("CustomerList.csv")
                   zip1.Comment = "This zip archive has been created."
                   zip1.Save("Content.zip")
               End Using
            
               Using zip2 As ZipFile = ZipFile.Read("Content.zip")
                   zip2.UpdateFile("Updates\Readme.txt")
                   zip2.Comment = "This zip archive has been updated: The Readme.txt file has been changed."
                   zip2.Save
               End Using
             </code>
             </example>
            
             <seealso cref="M:Ionic.Zip.ZipFile.AddFile(System.String)"/>
             <seealso cref="M:Ionic.Zip.ZipFile.UpdateDirectory(System.String)"/>
             <seealso cref="M:Ionic.Zip.ZipFile.UpdateItem(System.String)"/>
            
             <param name="fileName">
               The name of the file to add or update. It should refer to a file in the
               filesystem.  The name of the file may be a relative path or a
               fully-qualified path.
             </param>
            
             <returns>
               The <c>ZipEntry</c> corresponding to the File that was added or updated.
             </returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.UpdateFile(System.String,System.String)">
             <summary>
               Adds or Updates a File in a Zip file archive.
             </summary>
            
             <remarks>
             <para>
               This method adds a file to a zip archive, or, if the file already exists
               in the zip archive, this method Updates the content of that given filename
               in the zip archive.
             </para>
            
             <para>
               This version of the method allows the caller to explicitly specify the
               directory path to be used in the archive.  The entry to be added or
               updated is found by using the specified directory path, combined with the
               basename of the specified filename.
             </para>
            
             <para>
               Upon success, there is no way for the application to learn if the file was
               added versus updated.
             </para>
            
             <para>
               For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption"/>, <see
               cref="P:Ionic.Zip.ZipFile.Password"/>, <see cref="P:Ionic.Zip.ZipFile.SetCompression"/>, <see
               cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile"/>,
               <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction"/>, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel"/>, their
               respective values at the time of this call will be applied to the
               <c>ZipEntry</c> added.
             </para>
             </remarks>
            
             <seealso cref="M:Ionic.Zip.ZipFile.AddFile(System.String,System.String)"/>
             <seealso cref="M:Ionic.Zip.ZipFile.UpdateDirectory(System.String,System.String)"/>
             <seealso cref="M:Ionic.Zip.ZipFile.UpdateItem(System.String,System.String)"/>
            
             <param name="fileName">
               The name of the file to add or update. It should refer to a file in the
               filesystem.  The name of the file may be a relative path or a
               fully-qualified path.
             </param>
            
             <param name="directoryPathInArchive">
               Specifies a directory path to use to override any path in the
               <c>fileName</c>.  This path may, or may not, correspond to a real
               directory in the current filesystem.  If the files within the zip are
               later extracted, this is the path used for the extracted file.  Passing
               <c>null</c> (<c>Nothing</c> in VB) will use the path on the
               <c>fileName</c>, if any.  Passing the empty string ("") will insert the
               item at the root path within the archive.
             </param>
            
             <returns>
               The <c>ZipEntry</c> corresponding to the File that was added or updated.
             </returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.UpdateDirectory(System.String)">
             <summary>
               Add or update a directory in a zip archive.
             </summary>
            
             <remarks>
               If the specified directory does not exist in the archive, then this method
               is equivalent to calling <c>AddDirectory()</c>.  If the specified
               directory already exists in the archive, then this method updates any
               existing entries, and adds any new entries. Any entries that are in the
               zip archive but not in the specified directory, are left alone.  In other
               words, the contents of the zip file will be a union of the previous
               contents and the new files.
             </remarks>
            
             <seealso cref="M:Ionic.Zip.ZipFile.UpdateFile(System.String)"/>
             <seealso cref="M:Ionic.Zip.ZipFile.AddDirectory(System.String)"/>
             <seealso cref="M:Ionic.Zip.ZipFile.UpdateItem(System.String)"/>
            
             <param name="directoryName">
               The path to the directory to be added to the zip archive, or updated in
               the zip archive.
             </param>
            
             <returns>
             The <c>ZipEntry</c> corresponding to the Directory that was added or updated.
             </returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.UpdateDirectory(System.String,System.String)">
             <summary>
               Add or update a directory in the zip archive at the specified root
               directory in the archive.
             </summary>
            
             <remarks>
               If the specified directory does not exist in the archive, then this method
               is equivalent to calling <c>AddDirectory()</c>.  If the specified
               directory already exists in the archive, then this method updates any
               existing entries, and adds any new entries. Any entries that are in the
               zip archive but not in the specified directory, are left alone.  In other
               words, the contents of the zip file will be a union of the previous
               contents and the new files.
             </remarks>
            
             <seealso cref="M:Ionic.Zip.ZipFile.UpdateFile(System.String,System.String)"/>
             <seealso cref="M:Ionic.Zip.ZipFile.AddDirectory(System.String,System.String)"/>
             <seealso cref="M:Ionic.Zip.ZipFile.UpdateItem(System.String,System.String)"/>
            
             <param name="directoryName">
               The path to the directory to be added to the zip archive, or updated
               in the zip archive.
             </param>
            
             <param name="directoryPathInArchive">
               Specifies a directory path to use to override any path in the
               <c>directoryName</c>.  This path may, or may not, correspond to a real
               directory in the current filesystem.  If the files within the zip are
               later extracted, this is the path used for the extracted file.  Passing
               <c>null</c> (<c>Nothing</c> in VB) will use the path on the
               <c>directoryName</c>, if any.  Passing the empty string ("") will insert
               the item at the root path within the archive.
             </param>
            
             <returns>
               The <c>ZipEntry</c> corresponding to the Directory that was added or updated.
             </returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.UpdateItem(System.String)">
             <summary>
               Add or update a file or directory in the zip archive.
             </summary>
            
             <remarks>
             <para>
               This is useful when the application is not sure or does not care if the
               item to be added is a file or directory, and does not know or does not
               care if the item already exists in the <c>ZipFile</c>. Calling this method
               is equivalent to calling <c>RemoveEntry()</c> if an entry by the same name
               already exists, followed calling by <c>AddItem()</c>.
             </para>
            
             <para>
               For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption"/>, <see
               cref="P:Ionic.Zip.ZipFile.Password"/>, <see cref="P:Ionic.Zip.ZipFile.SetCompression"/>, <see
               cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile"/>,
               <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction"/>, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel"/>, their
               respective values at the time of this call will be applied to the
               <c>ZipEntry</c> added.
             </para>
             </remarks>
            
             <seealso cref="M:Ionic.Zip.ZipFile.AddItem(System.String)"/>
             <seealso cref="M:Ionic.Zip.ZipFile.UpdateFile(System.String)"/>
             <seealso cref="M:Ionic.Zip.ZipFile.UpdateDirectory(System.String)"/>
            
             <param name="itemName">
              the path to the file or directory to be added or updated.
             </param>
        </member>
        <member name="M:Ionic.Zip.ZipFile.UpdateItem(System.String,System.String)">
             <summary>
               Add or update a file or directory.
             </summary>
            
             <remarks>
             <para>
               This method is useful when the application is not sure or does not care if
               the item to be added is a file or directory, and does not know or does not
               care if the item already exists in the <c>ZipFile</c>. Calling this method
               is equivalent to calling <c>RemoveEntry()</c>, if an entry by that name
               exists, and then calling <c>AddItem()</c>.
             </para>
            
             <para>
               This version of the method allows the caller to explicitly specify the
               directory path to be used for the item being added to the archive.  The
               entry or entries that are added or updated will use the specified
               <c>DirectoryPathInArchive</c>. Extracting the entry from the archive will
               result in a file stored in that directory path.
             </para>
            
             <para>
               For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption"/>, <see
               cref="P:Ionic.Zip.ZipFile.Password"/>, <see cref="P:Ionic.Zip.ZipFile.SetCompression"/>, <see
               cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile"/>,
               <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction"/>, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel"/>, their
               respective values at the time of this call will be applied to the
               <c>ZipEntry</c> added.
             </para>
             </remarks>
            
             <seealso cref="M:Ionic.Zip.ZipFile.AddItem(System.String,System.String)"/>
             <seealso cref="M:Ionic.Zip.ZipFile.UpdateFile(System.String,System.String)"/>
             <seealso cref="M:Ionic.Zip.ZipFile.UpdateDirectory(System.String,System.String)"/>
            
             <param name="itemName">
               The path for the File or Directory to be added or updated.
             </param>
             <param name="directoryPathInArchive">
               Specifies a directory path to use to override any path in the
               <c>itemName</c>.  This path may, or may not, correspond to a real
               directory in the current filesystem.  If the files within the zip are
               later extracted, this is the path used for the extracted file.  Passing
               <c>null</c> (<c>Nothing</c> in VB) will use the path on the
               <c>itemName</c>, if any.  Passing the empty string ("") will insert the
               item at the root path within the archive.
             </param>
        </member>
        <member name="M:Ionic.Zip.ZipFile.AddEntry(System.String,System.String)">
             <summary>
               Adds a named entry into the zip archive, taking content for the entry
               from a string.
             </summary>
            
             <remarks>
               Calling this method creates an entry using the given fileName and
               directory path within the archive.  There is no need for a file by the
               given name to exist in the filesystem; the name is used within the zip
               archive only. The content for the entry is encoded using the default text
               encoding for the machine, or on Silverlight, using UTF-8.
             </remarks>
            
             <param name="content">
               The content of the file, should it be extracted from the zip.
             </param>
            
             <param name="entryName">
               The name, including any path, to use for the entry within the archive.
             </param>
            
             <returns>The <c>ZipEntry</c> added.</returns>
            
             <example>
            
             This example shows how to add an entry to the zipfile, using a string as
             content for that entry.
            
             <code lang="C#">
             string Content = "This string will be the content of the Readme.txt file in the zip archive.";
             using (ZipFile zip1 = new ZipFile())
             {
               zip1.AddFile("MyDocuments\\Resume.doc", "files");
               zip1.AddEntry("Readme.txt", Content);
               zip1.Comment = "This zip file was created at " + System.DateTime.Now.ToString("G");
               zip1.Save("Content.zip");
             }
            
             </code>
             <code lang="VB">
             Public Sub Run()
               Dim Content As String = "This string will be the content of the Readme.txt file in the zip archive."
               Using zip1 As ZipFile = New ZipFile
                 zip1.AddEntry("Readme.txt", Content)
                 zip1.AddFile("MyDocuments\Resume.doc", "files")
                 zip1.Comment = ("This zip file was created at " &amp; DateTime.Now.ToString("G"))
                 zip1.Save("Content.zip")
               End Using
             End Sub
             </code>
             </example>
        </member>
        <member name="M:Ionic.Zip.ZipFile.AddEntry(System.String,System.String,System.Text.Encoding)">
             <summary>
               Adds a named entry into the zip archive, taking content for the entry
               from a string, and using the specified text encoding.
             </summary>
            
             <remarks>
            
             <para>
               Calling this method creates an entry using the given fileName and
               directory path within the archive.  There is no need for a file by the
               given name to exist in the filesystem; the name is used within the zip
               archive only.
             </para>
            
             <para>
               The content for the entry, a string value, is encoded using the given
               text encoding. A BOM (byte-order-mark) is emitted into the file, if the
               Encoding parameter is set for that.
             </para>
            
             <para>
               Most Encoding classes support a constructor that accepts a boolean,
               indicating whether to emit a BOM or not. For example see <see
               cref="M:System.Text.UTF8Encoding.#ctor(System.Boolean)"/>.
             </para>
            
             </remarks>
            
             <param name="entryName">
               The name, including any path, to use within the archive for the entry.
             </param>
            
             <param name="content">
               The content of the file, should it be extracted from the zip.
             </param>
            
             <param name="encoding">
               The text encoding to use when encoding the string. Be aware: This is
               distinct from the text encoding used to encode the fileName, as specified
               in <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" />.
             </param>
            
             <returns>The <c>ZipEntry</c> added.</returns>
            
        </member>
        <member name="M:Ionic.Zip.ZipFile.AddEntry(System.String,System.IO.Stream)">
             <summary>
               Create an entry in the <c>ZipFile</c> using the given <c>Stream</c>
               as input.  The entry will have the given filename.
             </summary>
            
             <remarks>
            
             <para>
               The application should provide an open, readable stream; in this case it
               will be read during the call to <see cref="M:Ionic.Zip.ZipFile.Save"/> or one of
               its overloads.
             </para>
            
             <para>
               The passed stream will be read from its current position. If
               necessary, callers should set the position in the stream before
               calling AddEntry(). This might be appropriate when using this method
               with a MemoryStream, for example.
             </para>
            
             <para>
               In cases where a large number of streams will be added to the
               <c>ZipFile</c>, the application may wish to avoid maintaining all of the
               streams open simultaneously.  To handle this situation, the application
               should use the <see cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,Ionic.Zip.OpenDelegate,Ionic.Zip.CloseDelegate)"/>
               overload.
             </para>
            
             <para>
               For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption"/>, <see
               cref="P:Ionic.Zip.ZipFile.Password"/>, <see cref="P:Ionic.Zip.ZipFile.SetCompression"/>, <see
               cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile"/>,
               <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction"/>, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel"/>, their
               respective values at the time of this call will be applied to the
               <c>ZipEntry</c> added.
             </para>
            
             </remarks>
            
             <example>
             <para>
               This example adds a single entry to a <c>ZipFile</c> via a <c>Stream</c>.
             </para>
            
             <code lang="C#">
             String zipToCreate = "Content.zip";
             String fileNameInArchive = "Content-From-Stream.bin";
             using (System.IO.Stream streamToRead = MyStreamOpener())
             {
               using (ZipFile zip = new ZipFile())
               {
                 ZipEntry entry= zip.AddEntry(fileNameInArchive, streamToRead);
                 zip.AddFile("Readme.txt");
                 zip.Save(zipToCreate);  // the stream is read implicitly here
               }
             }
             </code>
            
             <code lang="VB">
             Dim zipToCreate As String = "Content.zip"
             Dim fileNameInArchive As String = "Content-From-Stream.bin"
             Using streamToRead as System.IO.Stream = MyStreamOpener()
               Using zip As ZipFile = New ZipFile()
                 Dim entry as ZipEntry = zip.AddEntry(fileNameInArchive, streamToRead)
                 zip.AddFile("Readme.txt")
                 zip.Save(zipToCreate)  '' the stream is read implicitly, here
               End Using
             End Using
             </code>
             </example>
            
             <seealso cref="M:Ionic.Zip.ZipFile.UpdateEntry(System.String,System.IO.Stream)"/>
            
             <param name="entryName">
               The name, including any path, which is shown in the zip file for the added
               entry.
             </param>
             <param name="stream">
               The input stream from which to grab content for the file
             </param>
             <returns>The <c>ZipEntry</c> added.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.AddEntry(System.String,Ionic.Zip.WriteDelegate)">
             <summary>
               Add a ZipEntry for which content is written directly by the application.
             </summary>
            
             <remarks>
             <para>
               When the application needs to write the zip entry data, use this
               method to add the ZipEntry. For example, in the case that the
               application wishes to write the XML representation of a DataSet into
               a ZipEntry, the application can use this method to do so.
             </para>
            
             <para>
               For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption"/>, <see
               cref="P:Ionic.Zip.ZipFile.Password"/>, <see cref="P:Ionic.Zip.ZipFile.SetCompression"/>, <see
               cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile"/>,
               <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction"/>, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel"/>, their
               respective values at the time of this call will be applied to the
               <c>ZipEntry</c> added.
             </para>
            
             <para>
               About progress events: When using the WriteDelegate, DotNetZip does
               not issue any SaveProgress events with <c>EventType</c> = <see
               cref="F:Ionic.Zip.ZipProgressEventType.Saving_EntryBytesRead">
               Saving_EntryBytesRead</see>. (This is because it is the
               application's code that runs in WriteDelegate - there's no way for
               DotNetZip to know when to issue a EntryBytesRead event.)
               Applications that want to update a progress bar or similar status
               indicator should do so from within the WriteDelegate
               itself. DotNetZip will issue the other SaveProgress events,
               including <see cref="F:Ionic.Zip.ZipProgressEventType.Saving_Started">
               Saving_Started</see>,
               <see cref="F:Ionic.Zip.ZipProgressEventType.Saving_BeforeWriteEntry">
               Saving_BeforeWriteEntry</see>, and <see
               cref="F:Ionic.Zip.ZipProgressEventType.Saving_AfterWriteEntry">
               Saving_AfterWriteEntry</see>.
             </para>
            
             <para>
               Note: When you use PKZip encryption, it's normally necessary to
               compute the CRC of the content to be encrypted, before compressing or
               encrypting it. Therefore, when using PKZip encryption with a
               WriteDelegate, the WriteDelegate CAN BE called twice: once to compute
               the CRC, and the second time to potentially compress and
               encrypt. Surprising, but true. This is because PKWARE specified that
               the encryption initialization data depends on the CRC.
               If this happens, for each call of the delegate, your
               application must stream the same entry data in its entirety. If your
               application writes different data during the second call, it will
               result in a corrupt zip file.
             </para>
            
             <para>
               The double-read behavior happens with all types of entries, not only
               those that use WriteDelegate. It happens if you add an entry from a
               filesystem file, or using a string, or a stream, or an opener/closer
               pair. But in those cases, DotNetZip takes care of reading twice; in
               the case of the WriteDelegate, the application code gets invoked
               twice. Be aware.
             </para>
            
             <para>
               As you can imagine, this can cause performance problems for large
               streams, and it can lead to correctness problems when you use a
               <c>WriteDelegate</c>. This is a pretty big pitfall.  There are two
               ways to avoid it.  First, and most preferred: don't use PKZIP
               encryption.  If you use the WinZip AES encryption, this problem
               doesn't occur, because the encryption protocol doesn't require the CRC
               up front. Second: if you do choose to use PKZIP encryption, write out
               to a non-seekable stream (like standard output, or the
               Response.OutputStream in an ASP.NET application).  In this case,
               DotNetZip will use an alternative encryption protocol that does not
               rely on the CRC of the content.  This also implies setting bit 3 in
               the zip entry, which still presents problems for some zip tools.
             </para>
            
             <para>
               In the future I may modify DotNetZip to *always* use bit 3 when PKZIP
               encryption is in use.  This seems like a win overall, but there will
               be some work involved.  If you feel strongly about it, visit the
               DotNetZip forums and vote up <see
               href="http://dotnetzip.codeplex.com/workitem/13686">the Workitem
               tracking this issue</see>.
             </para>
            
             </remarks>
            
             <param name="entryName">the name of the entry to add</param>
             <param name="writer">the delegate which will write the entry content</param>
             <returns>the ZipEntry added</returns>
            
             <example>
            
               This example shows an application filling a DataSet, then saving the
               contents of that DataSet as XML, into a ZipEntry in a ZipFile, using an
               anonymous delegate in C#. The DataSet XML is never saved to a disk file.
            
             <code lang="C#">
             var c1= new System.Data.SqlClient.SqlConnection(connstring1);
             var da = new System.Data.SqlClient.SqlDataAdapter()
                 {
                     SelectCommand=  new System.Data.SqlClient.SqlCommand(strSelect, c1)
                 };
            
             DataSet ds1 = new DataSet();
             da.Fill(ds1, "Invoices");
            
             using(Ionic.Zip.ZipFile zip = new Ionic.Zip.ZipFile())
             {
                 zip.AddEntry(zipEntryName, (name,stream) => ds1.WriteXml(stream) );
                 zip.Save(zipFileName);
             }
             </code>
             </example>
            
             <example>
            
             This example uses an anonymous method in C# as the WriteDelegate to provide
             the data for the ZipEntry. The example is a bit contrived - the
             <c>AddFile()</c> method is a simpler way to insert the contents of a file
             into an entry in a zip file. On the other hand, if there is some sort of
             processing or transformation of the file contents required before writing,
             the application could use the <c>WriteDelegate</c> to do it, in this way.
            
             <code lang="C#">
             using (var input = File.Open(filename, FileMode.Open, FileAccess.Read, FileShare.ReadWrite ))
             {
                 using(Ionic.Zip.ZipFile zip = new Ionic.Zip.ZipFile())
                 {
                     zip.AddEntry(zipEntryName, (name,output) =>
                         {
                             byte[] buffer = new byte[BufferSize];
                             int n;
                             while ((n = input.Read(buffer, 0, buffer.Length)) != 0)
                             {
                                 // could transform the data here...
                                 output.Write(buffer, 0, n);
                                 // could update a progress bar here
                             }
                         });
            
                     zip.Save(zipFileName);
                 }
             }
             </code>
             </example>
            
             <example>
            
             This example uses a named delegate in VB to write data for the given
             ZipEntry (VB9 does not have anonymous delegates). The example here is a bit
             contrived - a simpler way to add the contents of a file to a ZipEntry is to
             simply use the appropriate <c>AddFile()</c> method.  The key scenario for
             which the <c>WriteDelegate</c> makes sense is saving a DataSet, in XML
             format, to the zip file. The DataSet can write XML to a stream, and the
             WriteDelegate is the perfect place to write into the zip file.  There may be
             other data structures that can write to a stream, but cannot be read as a
             stream.  The <c>WriteDelegate</c> would be appropriate for those cases as
             well.
            
             <code lang="VB">
             Private Sub WriteEntry (ByVal name As String, ByVal output As Stream)
                 Using input As FileStream = File.Open(filename, FileMode.Open, FileAccess.Read, FileShare.ReadWrite)
                     Dim n As Integer = -1
                     Dim buffer As Byte() = New Byte(BufferSize){}
                     Do While n &lt;&gt; 0
                         n = input.Read(buffer, 0, buffer.Length)
                         output.Write(buffer, 0, n)
                     Loop
                 End Using
             End Sub
            
             Public Sub Run()
                 Using zip = New ZipFile
                     zip.AddEntry(zipEntryName, New WriteDelegate(AddressOf WriteEntry))
                     zip.Save(zipFileName)
                 End Using
             End Sub
             </code>
             </example>
        </member>
        <member name="M:Ionic.Zip.ZipFile.AddEntry(System.String,Ionic.Zip.OpenDelegate,Ionic.Zip.CloseDelegate)">
             <summary>
               Add an entry, for which the application will provide a stream
               containing the entry data, on a just-in-time basis.
             </summary>
            
             <remarks>
             <para>
               In cases where the application wishes to open the stream that
               holds the content for the ZipEntry, on a just-in-time basis, the
               application can use this method.  The application provides an
               opener delegate that will be called by the DotNetZip library to
               obtain a readable stream that can be read to get the bytes for
               the given entry.  Typically, this delegate opens a stream.
               Optionally, the application can provide a closer delegate as
               well, which will be called by DotNetZip when all bytes have been
               read from the entry.
             </para>
            
             <para>
               These delegates are called from within the scope of the call to
               ZipFile.Save().
             </para>
            
             <para>
               For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption"/>, <see
               cref="P:Ionic.Zip.ZipFile.Password"/>, <see cref="P:Ionic.Zip.ZipFile.SetCompression"/>, <see
               cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile"/>,
               <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction"/>, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel"/>, their
               respective values at the time of this call will be applied to the
               <c>ZipEntry</c> added.
             </para>
            
             </remarks>
            
             <example>
            
               This example uses anonymous methods in C# to open and close the
               source stream for the content for a zip entry.
            
             <code lang="C#">
             using(Ionic.Zip.ZipFile zip = new Ionic.Zip.ZipFile())
             {
                 zip.AddEntry(zipEntryName,
                              (name) =>  File.Open(filename, FileMode.Open, FileAccess.Read, FileShare.ReadWrite ),
                              (name, stream) =>  stream.Close()
                              );
            
                 zip.Save(zipFileName);
             }
             </code>
            
             </example>
            
             <example>
            
               This example uses delegates in VB.NET to open and close the
               the source stream for the content for a zip entry.  VB 9.0 lacks
               support for "Sub" lambda expressions, and so the CloseDelegate must
               be an actual, named Sub.
            
             <code lang="VB">
            
             Function MyStreamOpener(ByVal entryName As String) As Stream
                 '' This simply opens a file.  You probably want to do somethinig
                 '' more involved here: open a stream to read from a database,
                 '' open a stream on an HTTP connection, and so on.
                 Return File.OpenRead(entryName)
             End Function
            
             Sub MyStreamCloser(entryName As String, stream As Stream)
                 stream.Close()
             End Sub
            
             Public Sub Run()
                 Dim dirToZip As String = "fodder"
                 Dim zipFileToCreate As String = "Archive.zip"
                 Dim opener As OpenDelegate = AddressOf MyStreamOpener
                 Dim closer As CloseDelegate = AddressOf MyStreamCloser
                 Dim numFilestoAdd As Int32 = 4
                 Using zip As ZipFile = New ZipFile
                     Dim i As Integer
                     For i = 0 To numFilesToAdd - 1
                         zip.AddEntry(String.Format("content-{0:000}.txt"), opener, closer)
                     Next i
                     zip.Save(zipFileToCreate)
                 End Using
             End Sub
            
             </code>
             </example>
            
             <param name="entryName">the name of the entry to add</param>
             <param name="opener">
              the delegate that will be invoked by ZipFile.Save() to get the
              readable stream for the given entry. ZipFile.Save() will call
              read on this stream to obtain the data for the entry. This data
              will then be compressed and written to the newly created zip
              file.
             </param>
             <param name="closer">
              the delegate that will be invoked to close the stream. This may
              be null (Nothing in VB), in which case no call is makde to close
              the stream.
             </param>
             <returns>the ZipEntry added</returns>
            
        </member>
        <member name="M:Ionic.Zip.ZipFile.UpdateEntry(System.String,System.String)">
             <summary>
               Updates the given entry in the <c>ZipFile</c>, using the given
               string as content for the <c>ZipEntry</c>.
             </summary>
            
             <remarks>
            
             <para>
               Calling this method is equivalent to removing the <c>ZipEntry</c> for
               the given file name and directory path, if it exists, and then calling
               <see cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,System.String)" />.  See the documentation for
               that method for further explanation. The string content is encoded
               using the default encoding for the machine, or on Silverlight, using
               UTF-8. This encoding is distinct from the encoding used for the
               filename itself.  See <see cref="P:Ionic.Zip.ZipFile.AlternateEncoding"/>.
             </para>
            
             </remarks>
            
             <param name="entryName">
               The name, including any path, to use within the archive for the entry.
             </param>
            
             <param name="content">
               The content of the file, should it be extracted from the zip.
             </param>
            
             <returns>The <c>ZipEntry</c> added.</returns>
            
        </member>
        <member name="M:Ionic.Zip.ZipFile.UpdateEntry(System.String,System.String,System.Text.Encoding)">
             <summary>
               Updates the given entry in the <c>ZipFile</c>, using the given string as
               content for the <c>ZipEntry</c>.
             </summary>
            
             <remarks>
               Calling this method is equivalent to removing the <c>ZipEntry</c> for the
               given file name and directory path, if it exists, and then calling <see
               cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,System.String,System.Text.Encoding)" />.  See the
               documentation for that method for further explanation.
             </remarks>
            
             <param name="entryName">
               The name, including any path, to use within the archive for the entry.
             </param>
            
             <param name="content">
               The content of the file, should it be extracted from the zip.
             </param>
            
             <param name="encoding">
               The text encoding to use when encoding the string. Be aware: This is
               distinct from the text encoding used to encode the filename. See <see
               cref="P:Ionic.Zip.ZipFile.AlternateEncoding" />.
             </param>
            
             <returns>The <c>ZipEntry</c> added.</returns>
            
        </member>
        <member name="M:Ionic.Zip.ZipFile.UpdateEntry(System.String,Ionic.Zip.WriteDelegate)">
             <summary>
               Updates the given entry in the <c>ZipFile</c>, using the given delegate
               as the source for content for the <c>ZipEntry</c>.
             </summary>
            
             <remarks>
               Calling this method is equivalent to removing the <c>ZipEntry</c> for the
               given file name and directory path, if it exists, and then calling <see
               cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,Ionic.Zip.WriteDelegate)" />.  See the
               documentation for that method for further explanation.
             </remarks>
            
             <param name="entryName">
               The name, including any path, to use within the archive for the entry.
             </param>
            
             <param name="writer">the delegate which will write the entry content.</param>
            
             <returns>The <c>ZipEntry</c> added.</returns>
            
        </member>
        <member name="M:Ionic.Zip.ZipFile.UpdateEntry(System.String,Ionic.Zip.OpenDelegate,Ionic.Zip.CloseDelegate)">
             <summary>
               Updates the given entry in the <c>ZipFile</c>, using the given delegates
               to open and close the stream that provides the content for the <c>ZipEntry</c>.
             </summary>
            
             <remarks>
               Calling this method is equivalent to removing the <c>ZipEntry</c> for the
               given file name and directory path, if it exists, and then calling <see
               cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,Ionic.Zip.OpenDelegate,Ionic.Zip.CloseDelegate)" />.  See the
               documentation for that method for further explanation.
             </remarks>
            
             <param name="entryName">
               The name, including any path, to use within the archive for the entry.
             </param>
            
             <param name="opener">
              the delegate that will be invoked to open the stream
             </param>
             <param name="closer">
              the delegate that will be invoked to close the stream
             </param>
            
             <returns>The <c>ZipEntry</c> added or updated.</returns>
            
        </member>
        <member name="M:Ionic.Zip.ZipFile.UpdateEntry(System.String,System.IO.Stream)">
             <summary>
               Updates the given entry in the <c>ZipFile</c>, using the given stream as
               input, and the given filename and given directory Path.
             </summary>
            
             <remarks>
             <para>
               Calling the method is equivalent to calling <c>RemoveEntry()</c> if an
               entry by the same name already exists, and then calling <c>AddEntry()</c>
               with the given <c>fileName</c> and stream.
             </para>
            
             <para>
               The stream must be open and readable during the call to
               <c>ZipFile.Save</c>.  You can dispense the stream on a just-in-time basis
               using the <see cref="P:Ionic.Zip.ZipEntry.InputStream"/> property. Check the
               documentation of that property for more information.
             </para>
            
             <para>
               For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption"/>, <see
               cref="P:Ionic.Zip.ZipFile.Password"/>, <see cref="P:Ionic.Zip.ZipFile.SetCompression"/>, <see
               cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile"/>,
               <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction"/>, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel"/>, their
               respective values at the time of this call will be applied to the
               <c>ZipEntry</c> added.
             </para>
            
             </remarks>
            
             <seealso cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,System.IO.Stream)"/>
             <seealso cref="P:Ionic.Zip.ZipEntry.InputStream"/>
            
             <param name="entryName">
               The name, including any path, to use within the archive for the entry.
             </param>
            
             <param name="stream">The input stream from which to read file data.</param>
             <returns>The <c>ZipEntry</c> added.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.AddEntry(System.String,System.Byte[])">
             <summary>
               Add an entry into the zip archive using the given filename and
               directory path within the archive, and the given content for the
               file. No file is created in the filesystem.
             </summary>
            
             <param name="byteContent">The data to use for the entry.</param>
            
             <param name="entryName">
               The name, including any path, to use within the archive for the entry.
             </param>
            
             <returns>The <c>ZipEntry</c> added.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.UpdateEntry(System.String,System.Byte[])">
             <summary>
               Updates the given entry in the <c>ZipFile</c>, using the given byte
               array as content for the entry.
             </summary>
            
             <remarks>
               Calling this method is equivalent to removing the <c>ZipEntry</c>
               for the given filename and directory path, if it exists, and then
               calling <see cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,System.Byte[])" />.  See the
               documentation for that method for further explanation.
             </remarks>
            
             <param name="entryName">
               The name, including any path, to use within the archive for the entry.
             </param>
            
             <param name="byteContent">The content to use for the <c>ZipEntry</c>.</param>
            
             <returns>The <c>ZipEntry</c> added.</returns>
            
        </member>
        <member name="M:Ionic.Zip.ZipFile.AddDirectory(System.String)">
             <summary>
               Adds the contents of a filesystem directory to a Zip file archive.
             </summary>
            
             <remarks>
            
             <para>
               The name of the directory may be a relative path or a fully-qualified
               path. Any files within the named directory are added to the archive.  Any
               subdirectories within the named directory are also added to the archive,
               recursively.
             </para>
            
             <para>
               Top-level entries in the named directory will appear as top-level entries
               in the zip archive.  Entries in subdirectories in the named directory will
               result in entries in subdirectories in the zip archive.
             </para>
            
             <para>
               If you want the entries to appear in a containing directory in the zip
               archive itself, then you should call the AddDirectory() overload that
               allows you to explicitly specify a directory path for use in the archive.
             </para>
            
             <para>
               For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption"/>, <see
               cref="P:Ionic.Zip.ZipFile.Password"/>, <see cref="P:Ionic.Zip.ZipFile.SetCompression"/>, <see
               cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile"/>,
               <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction"/>, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel"/>, their
               respective values at the time of this call will be applied to each
               ZipEntry added.
             </para>
            
             </remarks>
            
             <seealso cref="M:Ionic.Zip.ZipFile.AddItem(System.String)"/>
             <seealso cref="M:Ionic.Zip.ZipFile.AddFile(System.String)"/>
             <seealso cref="M:Ionic.Zip.ZipFile.UpdateDirectory(System.String)"/>
             <seealso cref="M:Ionic.Zip.ZipFile.AddDirectory(System.String,System.String)"/>
            
             <overloads>This method has 2 overloads.</overloads>
            
             <param name="directoryName">The name of the directory to add.</param>
             <returns>The <c>ZipEntry</c> added.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.AddDirectory(System.String,System.String)">
             <summary>
               Adds the contents of a filesystem directory to a Zip file archive,
               overriding the path to be used for entries in the archive.
             </summary>
            
             <remarks>
             <para>
               The name of the directory may be a relative path or a fully-qualified
               path. The add operation is recursive, so that any files or subdirectories
               within the name directory are also added to the archive.
             </para>
            
             <para>
               Top-level entries in the named directory will appear as top-level entries
               in the zip archive.  Entries in subdirectories in the named directory will
               result in entries in subdirectories in the zip archive.
             </para>
            
             <para>
               For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption"/>, <see
               cref="P:Ionic.Zip.ZipFile.Password"/>, <see cref="P:Ionic.Zip.ZipFile.SetCompression"/>, <see
               cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile"/>,
               <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction"/>, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel"/>, their
               respective values at the time of this call will be applied to each
               ZipEntry added.
             </para>
            
             </remarks>
            
             <example>
             <para>
               In this code, calling the ZipUp() method with a value of "c:\reports" for
               the directory parameter will result in a zip file structure in which all
               entries are contained in a toplevel "reports" directory.
             </para>
            
             <code lang="C#">
             public void ZipUp(string targetZip, string directory)
             {
               using (var zip = new ZipFile())
               {
                 zip.AddDirectory(directory, System.IO.Path.GetFileName(directory));
                 zip.Save(targetZip);
               }
             }
             </code>
             </example>
            
             <seealso cref="M:Ionic.Zip.ZipFile.AddItem(System.String,System.String)"/>
             <seealso cref="M:Ionic.Zip.ZipFile.AddFile(System.String,System.String)"/>
             <seealso cref="M:Ionic.Zip.ZipFile.UpdateDirectory(System.String,System.String)"/>
            
             <param name="directoryName">The name of the directory to add.</param>
            
             <param name="directoryPathInArchive">
               Specifies a directory path to use to override any path in the
               DirectoryName.  This path may, or may not, correspond to a real directory
               in the current filesystem.  If the zip is later extracted, this is the
               path used for the extracted file or directory.  Passing <c>null</c>
               (<c>Nothing</c> in VB) or the empty string ("") will insert the items at
               the root path within the archive.
             </param>
            
             <returns>The <c>ZipEntry</c> added.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.AddDirectoryByName(System.String)">
             <summary>
               Creates a directory in the zip archive.
             </summary>
            
             <remarks>
            
             <para>
               Use this when you want to create a directory in the archive but there is
               no corresponding filesystem representation for that directory.
             </para>
            
             <para>
               You will probably not need to do this in your code. One of the only times
               you will want to do this is if you want an empty directory in the zip
               archive.  The reason: if you add a file to a zip archive that is stored
               within a multi-level directory, all of the directory tree is implicitly
               created in the zip archive.
             </para>
            
             </remarks>
            
             <param name="directoryNameInArchive">
               The name of the directory to create in the archive.
             </param>
             <returns>The <c>ZipEntry</c> added.</returns>
        </member>
        <member name="E:Ionic.Zip.ZipFile.SaveProgress">
             <summary>
               An event handler invoked when a Save() starts, before and after each
               entry has been written to the archive, when a Save() completes, and
               during other Save events.
             </summary>
            
             <remarks>
             <para>
               Depending on the particular event, different properties on the <see
               cref="T:Ionic.Zip.SaveProgressEventArgs"/> parameter are set.  The following
               table summarizes the available EventTypes and the conditions under
               which this event handler is invoked with a
               <c>SaveProgressEventArgs</c> with the given EventType.
             </para>
            
             <list type="table">
             <listheader>
             <term>value of EntryType</term>
             <description>Meaning and conditions</description>
             </listheader>
            
             <item>
             <term>ZipProgressEventType.Saving_Started</term>
             <description>Fired when ZipFile.Save() begins.
             </description>
             </item>
            
             <item>
             <term>ZipProgressEventType.Saving_BeforeSaveEntry</term>
             <description>
               Fired within ZipFile.Save(), just before writing data for each
               particular entry.
             </description>
             </item>
            
             <item>
             <term>ZipProgressEventType.Saving_AfterSaveEntry</term>
             <description>
               Fired within ZipFile.Save(), just after having finished writing data
               for each particular entry.
             </description>
             </item>
            
             <item>
             <term>ZipProgressEventType.Saving_Completed</term>
             <description>Fired when ZipFile.Save() has completed.
             </description>
             </item>
            
             <item>
             <term>ZipProgressEventType.Saving_AfterSaveTempArchive</term>
             <description>
               Fired after the temporary file has been created.  This happens only
               when saving to a disk file.  This event will not be invoked when
               saving to a stream.
             </description>
             </item>
            
             <item>
             <term>ZipProgressEventType.Saving_BeforeRenameTempArchive</term>
             <description>
               Fired just before renaming the temporary file to the permanent
               location.  This happens only when saving to a disk file.  This event
               will not be invoked when saving to a stream.
             </description>
             </item>
            
             <item>
             <term>ZipProgressEventType.Saving_AfterRenameTempArchive</term>
             <description>
               Fired just after renaming the temporary file to the permanent
               location.  This happens only when saving to a disk file.  This event
               will not be invoked when saving to a stream.
             </description>
             </item>
            
             <item>
             <term>ZipProgressEventType.Saving_AfterCompileSelfExtractor</term>
             <description>
               Fired after a self-extracting archive has finished compiling.  This
               EventType is used only within SaveSelfExtractor().
             </description>
             </item>
            
             <item>
             <term>ZipProgressEventType.Saving_BytesRead</term>
             <description>
               Set during the save of a particular entry, to update progress of the
               Save().  When this EventType is set, the BytesTransferred is the
               number of bytes that have been read from the source stream.  The
               TotalBytesToTransfer is the number of bytes in the uncompressed
               file.
             </description>
             </item>
            
             </list>
             </remarks>
            
             <example>
            
                This example uses an anonymous method to handle the
                SaveProgress event, by updating a progress bar.
            
             <code lang="C#">
             progressBar1.Value = 0;
             progressBar1.Max = listbox1.Items.Count;
             using (ZipFile zip = new ZipFile())
             {
                // listbox1 contains a list of filenames
                zip.AddFiles(listbox1.Items);
            
                // do the progress bar:
                zip.SaveProgress += (sender, e) => {
                   if (e.EventType == ZipProgressEventType.Saving_BeforeWriteEntry) {
                      progressBar1.PerformStep();
                   }
                };
            
                zip.Save(fs);
             }
             </code>
             </example>
            
             <example>
               This example uses a named method as the
               <c>SaveProgress</c> event handler, to update the user, in a
               console-based application.
            
             <code lang="C#">
             static bool justHadByteUpdate= false;
             public static void SaveProgress(object sender, SaveProgressEventArgs e)
             {
                 if (e.EventType == ZipProgressEventType.Saving_Started)
                     Console.WriteLine("Saving: {0}", e.ArchiveName);
            
                 else if (e.EventType == ZipProgressEventType.Saving_Completed)
                 {
                     justHadByteUpdate= false;
                     Console.WriteLine();
                     Console.WriteLine("Done: {0}", e.ArchiveName);
                 }
            
                 else if (e.EventType == ZipProgressEventType.Saving_BeforeWriteEntry)
                 {
                     if (justHadByteUpdate)
                         Console.WriteLine();
                     Console.WriteLine("  Writing: {0} ({1}/{2})",
                                       e.CurrentEntry.FileName, e.EntriesSaved, e.EntriesTotal);
                     justHadByteUpdate= false;
                 }
            
                 else if (e.EventType == ZipProgressEventType.Saving_EntryBytesRead)
                 {
                     if (justHadByteUpdate)
                         Console.SetCursorPosition(0, Console.CursorTop);
                      Console.Write("     {0}/{1} ({2:N0}%)", e.BytesTransferred, e.TotalBytesToTransfer,
                                   e.BytesTransferred / (0.01 * e.TotalBytesToTransfer ));
                     justHadByteUpdate= true;
                 }
             }
            
             public static ZipUp(string targetZip, string directory)
             {
               using (var zip = new ZipFile()) {
                 zip.SaveProgress += SaveProgress;
                 zip.AddDirectory(directory);
                 zip.Save(targetZip);
               }
             }
            
             </code>
            
             <code lang="VB">
             Public Sub ZipUp(ByVal targetZip As String, ByVal directory As String)
                 Using zip As ZipFile = New ZipFile
                     AddHandler zip.SaveProgress, AddressOf MySaveProgress
                     zip.AddDirectory(directory)
                     zip.Save(targetZip)
                 End Using
             End Sub
            
             Private Shared justHadByteUpdate As Boolean = False
            
             Public Shared Sub MySaveProgress(ByVal sender As Object, ByVal e As SaveProgressEventArgs)
                 If (e.EventType Is ZipProgressEventType.Saving_Started) Then
                     Console.WriteLine("Saving: {0}", e.ArchiveName)
            
                 ElseIf (e.EventType Is ZipProgressEventType.Saving_Completed) Then
                     justHadByteUpdate = False
                     Console.WriteLine
                     Console.WriteLine("Done: {0}", e.ArchiveName)
            
                 ElseIf (e.EventType Is ZipProgressEventType.Saving_BeforeWriteEntry) Then
                     If justHadByteUpdate Then
                         Console.WriteLine
                     End If
                     Console.WriteLine("  Writing: {0} ({1}/{2})", e.CurrentEntry.FileName, e.EntriesSaved, e.EntriesTotal)
                     justHadByteUpdate = False
            
                 ElseIf (e.EventType Is ZipProgressEventType.Saving_EntryBytesRead) Then
                     If justHadByteUpdate Then
                         Console.SetCursorPosition(0, Console.CursorTop)
                     End If
                     Console.Write("     {0}/{1} ({2:N0}%)", e.BytesTransferred, _
                                   e.TotalBytesToTransfer, _
                                   (CDbl(e.BytesTransferred) / (0.01 * e.TotalBytesToTransfer)))
                     justHadByteUpdate = True
                 End If
             End Sub
             </code>
             </example>
            
             <example>
            
             This is a more complete example of using the SaveProgress
             events in a Windows Forms application, with a
             Thread object.
            
             <code lang="C#">
             delegate void SaveEntryProgress(SaveProgressEventArgs e);
             delegate void ButtonClick(object sender, EventArgs e);
            
             public class WorkerOptions
             {
                 public string ZipName;
                 public string Folder;
                 public string Encoding;
                 public string Comment;
                 public int ZipFlavor;
                 public Zip64Option Zip64;
             }
            
             private int _progress2MaxFactor;
             private bool _saveCanceled;
             private long _totalBytesBeforeCompress;
             private long _totalBytesAfterCompress;
             private Thread _workerThread;
            
            
             private void btnZipup_Click(object sender, EventArgs e)
             {
                 KickoffZipup();
             }
            
             private void btnCancel_Click(object sender, EventArgs e)
             {
                 if (this.lblStatus.InvokeRequired)
                 {
                     this.lblStatus.Invoke(new ButtonClick(this.btnCancel_Click), new object[] { sender, e });
                 }
                 else
                 {
                     _saveCanceled = true;
                     lblStatus.Text = "Canceled...";
                     ResetState();
                 }
             }
            
             private void KickoffZipup()
             {
                 _folderName = tbDirName.Text;
            
                 if (_folderName == null || _folderName == "") return;
                 if (this.tbZipName.Text == null || this.tbZipName.Text == "") return;
            
                 // check for existence of the zip file:
                 if (System.IO.File.Exists(this.tbZipName.Text))
                 {
                     var dlgResult = MessageBox.Show(String.Format("The file you have specified ({0}) already exists." +
                                                                   "  Do you want to overwrite this file?", this.tbZipName.Text),
                                                     "Confirmation is Required", MessageBoxButtons.YesNo, MessageBoxIcon.Question);
                     if (dlgResult != DialogResult.Yes) return;
                     System.IO.File.Delete(this.tbZipName.Text);
                 }
            
                  _saveCanceled = false;
                 _nFilesCompleted = 0;
                 _totalBytesAfterCompress = 0;
                 _totalBytesBeforeCompress = 0;
                 this.btnOk.Enabled = false;
                 this.btnOk.Text = "Zipping...";
                 this.btnCancel.Enabled = true;
                 lblStatus.Text = "Zipping...";
            
                 var options = new WorkerOptions
                 {
                     ZipName = this.tbZipName.Text,
                     Folder = _folderName,
                     Encoding = "ibm437"
                 };
            
                 if (this.comboBox1.SelectedIndex != 0)
                 {
                     options.Encoding = this.comboBox1.SelectedItem.ToString();
                 }
            
                 if (this.radioFlavorSfxCmd.Checked)
                     options.ZipFlavor = 2;
                 else if (this.radioFlavorSfxGui.Checked)
                     options.ZipFlavor = 1;
                 else options.ZipFlavor = 0;
            
                 if (this.radioZip64AsNecessary.Checked)
                     options.Zip64 = Zip64Option.AsNecessary;
                 else if (this.radioZip64Always.Checked)
                     options.Zip64 = Zip64Option.Always;
                 else options.Zip64 = Zip64Option.Never;
            
                 options.Comment = String.Format("Encoding:{0} || Flavor:{1} || ZIP64:{2}\r\nCreated at {3} || {4}\r\n",
                             options.Encoding,
                             FlavorToString(options.ZipFlavor),
                             options.Zip64.ToString(),
                             System.DateTime.Now.ToString("yyyy-MMM-dd HH:mm:ss"),
                             this.Text);
            
                 if (this.tbComment.Text != TB_COMMENT_NOTE)
                     options.Comment += this.tbComment.Text;
            
                 _workerThread = new Thread(this.DoSave);
                 _workerThread.Name = "Zip Saver thread";
                 _workerThread.Start(options);
                 this.Cursor = Cursors.WaitCursor;
              }
            
            
             private void DoSave(Object p)
             {
                 WorkerOptions options = p as WorkerOptions;
                 try
                 {
                     using (var zip1 = new ZipFile())
                     {
                         zip1.ProvisionalAlternateEncoding = System.Text.Encoding.GetEncoding(options.Encoding);
                         zip1.Comment = options.Comment;
                         zip1.AddDirectory(options.Folder);
                         _entriesToZip = zip1.EntryFileNames.Count;
                         SetProgressBars();
                         zip1.SaveProgress += this.zip1_SaveProgress;
            
                         zip1.UseZip64WhenSaving = options.Zip64;
            
                         if (options.ZipFlavor == 1)
                             zip1.SaveSelfExtractor(options.ZipName, SelfExtractorFlavor.WinFormsApplication);
                         else if (options.ZipFlavor == 2)
                             zip1.SaveSelfExtractor(options.ZipName, SelfExtractorFlavor.ConsoleApplication);
                         else
                             zip1.Save(options.ZipName);
                     }
                 }
                 catch (System.Exception exc1)
                 {
                     MessageBox.Show(String.Format("Exception while zipping: {0}", exc1.Message));
                     btnCancel_Click(null, null);
                 }
             }
            
            
            
             void zip1_SaveProgress(object sender, SaveProgressEventArgs e)
             {
                 switch (e.EventType)
                 {
                     case ZipProgressEventType.Saving_AfterWriteEntry:
                         StepArchiveProgress(e);
                         break;
                     case ZipProgressEventType.Saving_EntryBytesRead:
                         StepEntryProgress(e);
                         break;
                     case ZipProgressEventType.Saving_Completed:
                         SaveCompleted();
                         break;
                     case ZipProgressEventType.Saving_AfterSaveTempArchive:
                         // this event only occurs when saving an SFX file
                         TempArchiveSaved();
                         break;
                 }
                 if (_saveCanceled)
                     e.Cancel = true;
             }
            
            
            
             private void StepArchiveProgress(SaveProgressEventArgs e)
             {
                 if (this.progressBar1.InvokeRequired)
                 {
                     this.progressBar1.Invoke(new SaveEntryProgress(this.StepArchiveProgress), new object[] { e });
                 }
                 else
                 {
                     if (!_saveCanceled)
                     {
                         _nFilesCompleted++;
                         this.progressBar1.PerformStep();
                         _totalBytesAfterCompress += e.CurrentEntry.CompressedSize;
                         _totalBytesBeforeCompress += e.CurrentEntry.UncompressedSize;
            
                         // reset the progress bar for the entry:
                         this.progressBar2.Value = this.progressBar2.Maximum = 1;
            
                         this.Update();
                     }
                 }
             }
            
            
             private void StepEntryProgress(SaveProgressEventArgs e)
             {
                 if (this.progressBar2.InvokeRequired)
                 {
                     this.progressBar2.Invoke(new SaveEntryProgress(this.StepEntryProgress), new object[] { e });
                 }
                 else
                 {
                     if (!_saveCanceled)
                     {
                         if (this.progressBar2.Maximum == 1)
                         {
                             // reset
                             Int64 max = e.TotalBytesToTransfer;
                             _progress2MaxFactor = 0;
                             while (max > System.Int32.MaxValue)
                             {
                                 max /= 2;
                                 _progress2MaxFactor++;
                             }
                             this.progressBar2.Maximum = (int)max;
                             lblStatus.Text = String.Format("{0} of {1} files...({2})",
                                 _nFilesCompleted + 1, _entriesToZip, e.CurrentEntry.FileName);
                         }
            
                          int xferred = e.BytesTransferred >> _progress2MaxFactor;
            
                          this.progressBar2.Value = (xferred >= this.progressBar2.Maximum)
                             ? this.progressBar2.Maximum
                             : xferred;
            
                          this.Update();
                     }
                 }
             }
            
             private void SaveCompleted()
             {
                 if (this.lblStatus.InvokeRequired)
                 {
                     this.lblStatus.Invoke(new MethodInvoker(this.SaveCompleted));
                 }
                 else
                 {
                     lblStatus.Text = String.Format("Done, Compressed {0} files, {1:N0}% of original.",
                         _nFilesCompleted, (100.00 * _totalBytesAfterCompress) / _totalBytesBeforeCompress);
                      ResetState();
                 }
             }
            
             private void ResetState()
             {
                 this.btnCancel.Enabled = false;
                 this.btnOk.Enabled = true;
                 this.btnOk.Text = "Zip it!";
                 this.progressBar1.Value = 0;
                 this.progressBar2.Value = 0;
                 this.Cursor = Cursors.Default;
                 if (!_workerThread.IsAlive)
                     _workerThread.Join();
             }
             </code>
            
             </example>
            
             <seealso cref="E:Ionic.Zip.ZipFile.ReadProgress"/>
             <seealso cref="E:Ionic.Zip.ZipFile.AddProgress"/>
             <seealso cref="E:Ionic.Zip.ZipFile.ExtractProgress"/>
        </member>
        <member name="E:Ionic.Zip.ZipFile.ReadProgress">
             <summary>
             An event handler invoked before, during, and after the reading of a zip archive.
             </summary>
            
             <remarks>
             <para>
             Depending on the particular event being signaled, different properties on the
             <see cref="T:Ionic.Zip.ReadProgressEventArgs"/> parameter are set.  The following table
             summarizes the available EventTypes and the conditions under which this
             event handler is invoked with a <c>ReadProgressEventArgs</c> with the given EventType.
             </para>
            
             <list type="table">
             <listheader>
             <term>value of EntryType</term>
             <description>Meaning and conditions</description>
             </listheader>
            
             <item>
             <term>ZipProgressEventType.Reading_Started</term>
             <description>Fired just as ZipFile.Read() begins. Meaningful properties: ArchiveName.
             </description>
             </item>
            
             <item>
             <term>ZipProgressEventType.Reading_Completed</term>
             <description>Fired when ZipFile.Read() has completed. Meaningful properties: ArchiveName.
             </description>
             </item>
            
             <item>
             <term>ZipProgressEventType.Reading_ArchiveBytesRead</term>
             <description>Fired while reading, updates the number of bytes read for the entire archive.
             Meaningful properties: ArchiveName, CurrentEntry, BytesTransferred, TotalBytesToTransfer.
             </description>
             </item>
            
             <item>
             <term>ZipProgressEventType.Reading_BeforeReadEntry</term>
             <description>Indicates an entry is about to be read from the archive.
             Meaningful properties: ArchiveName, EntriesTotal.
             </description>
             </item>
            
             <item>
             <term>ZipProgressEventType.Reading_AfterReadEntry</term>
             <description>Indicates an entry has just been read from the archive.
             Meaningful properties: ArchiveName, EntriesTotal, CurrentEntry.
             </description>
             </item>
            
             </list>
             </remarks>
            
             <seealso cref="E:Ionic.Zip.ZipFile.SaveProgress"/>
             <seealso cref="E:Ionic.Zip.ZipFile.AddProgress"/>
             <seealso cref="E:Ionic.Zip.ZipFile.ExtractProgress"/>
        </member>
        <member name="E:Ionic.Zip.ZipFile.ExtractProgress">
             <summary>
               An event handler invoked before, during, and after extraction of
               entries in the zip archive.
             </summary>
            
             <remarks>
             <para>
               Depending on the particular event, different properties on the <see
               cref="T:Ionic.Zip.ExtractProgressEventArgs"/> parameter are set.  The following
               table summarizes the available EventTypes and the conditions under
               which this event handler is invoked with a
               <c>ExtractProgressEventArgs</c> with the given EventType.
             </para>
            
             <list type="table">
             <listheader>
             <term>value of EntryType</term>
             <description>Meaning and conditions</description>
             </listheader>
            
             <item>
             <term>ZipProgressEventType.Extracting_BeforeExtractAll</term>
             <description>
               Set when ExtractAll() begins. The ArchiveName, Overwrite, and
               ExtractLocation properties are meaningful.</description>
             </item>
            
             <item>
             <term>ZipProgressEventType.Extracting_AfterExtractAll</term>
             <description>
               Set when ExtractAll() has completed.  The ArchiveName, Overwrite,
               and ExtractLocation properties are meaningful.
             </description>
             </item>
            
             <item>
             <term>ZipProgressEventType.Extracting_BeforeExtractEntry</term>
             <description>
               Set when an Extract() on an entry in the ZipFile has begun.
               Properties that are meaningful: ArchiveName, EntriesTotal,
               CurrentEntry, Overwrite, ExtractLocation, EntriesExtracted.
             </description>
             </item>
            
             <item>
             <term>ZipProgressEventType.Extracting_AfterExtractEntry</term>
             <description>
               Set when an Extract() on an entry in the ZipFile has completed.
               Properties that are meaningful: ArchiveName, EntriesTotal,
               CurrentEntry, Overwrite, ExtractLocation, EntriesExtracted.
             </description>
             </item>
            
             <item>
             <term>ZipProgressEventType.Extracting_EntryBytesWritten</term>
             <description>
               Set within a call to Extract() on an entry in the ZipFile, as data
               is extracted for the entry.  Properties that are meaningful:
               ArchiveName, CurrentEntry, BytesTransferred, TotalBytesToTransfer.
             </description>
             </item>
            
             <item>
             <term>ZipProgressEventType.Extracting_ExtractEntryWouldOverwrite</term>
             <description>
               Set within a call to Extract() on an entry in the ZipFile, when the
               extraction would overwrite an existing file. This event type is used
               only when <c>ExtractExistingFileAction</c> on the <c>ZipFile</c> or
               <c>ZipEntry</c> is set to <c>InvokeExtractProgressEvent</c>.
             </description>
             </item>
            
             </list>
            
             </remarks>
            
             <example>
             <code>
             private static bool justHadByteUpdate = false;
             public static void ExtractProgress(object sender, ExtractProgressEventArgs e)
             {
               if(e.EventType == ZipProgressEventType.Extracting_EntryBytesWritten)
               {
                 if (justHadByteUpdate)
                   Console.SetCursorPosition(0, Console.CursorTop);
            
                 Console.Write("   {0}/{1} ({2:N0}%)", e.BytesTransferred, e.TotalBytesToTransfer,
                               e.BytesTransferred / (0.01 * e.TotalBytesToTransfer ));
                 justHadByteUpdate = true;
               }
               else if(e.EventType == ZipProgressEventType.Extracting_BeforeExtractEntry)
               {
                 if (justHadByteUpdate)
                   Console.WriteLine();
                 Console.WriteLine("Extracting: {0}", e.CurrentEntry.FileName);
                 justHadByteUpdate= false;
               }
             }
            
             public static ExtractZip(string zipToExtract, string directory)
             {
               string TargetDirectory= "extract";
               using (var zip = ZipFile.Read(zipToExtract)) {
                 zip.ExtractProgress += ExtractProgress;
                 foreach (var e in zip1)
                 {
                   e.Extract(TargetDirectory, true);
                 }
               }
             }
            
             </code>
             <code lang="VB">
             Public Shared Sub Main(ByVal args As String())
                 Dim ZipToUnpack As String = "C1P3SML.zip"
                 Dim TargetDir As String = "ExtractTest_Extract"
                 Console.WriteLine("Extracting file {0} to {1}", ZipToUnpack, TargetDir)
                 Using zip1 As ZipFile = ZipFile.Read(ZipToUnpack)
                     AddHandler zip1.ExtractProgress, AddressOf MyExtractProgress
                     Dim e As ZipEntry
                     For Each e In zip1
                         e.Extract(TargetDir, True)
                     Next
                 End Using
             End Sub
            
             Private Shared justHadByteUpdate As Boolean = False
            
             Public Shared Sub MyExtractProgress(ByVal sender As Object, ByVal e As ExtractProgressEventArgs)
                 If (e.EventType = ZipProgressEventType.Extracting_EntryBytesWritten) Then
                     If ExtractTest.justHadByteUpdate Then
                         Console.SetCursorPosition(0, Console.CursorTop)
                     End If
                     Console.Write("   {0}/{1} ({2:N0}%)", e.BytesTransferred, e.TotalBytesToTransfer, (CDbl(e.BytesTransferred) / (0.01 * e.TotalBytesToTransfer)))
                     ExtractTest.justHadByteUpdate = True
                 ElseIf (e.EventType = ZipProgressEventType.Extracting_BeforeExtractEntry) Then
                     If ExtractTest.justHadByteUpdate Then
                         Console.WriteLine
                     End If
                     Console.WriteLine("Extracting: {0}", e.CurrentEntry.FileName)
                     ExtractTest.justHadByteUpdate = False
                 End If
             End Sub
             </code>
             </example>
            
             <seealso cref="E:Ionic.Zip.ZipFile.SaveProgress"/>
             <seealso cref="E:Ionic.Zip.ZipFile.ReadProgress"/>
             <seealso cref="E:Ionic.Zip.ZipFile.AddProgress"/>
        </member>
        <member name="E:Ionic.Zip.ZipFile.AddProgress">
             <summary>
             An event handler invoked before, during, and after Adding entries to a zip archive.
             </summary>
            
             <remarks>
                 Adding a large number of entries to a zip file can take a long
                 time.  For example, when calling <see cref="M:Ionic.Zip.ZipFile.AddDirectory(System.String)"/> on a
                 directory that contains 50,000 files, it could take 3 minutes or so.
                 This event handler allws an application to track the progress of the Add
                 operation, and to optionally cancel a lengthy Add operation.
             </remarks>
            
             <example>
             <code lang="C#">
            
             int _numEntriesToAdd= 0;
             int _numEntriesAdded= 0;
             void AddProgressHandler(object sender, AddProgressEventArgs e)
             {
                 switch (e.EventType)
                 {
                     case ZipProgressEventType.Adding_Started:
                         Console.WriteLine("Adding files to the zip...");
                         break;
                     case ZipProgressEventType.Adding_AfterAddEntry:
                         _numEntriesAdded++;
                         Console.WriteLine(String.Format("Adding file {0}/{1} :: {2}",
                                                  _numEntriesAdded, _numEntriesToAdd, e.CurrentEntry.FileName));
                         break;
                     case ZipProgressEventType.Adding_Completed:
                         Console.WriteLine("Added all files");
                         break;
                 }
             }
            
             void CreateTheZip()
             {
                 using (ZipFile zip = new ZipFile())
                 {
                     zip.AddProgress += AddProgressHandler;
                     zip.AddDirectory(System.IO.Path.GetFileName(DirToZip));
                     zip.Save(ZipFileToCreate);
                 }
             }
            
             </code>
            
             <code lang="VB">
            
             Private Sub AddProgressHandler(ByVal sender As Object, ByVal e As AddProgressEventArgs)
                 Select Case e.EventType
                     Case ZipProgressEventType.Adding_Started
                         Console.WriteLine("Adding files to the zip...")
                         Exit Select
                     Case ZipProgressEventType.Adding_AfterAddEntry
                         Console.WriteLine(String.Format("Adding file {0}", e.CurrentEntry.FileName))
                         Exit Select
                     Case ZipProgressEventType.Adding_Completed
                         Console.WriteLine("Added all files")
                         Exit Select
                 End Select
             End Sub
            
             Sub CreateTheZip()
                 Using zip as ZipFile = New ZipFile
                     AddHandler zip.AddProgress, AddressOf AddProgressHandler
                     zip.AddDirectory(System.IO.Path.GetFileName(DirToZip))
                     zip.Save(ZipFileToCreate);
                 End Using
             End Sub
            
             </code>
            
             </example>
            
             <seealso cref="E:Ionic.Zip.ZipFile.SaveProgress"/>
             <seealso cref="E:Ionic.Zip.ZipFile.ReadProgress"/>
             <seealso cref="E:Ionic.Zip.ZipFile.ExtractProgress"/>
        </member>
        <member name="E:Ionic.Zip.ZipFile.ZipError">
             <summary>
             An event that is raised when an error occurs during open or read of files
             while saving a zip archive.
             </summary>
            
             <remarks>
              <para>
                 Errors can occur as a file is being saved to the zip archive.  For
                 example, the File.Open may fail, or a File.Read may fail, because of
                 lock conflicts or other reasons.  If you add a handler to this event,
                 you can handle such errors in your own code.  If you don't add a
                 handler, the library will throw an exception if it encounters an I/O
                 error during a call to <c>Save()</c>.
              </para>
            
              <para>
                Setting a handler implicitly sets <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction"/> to
                <c>ZipErrorAction.InvokeErrorEvent</c>.
              </para>
            
              <para>
                The handler you add applies to all <see cref="T:Ionic.Zip.ZipEntry"/> items that are
                subsequently added to the <c>ZipFile</c> instance. If you set this
                property after you have added items to the <c>ZipFile</c>, but before you
                have called <c>Save()</c>, errors that occur while saving those items
                will not cause the error handler to be invoked.
              </para>
            
              <para>
                If you want to handle any errors that occur with any entry in the zip
                file using the same error handler, then add your error handler once,
                before adding any entries to the zip archive.
              </para>
            
              <para>
                In the error handler method, you need to set the <see
                cref="P:Ionic.Zip.ZipEntry.ZipErrorAction"/> property on the
                <c>ZipErrorEventArgs.CurrentEntry</c>.  This communicates back to
                DotNetZip what you would like to do with this particular error.  Within
                an error handler, if you set the <c>ZipEntry.ZipErrorAction</c> property
                on the <c>ZipEntry</c> to <c>ZipErrorAction.InvokeErrorEvent</c> or if
                you don't set it at all, the library will throw the exception. (It is the
                same as if you had set the <c>ZipEntry.ZipErrorAction</c> property on the
                <c>ZipEntry</c> to <c>ZipErrorAction.Throw</c>.) If you set the
                <c>ZipErrorEventArgs.Cancel</c> to true, the entire <c>Save()</c> will be
                canceled.
              </para>
            
              <para>
                In the case that you use <c>ZipErrorAction.Skip</c>, implying that
                you want to skip the entry for which there's been an error, DotNetZip
                tries to seek backwards in the output stream, and truncate all bytes
                written on behalf of that particular entry. This works only if the
                output stream is seekable.  It will not work, for example, when using
                ASPNET's Response.OutputStream.
              </para>
            
             </remarks>
            
             <example>
            
             This example shows how to use an event handler to handle
             errors during save of the zip file.
             <code lang="C#">
            
             public static void MyZipError(object sender, ZipErrorEventArgs e)
             {
                 Console.WriteLine("Error saving {0}...", e.FileName);
                 Console.WriteLine("   Exception: {0}", e.exception);
                 ZipEntry entry = e.CurrentEntry;
                 string response = null;
                 // Ask the user whether he wants to skip this error or not
                 do
                 {
                     Console.Write("Retry, Skip, Throw, or Cancel ? (R/S/T/C) ");
                     response = Console.ReadLine();
                     Console.WriteLine();
            
                 } while (response != null &amp;&amp;
                          response[0]!='S' &amp;&amp; response[0]!='s' &amp;&amp;
                          response[0]!='R' &amp;&amp; response[0]!='r' &amp;&amp;
                          response[0]!='T' &amp;&amp; response[0]!='t' &amp;&amp;
                          response[0]!='C' &amp;&amp; response[0]!='c');
            
                 e.Cancel = (response[0]=='C' || response[0]=='c');
            
                 if (response[0]=='S' || response[0]=='s')
                     entry.ZipErrorAction = ZipErrorAction.Skip;
                 else if (response[0]=='R' || response[0]=='r')
                     entry.ZipErrorAction = ZipErrorAction.Retry;
                 else if (response[0]=='T' || response[0]=='t')
                     entry.ZipErrorAction = ZipErrorAction.Throw;
             }
            
             public void SaveTheFile()
             {
               string directoryToZip = "fodder";
               string directoryInArchive = "files";
               string zipFileToCreate = "Archive.zip";
               using (var zip = new ZipFile())
               {
                 // set the event handler before adding any entries
                 zip.ZipError += MyZipError;
                 zip.AddDirectory(directoryToZip, directoryInArchive);
                 zip.Save(zipFileToCreate);
               }
             }
             </code>
            
             <code lang="VB">
             Private Sub MyZipError(ByVal sender As Object, ByVal e As Ionic.Zip.ZipErrorEventArgs)
                 ' At this point, the application could prompt the user for an action to take.
                 ' But in this case, this application will simply automatically skip the file, in case of error.
                 Console.WriteLine("Zip Error,  entry {0}", e.CurrentEntry.FileName)
                 Console.WriteLine("   Exception: {0}", e.exception)
                 ' set the desired ZipErrorAction on the CurrentEntry to communicate that to DotNetZip
                 e.CurrentEntry.ZipErrorAction = Zip.ZipErrorAction.Skip
             End Sub
            
             Public Sub SaveTheFile()
                 Dim directoryToZip As String = "fodder"
                 Dim directoryInArchive As String = "files"
                 Dim zipFileToCreate as String = "Archive.zip"
                 Using zipArchive As ZipFile = New ZipFile
                     ' set the event handler before adding any entries
                     AddHandler zipArchive.ZipError, AddressOf MyZipError
                     zipArchive.AddDirectory(directoryToZip, directoryInArchive)
                     zipArchive.Save(zipFileToCreate)
                 End Using
             End Sub
            
             </code>
             </example>
            
             <seealso cref="P:Ionic.Zip.ZipFile.ZipErrorAction"/>
        </member>
        <member name="M:Ionic.Zip.ZipFile.GetEnumerator">
             <summary>
             Generic IEnumerator support, for use of a ZipFile in an enumeration.
             </summary>
            
             <remarks>
             You probably do not want to call <c>GetEnumerator</c> explicitly. Instead
             it is implicitly called when you use a <see langword="foreach"/> loop in C#, or a
             <c>For Each</c> loop in VB.NET.
             </remarks>
            
             <example>
             This example reads a zipfile of a given name, then enumerates the
             entries in that zip file, and displays the information about each
             entry on the Console.
             <code>
             using (ZipFile zip = ZipFile.Read(zipfile))
             {
               bool header = true;
               foreach (ZipEntry e in zip)
               {
                 if (header)
                 {
                    System.Console.WriteLine("Zipfile: {0}", zip.Name);
                    System.Console.WriteLine("Version Needed: 0x{0:X2}", e.VersionNeeded);
                    System.Console.WriteLine("BitField: 0x{0:X2}", e.BitField);
                    System.Console.WriteLine("Compression Method: 0x{0:X2}", e.CompressionMethod);
                    System.Console.WriteLine("\n{1,-22} {2,-6} {3,4}   {4,-8}  {0}",
                                 "Filename", "Modified", "Size", "Ratio", "Packed");
                    System.Console.WriteLine(new System.String('-', 72));
                    header = false;
                 }
            
                 System.Console.WriteLine("{1,-22} {2,-6} {3,4:F0}%   {4,-8}  {0}",
                             e.FileName,
                             e.LastModified.ToString("yyyy-MM-dd HH:mm:ss"),
                             e.UncompressedSize,
                             e.CompressionRatio,
                             e.CompressedSize);
            
                 e.Extract();
               }
             }
             </code>
            
             <code lang="VB">
               Dim ZipFileToExtract As String = "c:\foo.zip"
               Using zip As ZipFile = ZipFile.Read(ZipFileToExtract)
                   Dim header As Boolean = True
                   Dim e As ZipEntry
                   For Each e In zip
                       If header Then
                           Console.WriteLine("Zipfile: {0}", zip.Name)
                           Console.WriteLine("Version Needed: 0x{0:X2}", e.VersionNeeded)
                           Console.WriteLine("BitField: 0x{0:X2}", e.BitField)
                           Console.WriteLine("Compression Method: 0x{0:X2}", e.CompressionMethod)
                           Console.WriteLine(ChrW(10) &amp; "{1,-22} {2,-6} {3,4}   {4,-8}  {0}", _
                             "Filename", "Modified", "Size", "Ratio", "Packed" )
                           Console.WriteLine(New String("-"c, 72))
                           header = False
                       End If
                       Console.WriteLine("{1,-22} {2,-6} {3,4:F0}%   {4,-8}  {0}", _
                         e.FileName, _
                         e.LastModified.ToString("yyyy-MM-dd HH:mm:ss"), _
                         e.UncompressedSize, _
                         e.CompressionRatio, _
                         e.CompressedSize )
                       e.Extract
                   Next
               End Using
             </code>
             </example>
            
             <returns>A generic enumerator suitable for use  within a foreach loop.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.GetNewEnum">
             <summary>
             An IEnumerator, for use of a ZipFile in a foreach construct.
             </summary>
            
             <remarks>
             This method is included for COM support.  An application generally does not call
             this method directly.  It is called implicitly by COM clients when enumerating
             the entries in the ZipFile instance.  In VBScript, this is done with a <c>For Each</c>
             statement.  In Javascript, this is done with <c>new Enumerator(zipfile)</c>.
             </remarks>
            
             <returns>
             The IEnumerator over the entries in the ZipFile.
             </returns>
        </member>
        <member name="T:Ionic.Zip.Zip64Option">
             <summary>
               Options for using ZIP64 extensions when saving zip archives.
             </summary>
            
             <remarks>
            
             <para>
               Designed many years ago, the <see
               href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">original zip
               specification from PKWARE</see> allowed for 32-bit quantities for the
               compressed and uncompressed sizes of zip entries, as well as a 32-bit quantity
               for specifying the length of the zip archive itself, and a maximum of 65535
               entries.  These limits are now regularly exceeded in many backup and archival
               scenarios.  Recently, PKWare added extensions to the original zip spec, called
               "ZIP64 extensions", to raise those limitations.  This property governs whether
               DotNetZip will use those extensions when writing zip archives. The use of
               these extensions is optional and explicit in DotNetZip because, despite the
               status of ZIP64 as a bona fide standard, many other zip tools and libraries do
               not support ZIP64, and therefore a zip file with ZIP64 extensions may be
               unreadable by some of those other tools.
             </para>
            
             <para>
               Set this property to <see cref="F:Ionic.Zip.Zip64Option.Always"/> to always use ZIP64
               extensions when saving, regardless of whether your zip archive needs it.
               Suppose you add 5 files, each under 100k, to a ZipFile. If you specify Always
               for this flag, you will get a ZIP64 archive, though the archive does not need
               to use ZIP64 because none of the original zip limits had been exceeded.
             </para>
            
             <para>
               Set this property to <see cref="F:Ionic.Zip.Zip64Option.Never"/> to tell the DotNetZip
               library to never use ZIP64 extensions.  This is useful for maximum
               compatibility and interoperability, at the expense of the capability of
               handling large files or large archives.  NB: Windows Explorer in Windows XP
               and Windows Vista cannot currently extract files from a zip64 archive, so if
               you want to guarantee that a zip archive produced by this library will work in
               Windows Explorer, use <c>Never</c>. If you set this property to <see
               cref="F:Ionic.Zip.Zip64Option.Never"/>, and your application creates a zip that would
               exceed one of the Zip limits, the library will throw an exception while saving
               the zip file.
             </para>
            
             <para>
               Set this property to <see cref="F:Ionic.Zip.Zip64Option.AsNecessary"/> to tell the
               DotNetZip library to use the ZIP64 extensions when required by the
               entry. After the file is compressed, the original and compressed sizes are
               checked, and if they exceed the limits described above, then zip64 can be
               used. That is the general idea, but there is an additional wrinkle when saving
               to a non-seekable device, like the ASP.NET <c>Response.OutputStream</c>, or
               <c>Console.Out</c>.  When using non-seekable streams for output, the entry
               header - which indicates whether zip64 is in use - is emitted before it is
               known if zip64 is necessary.  It is only after all entries have been saved
               that it can be known if ZIP64 will be required.  On seekable output streams,
               after saving all entries, the library can seek backward and re-emit the zip
               file header to be consistent with the actual ZIP64 requirement.  But using a
               non-seekable output stream, the library cannot seek backward, so the header
               can never be changed. In other words, the archive's use of ZIP64 extensions is
               not alterable after the header is emitted.  Therefore, when saving to
               non-seekable streams, using <see cref="F:Ionic.Zip.Zip64Option.AsNecessary"/> is the same
               as using <see cref="F:Ionic.Zip.Zip64Option.Always"/>: it will always produce a zip
               archive that uses ZIP64 extensions.
             </para>
            
             </remarks>
        </member>
        <member name="F:Ionic.Zip.Zip64Option.Default">
            <summary>
            The default behavior, which is "Never".
            (For COM clients, this is a 0 (zero).)
            </summary>
        </member>
        <member name="F:Ionic.Zip.Zip64Option.Never">
            <summary>
            Do not use ZIP64 extensions when writing zip archives.
            (For COM clients, this is a 0 (zero).)
            </summary>
        </member>
        <member name="F:Ionic.Zip.Zip64Option.AsNecessary">
            <summary>
            Use ZIP64 extensions when writing zip archives, as necessary.
            For example, when a single entry exceeds 0xFFFFFFFF in size, or when the archive as a whole
            exceeds 0xFFFFFFFF in size, or when there are more than 65535 entries in an archive.
            (For COM clients, this is a 1.)
            </summary>
        </member>
        <member name="F:Ionic.Zip.Zip64Option.Always">
            <summary>
            Always use ZIP64 extensions when writing zip archives, even when unnecessary.
            (For COM clients, this is a 2.)
            </summary>
        </member>
        <member name="T:Ionic.Zip.ZipOption">
            <summary>
             An enum representing the values on a three-way toggle switch
             for various options in the library. This might be used to
             specify whether to employ a particular text encoding, or to use
             ZIP64 extensions, or some other option.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipOption.Default">
            <summary>
            The default behavior. This is the same as "Never".
            (For COM clients, this is a 0 (zero).)
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipOption.Never">
            <summary>
            Never use the associated option.
            (For COM clients, this is a 0 (zero).)
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipOption.AsNecessary">
            <summary>
            Use the associated behavior "as necessary."
            (For COM clients, this is a 1.)
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipOption.Always">
            <summary>
            Use the associated behavior Always, whether necessary or not.
            (For COM clients, this is a 2.)
            </summary>
        </member>
        <member name="T:Ionic.Zip.ZipInputStream">
             <summary>
               Provides a stream metaphor for reading zip files.
             </summary>
            
             <remarks>
             <para>
               This class provides an alternative programming model for reading zip files to
               the one enabled by the <see cref="T:Ionic.Zip.ZipFile"/> class.  Use this when reading zip
               files, as an alternative to the <see cref="T:Ionic.Zip.ZipFile"/> class, when you would
               like to use a Stream class to read the file.
             </para>
            
             <para>
               Some application designs require a readable stream for input. This stream can
               be used to read a zip file, and extract entries.
             </para>
            
             <para>
               Both the <c>ZipInputStream</c> class and the <c>ZipFile</c> class can be used
               to read and extract zip files.  Both of them support many of the common zip
               features, including Unicode, different compression levels, and ZIP64.  The
               programming models differ. For example, when extracting entries via calls to
               the <c>GetNextEntry()</c> and <c>Read()</c> methods on the
               <c>ZipInputStream</c> class, the caller is responsible for creating the file,
               writing the bytes into the file, setting the attributes on the file, and
               setting the created, last modified, and last accessed timestamps on the
               file. All of these things are done automatically by a call to <see
               cref="M:Ionic.Zip.ZipEntry.Extract">ZipEntry.Extract()</see>.  For this reason, the
               <c>ZipInputStream</c> is generally recommended for when your application wants
               to extract the data, without storing that data into a file.
             </para>
            
             <para>
               Aside from the obvious differences in programming model, there are some
               differences in capability between the <c>ZipFile</c> class and the
               <c>ZipInputStream</c> class.
             </para>
            
             <list type="bullet">
               <item>
                 <c>ZipFile</c> can be used to create or update zip files, or read and
                 extract zip files. <c>ZipInputStream</c> can be used only to read and
                 extract zip files. If you want to use a stream to create zip files, check
                 out the <see cref="T:Ionic.Zip.ZipOutputStream"/>.
               </item>
            
               <item>
                 <c>ZipInputStream</c> cannot read segmented or spanned
                 zip files.
               </item>
            
               <item>
                 <c>ZipInputStream</c> will not read Zip file comments.
               </item>
            
               <item>
                 When reading larger files, <c>ZipInputStream</c> will always underperform
                 <c>ZipFile</c>. This is because the <c>ZipInputStream</c> does a full scan on the
                 zip file, while the <c>ZipFile</c> class reads the central directory of the
                 zip file.
               </item>
            
             </list>
            
             </remarks>
        </member>
        <member name="M:Ionic.Zip.ZipInputStream.#ctor(System.IO.Stream)">
             <summary>
               Create a <c>ZipInputStream</c>, wrapping it around an existing stream.
             </summary>
            
             <remarks>
            
             <para>
               While the <see cref="T:Ionic.Zip.ZipFile"/> class is generally easier
               to use, this class provides an alternative to those
               applications that want to read from a zipfile directly,
               using a <see cref="T:System.IO.Stream"/>.
             </para>
            
             <para>
               Both the <c>ZipInputStream</c> class and the <c>ZipFile</c> class can be used
               to read and extract zip files.  Both of them support many of the common zip
               features, including Unicode, different compression levels, and ZIP64.  The
               programming models differ. For example, when extracting entries via calls to
               the <c>GetNextEntry()</c> and <c>Read()</c> methods on the
               <c>ZipInputStream</c> class, the caller is responsible for creating the file,
               writing the bytes into the file, setting the attributes on the file, and
               setting the created, last modified, and last accessed timestamps on the
               file. All of these things are done automatically by a call to <see
               cref="M:Ionic.Zip.ZipEntry.Extract">ZipEntry.Extract()</see>.  For this reason, the
               <c>ZipInputStream</c> is generally recommended for when your application wants
               to extract the data, without storing that data into a file.
             </para>
            
             <para>
               Aside from the obvious differences in programming model, there are some
               differences in capability between the <c>ZipFile</c> class and the
               <c>ZipInputStream</c> class.
             </para>
            
             <list type="bullet">
               <item>
               <c>ZipFile</c> can be used to create or update zip files, or read and extract
               zip files. <c>ZipInputStream</c> can be used only to read and extract zip
                 files. If you want to use a stream to create zip files, check out the <see
                 cref="T:Ionic.Zip.ZipOutputStream"/>.
               </item>
            
               <item>
                 <c>ZipInputStream</c> cannot read segmented or spanned
                 zip files.
               </item>
            
               <item>
                 <c>ZipInputStream</c> will not read Zip file comments.
               </item>
            
               <item>
                 When reading larger files, <c>ZipInputStream</c> will always underperform
                 <c>ZipFile</c>. This is because the <c>ZipInputStream</c> does a full scan on the
                 zip file, while the <c>ZipFile</c> class reads the central directory of the
                 zip file.
               </item>
            
             </list>
            
             </remarks>
            
             <param name="stream">
               The stream to read. It must be readable. This stream will be closed at
               the time the <c>ZipInputStream</c> is closed.
             </param>
            
             <example>
            
               This example shows how to read a zip file, and extract entries, using the
               <c>ZipInputStream</c> class.
            
             <code lang="C#">
             private void Unzip()
             {
                 byte[] buffer= new byte[2048];
                 int n;
                 using (var raw = File.Open(inputFileName, FileMode.Open, FileAccess.Read))
                 {
                     using (var input= new ZipInputStream(raw))
                     {
                         ZipEntry e;
                         while (( e = input.GetNextEntry()) != null)
                         {
                             if (e.IsDirectory) continue;
                             string outputPath = Path.Combine(extractDir, e.FileName);
                             using (var output = File.Open(outputPath, FileMode.Create, FileAccess.ReadWrite))
                             {
                                 while ((n= input.Read(buffer, 0, buffer.Length)) > 0)
                                 {
                                     output.Write(buffer,0,n);
                                 }
                             }
                         }
                     }
                 }
             }
             </code>
            
             <code lang="VB">
             Private Sub UnZip()
                 Dim inputFileName As String = "MyArchive.zip"
                 Dim extractDir As String = "extract"
                 Dim buffer As Byte() = New Byte(2048) {}
                 Using raw As FileStream = File.Open(inputFileName, FileMode.Open, FileAccess.Read)
                     Using input As ZipInputStream = New ZipInputStream(raw)
                         Dim e As ZipEntry
                         Do While (Not e = input.GetNextEntry Is Nothing)
                             If Not e.IsDirectory Then
                                 Using output As FileStream = File.Open(Path.Combine(extractDir, e.FileName), _
                                                                        FileMode.Create, FileAccess.ReadWrite)
                                     Dim n As Integer
                                     Do While (n = input.Read(buffer, 0, buffer.Length) > 0)
                                         output.Write(buffer, 0, n)
                                     Loop
                                 End Using
                             End If
                         Loop
                     End Using
                 End Using
             End Sub
             </code>
             </example>
        </member>
        <member name="M:Ionic.Zip.ZipInputStream.#ctor(System.String)">
             <summary>
               Create a <c>ZipInputStream</c>, given the name of an existing zip file.
             </summary>
            
             <remarks>
            
             <para>
               This constructor opens a <c>FileStream</c> for the given zipfile, and
               wraps a <c>ZipInputStream</c> around that.  See the documentation for the
               <see cref="M:Ionic.Zip.ZipInputStream.#ctor(System.IO.Stream)"/> constructor for full details.
             </para>
            
             <para>
               While the <see cref="T:Ionic.Zip.ZipFile"/> class is generally easier
               to use, this class provides an alternative to those
               applications that want to read from a zipfile directly,
               using a <see cref="T:System.IO.Stream"/>.
             </para>
            
             </remarks>
            
             <param name="fileName">
               The name of the filesystem file to read.
             </param>
            
             <example>
            
               This example shows how to read a zip file, and extract entries, using the
               <c>ZipInputStream</c> class.
            
             <code lang="C#">
             private void Unzip()
             {
                 byte[] buffer= new byte[2048];
                 int n;
                 using (var input= new ZipInputStream(inputFileName))
                 {
                     ZipEntry e;
                     while (( e = input.GetNextEntry()) != null)
                     {
                         if (e.IsDirectory) continue;
                         string outputPath = Path.Combine(extractDir, e.FileName);
                         using (var output = File.Open(outputPath, FileMode.Create, FileAccess.ReadWrite))
                         {
                             while ((n= input.Read(buffer, 0, buffer.Length)) > 0)
                             {
                                 output.Write(buffer,0,n);
                             }
                         }
                     }
                 }
             }
             </code>
            
             <code lang="VB">
             Private Sub UnZip()
                 Dim inputFileName As String = "MyArchive.zip"
                 Dim extractDir As String = "extract"
                 Dim buffer As Byte() = New Byte(2048) {}
                 Using input As ZipInputStream = New ZipInputStream(inputFileName)
                     Dim e As ZipEntry
                     Do While (Not e = input.GetNextEntry Is Nothing)
                         If Not e.IsDirectory Then
                             Using output As FileStream = File.Open(Path.Combine(extractDir, e.FileName), _
                                                                    FileMode.Create, FileAccess.ReadWrite)
                                 Dim n As Integer
                                 Do While (n = input.Read(buffer, 0, buffer.Length) > 0)
                                     output.Write(buffer, 0, n)
                                 Loop
                             End Using
                         End If
                     Loop
                 End Using
             End Sub
             </code>
             </example>
        </member>
        <member name="M:Ionic.Zip.ZipInputStream.#ctor(System.IO.Stream,System.Boolean)">
             <summary>
               Create a <c>ZipInputStream</c>, explicitly specifying whether to
               keep the underlying stream open.
             </summary>
            
             <remarks>
               See the documentation for the <see
               cref="M:Ionic.Zip.ZipInputStream.#ctor(System.IO.Stream)">ZipInputStream(Stream)</see>
               constructor for a discussion of the class, and an example of how to use the class.
             </remarks>
            
             <param name="stream">
               The stream to read from. It must be readable.
             </param>
            
             <param name="leaveOpen">
               true if the application would like the stream
               to remain open after the <c>ZipInputStream</c> has been closed.
             </param>
        </member>
        <member name="M:Ionic.Zip.ZipInputStream.ToString">
            <summary>Provides a string representation of the instance.</summary>
            <remarks>
              <para>
                This can be useful for debugging purposes.
              </para>
            </remarks>
            <returns>a string representation of the instance.</returns>
        </member>
        <member name="P:Ionic.Zip.ZipInputStream.ProvisionalAlternateEncoding">
             <summary>
               The text encoding to use when reading entries into the zip archive, for
               those entries whose filenames or comments cannot be encoded with the
               default (IBM437) encoding.
             </summary>
            
             <remarks>
             <para>
               In <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">its
               zip specification</see>, PKWare describes two options for encoding
               filenames and comments: using IBM437 or UTF-8.  But, some archiving tools
               or libraries do not follow the specification, and instead encode
               characters using the system default code page.  For example, WinRAR when
               run on a machine in Shanghai may encode filenames with the Big-5 Chinese
               (950) code page.  This behavior is contrary to the Zip specification, but
               it occurs anyway.
             </para>
            
             <para>
               When using DotNetZip to read zip archives that use something other than
               UTF-8 or IBM437, set this property to specify the code page to use when
               reading encoded filenames and comments for each <c>ZipEntry</c> in the zip
               file.
             </para>
            
             <para>
               This property is "provisional". When the entry in the zip archive is not
               explicitly marked as using UTF-8, then IBM437 is used to decode filenames
               and comments. If a loss of data would result from using IBM436 -
               specifically when encoding and decoding is not reflexive - the codepage
               specified here is used. It is possible, therefore, to have a given entry
               with a <c>Comment</c> encoded in IBM437 and a <c>FileName</c> encoded with
               the specified "provisional" codepage.
             </para>
            
             <para>
               When a zip file uses an arbitrary, non-UTF8 code page for encoding, there
               is no standard way for the reader application - whether DotNetZip, WinZip,
               WinRar, or something else - to know which codepage has been used for the
               entries. Readers of zip files are not able to inspect the zip file and
               determine the codepage that was used for the entries contained within it.
               It is left to the application or user to determine the necessary codepage
               when reading zip files encoded this way.  If you use an incorrect codepage
               when reading a zipfile, you will get entries with filenames that are
               incorrect, and the incorrect filenames may even contain characters that
               are not legal for use within filenames in Windows. Extracting entries with
               illegal characters in the filenames will lead to exceptions. It's too bad,
               but this is just the way things are with code pages in zip files. Caveat
               Emptor.
             </para>
            
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipInputStream.CodecBufferSize">
             <summary>
               Size of the work buffer to use for the ZLIB codec during decompression.
             </summary>
            
             <remarks>
               Setting this affects the performance and memory efficiency of compression
               and decompression.  For larger files, setting this to a larger size may
               improve performance, but the exact numbers vary depending on available
               memory, and a bunch of other variables. I don't have good firm
               recommendations on how to set it.  You'll have to test it yourself. Or
               just leave it alone and accept the default.
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipInputStream.Password">
             <summary>
               Sets the password to be used on the <c>ZipInputStream</c> instance.
             </summary>
            
             <remarks>
            
             <para>
               When reading a zip archive, this password is used to read and decrypt the
               entries that are encrypted within the zip file. When entries within a zip
               file use different passwords, set the appropriate password for the entry
               before the first call to <c>Read()</c> for each entry.
             </para>
            
             <para>
               When reading an entry that is not encrypted, the value of this property is
               ignored.
             </para>
            
             </remarks>
            
             <example>
            
               This example uses the ZipInputStream to read and extract entries from a
               zip file, using a potentially different password for each entry.
            
             <code lang="C#">
             byte[] buffer= new byte[2048];
             int n;
             using (var raw = File.Open(_inputFileName, FileMode.Open, FileAccess.Read ))
             {
                 using (var input= new ZipInputStream(raw))
                 {
                     ZipEntry e;
                     while (( e = input.GetNextEntry()) != null)
                     {
                         input.Password = PasswordForEntry(e.FileName);
                         if (e.IsDirectory) continue;
                         string outputPath = Path.Combine(_extractDir, e.FileName);
                         using (var output = File.Open(outputPath, FileMode.Create, FileAccess.ReadWrite))
                         {
                             while ((n= input.Read(buffer,0,buffer.Length)) > 0)
                             {
                                 output.Write(buffer,0,n);
                             }
                         }
                     }
                 }
             }
            
             </code>
             </example>
        </member>
        <member name="M:Ionic.Zip.ZipInputStream.Read(System.Byte[],System.Int32,System.Int32)">
             <summary>
               Read the data from the stream into the buffer.
             </summary>
            
             <remarks>
             <para>
               The data for the zipentry will be decrypted and uncompressed, as
               necessary, before being copied into the buffer.
             </para>
            
             <para>
               You must set the <see cref="P:Ionic.Zip.ZipInputStream.Password"/> property before calling
               <c>Read()</c> the first time for an encrypted entry.  To determine if an
               entry is encrypted and requires a password, check the <see
               cref="P:Ionic.Zip.ZipEntry.Encryption">ZipEntry.Encryption</see> property.
             </para>
             </remarks>
            
             <param name="buffer">The buffer to hold the data read from the stream.</param>
             <param name="offset">the offset within the buffer to copy the first byte read.</param>
             <param name="count">the number of bytes to read.</param>
             <returns>the number of bytes read, after decryption and decompression.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipInputStream.GetNextEntry">
             <summary>
               Read the next entry from the zip file.
             </summary>
            
             <remarks>
             <para>
               Call this method just before calling <see cref="M:Ionic.Zip.ZipInputStream.Read(System.Byte[],System.Int32,System.Int32)"/>,
               to position the pointer in the zip file to the next entry that can be
               read.  Subsequent calls to <c>Read()</c>, will decrypt and decompress the
               data in the zip file, until <c>Read()</c> returns 0.
             </para>
            
             <para>
               Each time you call <c>GetNextEntry()</c>, the pointer in the wrapped
               stream is moved to the next entry in the zip file.  If you call <see
               cref="M:Ionic.Zip.ZipInputStream.Seek(System.Int64,System.IO.SeekOrigin)"/>, and thus re-position the pointer within
               the file, you will need to call <c>GetNextEntry()</c> again, to insure
               that the file pointer is positioned at the beginning of a zip entry.
             </para>
            
             <para>
               This method returns the <c>ZipEntry</c>. Using a stream approach, you will
               read the raw bytes for an entry in a zip file via calls to <c>Read()</c>.
               Alternatively, you can extract an entry into a file, or a stream, by
               calling <see cref="M:Ionic.Zip.ZipEntry.Extract"/>, or one of its siblings.
             </para>
            
             </remarks>
            
             <returns>
               The <c>ZipEntry</c> read. Returns null (or Nothing in VB) if there are no more
               entries in the zip file.
             </returns>
            
        </member>
        <member name="M:Ionic.Zip.ZipInputStream.Dispose(System.Boolean)">
             <summary>
               Dispose the stream.
             </summary>
            
             <remarks>
             <para>
               This method disposes the ZipInputStream.  It may also close the
               underlying stream, depending on which constructor was used.
             </para>
            
             <para>
               Typically the application will call <c>Dispose()</c> implicitly, via
               a <c>using</c> statement in C#, or a <c>Using</c> statement in VB.
             </para>
            
               <para>
                 Application code won't call this code directly.  This method may
                 be invoked in two distinct scenarios.  If disposing == true, the
                 method has been called directly or indirectly by a user's code,
                 for example via the public Dispose() method. In this case, both
                 managed and unmanaged resources can be referenced and disposed.
                 If disposing == false, the method has been called by the runtime
                 from inside the object finalizer and this method should not
                 reference other objects; in that case only unmanaged resources
                 must be referenced or disposed.
               </para>
             </remarks>
            
             <param name="disposing">
               true if the Dispose method was invoked by user code.
             </param>
        </member>
        <member name="P:Ionic.Zip.ZipInputStream.CanRead">
            <summary>
            Always returns true.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipInputStream.CanSeek">
            <summary>
            Returns the value of <c>CanSeek</c> for the underlying (wrapped) stream.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipInputStream.CanWrite">
            <summary>
            Always returns false.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipInputStream.Length">
            <summary>
            Returns the length of the underlying stream.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipInputStream.Position">
            <summary>
            Gets or sets the position of the underlying stream.
            </summary>
            <remarks>
            Setting the position is equivalent to calling <c>Seek(value, SeekOrigin.Begin)</c>.
            </remarks>
        </member>
        <member name="M:Ionic.Zip.ZipInputStream.Flush">
            <summary>
            This is a no-op.
            </summary>
        </member>
        <member name="M:Ionic.Zip.ZipInputStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            This method always throws a NotSupportedException.
            </summary>
            <param name="buffer">ignored</param>
            <param name="offset">ignored</param>
            <param name="count">ignored</param>
        </member>
        <member name="M:Ionic.Zip.ZipInputStream.Seek(System.Int64,System.IO.SeekOrigin)">
             <summary>
               This method seeks in the underlying stream.
             </summary>
            
             <remarks>
             <para>
               Call this method if you want to seek around within the zip file for random access.
             </para>
            
             <para>
               Applications can intermix calls to <c>Seek()</c> with calls to <see
               cref="M:Ionic.Zip.ZipInputStream.GetNextEntry"/>.  After a call to <c>Seek()</c>,
               <c>GetNextEntry()</c> will get the next <c>ZipEntry</c> that falls after
               the current position in the input stream. You're on your own for finding
               out just where to seek in the stream, to get to the various entries.
             </para>
            
             </remarks>
            
             <param name="offset">the offset point to seek to</param>
             <param name="origin">the reference point from which to seek</param>
             <returns>The new position</returns>
        </member>
        <member name="M:Ionic.Zip.ZipInputStream.SetLength(System.Int64)">
            <summary>
            This method always throws a NotSupportedException.
            </summary>
            <param name="value">ignored</param>
        </member>
        <member name="T:Ionic.Zip.ZipOutputStream">
             <summary>
               Provides a stream metaphor for generating zip files.
             </summary>
            
             <remarks>
             <para>
               This class writes zip files, as defined in the <see
               href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">specification
               for zip files described by PKWare</see>.  The compression for this
               implementation is provided by a managed-code version of Zlib, included with
               DotNetZip in the classes in the Ionic.Zlib namespace.
             </para>
            
             <para>
               This class provides an alternative programming model to the one enabled by the
               <see cref="T:Ionic.Zip.ZipFile"/> class. Use this when creating zip files, as an
               alternative to the <see cref="T:Ionic.Zip.ZipFile"/> class, when you would like to use a
               <c>Stream</c> type to write the zip file.
             </para>
            
             <para>
               Both the <c>ZipOutputStream</c> class and the <c>ZipFile</c> class can be used
               to create zip files. Both of them support many of the common zip features,
               including Unicode, different compression levels, and ZIP64.   They provide
               very similar performance when creating zip files.
             </para>
            
             <para>
               The <c>ZipFile</c> class is generally easier to use than
               <c>ZipOutputStream</c> and should be considered a higher-level interface.  For
               example, when creating a zip file via calls to the <c>PutNextEntry()</c> and
               <c>Write()</c> methods on the <c>ZipOutputStream</c> class, the caller is
               responsible for opening the file, reading the bytes from the file, writing
               those bytes into the <c>ZipOutputStream</c>, setting the attributes on the
               <c>ZipEntry</c>, and setting the created, last modified, and last accessed
               timestamps on the zip entry. All of these things are done automatically by a
               call to <see cref="M:Ionic.Zip.ZipFile.AddFile(System.String,System.String)">ZipFile.AddFile()</see>.
               For this reason, the <c>ZipOutputStream</c> is generally recommended for use
               only when your application emits arbitrary data, not necessarily data from a
               filesystem file, directly into a zip file, and does so using a <c>Stream</c>
               metaphor.
             </para>
            
             <para>
               Aside from the differences in programming model, there are other
               differences in capability between the two classes.
             </para>
            
             <list type="bullet">
               <item>
                 <c>ZipFile</c> can be used to read and extract zip files, in addition to
                 creating zip files. <c>ZipOutputStream</c> cannot read zip files. If you want
                 to use a stream to read zip files, check out the <see cref="T:Ionic.Zip.ZipInputStream"/> class.
               </item>
            
               <item>
                 <c>ZipOutputStream</c> does not support the creation of segmented or spanned
                 zip files.
               </item>
            
               <item>
                 <c>ZipOutputStream</c> cannot produce a self-extracting archive.
               </item>
             </list>
            
             <para>
               Be aware that the <c>ZipOutputStream</c> class implements the <see
               cref="T:System.IDisposable"/> interface.  In order for
               <c>ZipOutputStream</c> to produce a valid zip file, you use use it within
               a using clause (<c>Using</c> in VB), or call the <c>Dispose()</c> method
               explicitly.  See the examples for how to employ a using clause.
             </para>
            
             <para>
               Also, a note regarding compression performance: On the desktop .NET
               Framework, DotNetZip can use a multi-threaded compression implementation
               that provides significant speed increases on large files, over 300k or so,
               at the cost of increased memory use at runtime.  (The output of the
               compression is almost exactly the same size).  But, the multi-threaded
               approach incurs a performance hit on smaller files. There's no way for the
               ZipOutputStream to know whether parallel compression will be beneficial,
               because the ZipOutputStream does not know how much data you will write
               through the stream.  You may wish to set the <see
               cref="P:Ionic.Zip.ZipOutputStream.ParallelDeflateThreshold"/> property to zero, if you are compressing
               large files through <c>ZipOutputStream</c>.  This will cause parallel
               compression to be used, always.
             </para>
             </remarks>
        </member>
        <member name="M:Ionic.Zip.ZipOutputStream.#ctor(System.IO.Stream)">
             <summary>
               Create a ZipOutputStream, wrapping an existing stream.
             </summary>
            
             <remarks>
             <para>
               The <see cref="T:Ionic.Zip.ZipFile"/> class is generally easier to use when creating
               zip files. The ZipOutputStream offers a different metaphor for creating a
               zip file, based on the <see cref="T:System.IO.Stream"/> class.
             </para>
            
             </remarks>
            
             <param name="stream">
             The stream to wrap. It must be writable. This stream will be closed at
             the time the ZipOutputStream is closed.
             </param>
            
             <example>
            
               This example shows how to create a zip file, using the
               ZipOutputStream class.
            
             <code lang="C#">
             private void Zipup()
             {
                 if (filesToZip.Count == 0)
                 {
                     System.Console.WriteLine("Nothing to do.");
                     return;
                 }
            
                 using (var raw = File.Open(_outputFileName, FileMode.Create, FileAccess.ReadWrite ))
                 {
                     using (var output= new ZipOutputStream(raw))
                     {
                         output.Password = "VerySecret!";
                         output.Encryption = EncryptionAlgorithm.WinZipAes256;
            
                         foreach (string inputFileName in filesToZip)
                         {
                             System.Console.WriteLine("file: {0}", inputFileName);
            
                             output.PutNextEntry(inputFileName);
                             using (var input = File.Open(inputFileName, FileMode.Open, FileAccess.Read, FileShare.Read | FileShare.Write ))
                             {
                                 byte[] buffer= new byte[2048];
                                 int n;
                                 while ((n= input.Read(buffer,0,buffer.Length)) > 0)
                                 {
                                     output.Write(buffer,0,n);
                                 }
                             }
                         }
                     }
                 }
             }
             </code>
            
             <code lang="VB">
             Private Sub Zipup()
                 Dim outputFileName As String = "XmlData.zip"
                 Dim filesToZip As String() = Directory.GetFiles(".", "*.xml")
                 If (filesToZip.Length = 0) Then
                     Console.WriteLine("Nothing to do.")
                 Else
                     Using raw As FileStream = File.Open(outputFileName, FileMode.Create, FileAccess.ReadWrite)
                         Using output As ZipOutputStream = New ZipOutputStream(raw)
                             output.Password = "VerySecret!"
                             output.Encryption = EncryptionAlgorithm.WinZipAes256
                             Dim inputFileName As String
                             For Each inputFileName In filesToZip
                                 Console.WriteLine("file: {0}", inputFileName)
                                 output.PutNextEntry(inputFileName)
                                 Using input As FileStream = File.Open(inputFileName, FileMode.Open, FileAccess.Read, FileShare.ReadWrite)
                                     Dim n As Integer
                                     Dim buffer As Byte() = New Byte(2048) {}
                                     Do While (n = input.Read(buffer, 0, buffer.Length) > 0)
                                         output.Write(buffer, 0, n)
                                     Loop
                                 End Using
                             Next
                         End Using
                     End Using
                 End If
             End Sub
             </code>
             </example>
        </member>
        <member name="M:Ionic.Zip.ZipOutputStream.#ctor(System.String)">
             <summary>
               Create a ZipOutputStream that writes to a filesystem file.
             </summary>
            
             <remarks>
               The <see cref="T:Ionic.Zip.ZipFile"/> class is generally easier to use when creating
               zip files. The ZipOutputStream offers a different metaphor for creating a
               zip file, based on the <see cref="T:System.IO.Stream"/> class.
             </remarks>
            
             <param name="fileName">
               The name of the zip file to create.
             </param>
            
             <example>
            
               This example shows how to create a zip file, using the
               ZipOutputStream class.
            
             <code lang="C#">
             private void Zipup()
             {
                 if (filesToZip.Count == 0)
                 {
                     System.Console.WriteLine("Nothing to do.");
                     return;
                 }
            
                 using (var output= new ZipOutputStream(outputFileName))
                 {
                     output.Password = "VerySecret!";
                     output.Encryption = EncryptionAlgorithm.WinZipAes256;
            
                     foreach (string inputFileName in filesToZip)
                     {
                         System.Console.WriteLine("file: {0}", inputFileName);
            
                         output.PutNextEntry(inputFileName);
                         using (var input = File.Open(inputFileName, FileMode.Open, FileAccess.Read,
                                                      FileShare.Read | FileShare.Write ))
                         {
                             byte[] buffer= new byte[2048];
                             int n;
                             while ((n= input.Read(buffer,0,buffer.Length)) > 0)
                             {
                                 output.Write(buffer,0,n);
                             }
                         }
                     }
                 }
             }
             </code>
            
             <code lang="VB">
             Private Sub Zipup()
                 Dim outputFileName As String = "XmlData.zip"
                 Dim filesToZip As String() = Directory.GetFiles(".", "*.xml")
                 If (filesToZip.Length = 0) Then
                     Console.WriteLine("Nothing to do.")
                 Else
                     Using output As ZipOutputStream = New ZipOutputStream(outputFileName)
                         output.Password = "VerySecret!"
                         output.Encryption = EncryptionAlgorithm.WinZipAes256
                         Dim inputFileName As String
                         For Each inputFileName In filesToZip
                             Console.WriteLine("file: {0}", inputFileName)
                             output.PutNextEntry(inputFileName)
                             Using input As FileStream = File.Open(inputFileName, FileMode.Open, FileAccess.Read, FileShare.ReadWrite)
                                 Dim n As Integer
                                 Dim buffer As Byte() = New Byte(2048) {}
                                 Do While (n = input.Read(buffer, 0, buffer.Length) > 0)
                                     output.Write(buffer, 0, n)
                                 Loop
                             End Using
                         Next
                     End Using
                 End If
             End Sub
             </code>
             </example>
        </member>
        <member name="M:Ionic.Zip.ZipOutputStream.#ctor(System.IO.Stream,System.Boolean)">
             <summary>
               Create a ZipOutputStream.
             </summary>
            
             <remarks>
               See the documentation for the <see
               cref="M:Ionic.Zip.ZipOutputStream.#ctor(System.IO.Stream)">ZipOutputStream(Stream)</see>
               constructor for an example.
             </remarks>
            
             <param name="stream">
               The stream to wrap. It must be writable.
             </param>
            
             <param name="leaveOpen">
               true if the application would like the stream
               to remain open after the <c>ZipOutputStream</c> has been closed.
             </param>
        </member>
        <member name="M:Ionic.Zip.ZipOutputStream.ToString">
            <summary>Provides a string representation of the instance.</summary>
            <remarks>
              <para>
                This can be useful for debugging purposes.
              </para>
            </remarks>
            <returns>a string representation of the instance.</returns>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.Password">
             <summary>
               Sets the password to be used on the <c>ZipOutputStream</c> instance.
             </summary>
            
             <remarks>
            
             <para>
               When writing a zip archive, this password is applied to the entries, not
               to the zip archive itself. It applies to any <c>ZipEntry</c> subsequently
               written to the <c>ZipOutputStream</c>.
             </para>
            
             <para>
               Using a password does not encrypt or protect the "directory" of the
               archive - the list of entries contained in the archive.  If you set the
               <c>Password</c> property, the password actually applies to individual
               entries that are added to the archive, subsequent to the setting of this
               property.  The list of filenames in the archive that is eventually created
               will appear in clear text, but the contents of the individual files are
               encrypted.  This is how Zip encryption works.
             </para>
            
             <para>
               If you set this property, and then add a set of entries to the archive via
               calls to <c>PutNextEntry</c>, then each entry is encrypted with that
               password.  You may also want to change the password between adding
               different entries. If you set the password, add an entry, then set the
               password to <c>null</c> (<c>Nothing</c> in VB), and add another entry, the
               first entry is encrypted and the second is not.
             </para>
            
             <para>
               When setting the <c>Password</c>, you may also want to explicitly set the <see
               cref="P:Ionic.Zip.ZipOutputStream.Encryption"/> property, to specify how to encrypt the entries added
               to the ZipFile.  If you set the <c>Password</c> to a non-null value and do not
               set <see cref="P:Ionic.Zip.ZipOutputStream.Encryption"/>, then PKZip 2.0 ("Weak") encryption is used.
               This encryption is relatively weak but is very interoperable. If
               you set the password to a <c>null</c> value (<c>Nothing</c> in VB),
               <c>Encryption</c> is reset to None.
             </para>
            
             <para>
               Special case: if you wrap a ZipOutputStream around a non-seekable stream,
               and use encryption, and emit an entry of zero bytes, the <c>Close()</c> or
               <c>PutNextEntry()</c> following the entry will throw an exception.
             </para>
            
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.Encryption">
             <summary>
               The Encryption to use for entries added to the <c>ZipOutputStream</c>.
             </summary>
            
             <remarks>
             <para>
               The specified Encryption is applied to the entries subsequently
               written to the <c>ZipOutputStream</c> instance.
             </para>
            
             <para>
               If you set this to something other than
               EncryptionAlgorithm.None, you will also need to set the
               <see cref="P:Ionic.Zip.ZipOutputStream.Password"/> to a non-null, non-empty value in
               order to actually get encryption on the entry.
             </para>
            
             </remarks>
            
             <seealso cref="P:Ionic.Zip.ZipOutputStream.Password">ZipOutputStream.Password</seealso>
             <seealso cref="P:Ionic.Zip.ZipEntry.Encryption">ZipEntry.Encryption</seealso>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.CodecBufferSize">
             <summary>
               Size of the work buffer to use for the ZLIB codec during compression.
             </summary>
            
             <remarks>
               Setting this may affect performance.  For larger files, setting this to a
               larger size may improve performance, but I'm not sure.  Sorry, I don't
               currently have good recommendations on how to set it.  You can test it if
               you like.
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.Strategy">
             <summary>
               The compression strategy to use for all entries.
             </summary>
            
             <remarks>
               Set the Strategy used by the ZLIB-compatible compressor, when compressing
               data for the entries in the zip archive. Different compression strategies
               work better on different sorts of data. The strategy parameter can affect
               the compression ratio and the speed of compression but not the correctness
               of the compresssion.  For more information see <see
               cref="T:Ionic.Zlib.CompressionStrategy"/>.
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.Timestamp">
             <summary>
               The type of timestamp attached to the ZipEntry.
             </summary>
            
             <remarks>
               Set this in order to specify the kind of timestamp that should be emitted
               into the zip file for each entry.
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.CompressionLevel">
             <summary>
               Sets the compression level to be used for entries subsequently added to
               the zip archive.
             </summary>
            
             <remarks>
              <para>
                Varying the compression level used on entries can affect the
                size-vs-speed tradeoff when compression and decompressing data streams
                or files.
              </para>
            
              <para>
                As with some other properties on the <c>ZipOutputStream</c> class, like <see
                cref="P:Ionic.Zip.ZipOutputStream.Password"/>, and <see cref="P:Ionic.Zip.ZipOutputStream.Encryption"/>,
                setting this property on a <c>ZipOutputStream</c>
                instance will cause the specified <c>CompressionLevel</c> to be used on all
                <see cref="T:Ionic.Zip.ZipEntry"/> items that are subsequently added to the
                <c>ZipOutputStream</c> instance.
              </para>
            
              <para>
                If you do not set this property, the default compression level is used,
                which normally gives a good balance of compression efficiency and
                compression speed.  In some tests, using <c>BestCompression</c> can
                double the time it takes to compress, while delivering just a small
                increase in compression efficiency.  This behavior will vary with the
                type of data you compress.  If you are in doubt, just leave this setting
                alone, and accept the default.
              </para>
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.CompressionMethod">
            <summary>
              The compression method used on each entry added to the ZipOutputStream.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.Comment">
             <summary>
               A comment attached to the zip archive.
             </summary>
            
             <remarks>
            
             <para>
               The application sets this property to specify a comment to be embedded
               into the generated zip archive.
             </para>
            
             <para>
               According to <see
               href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">PKWARE's
               zip specification</see>, the comment is not encrypted, even if there is a
               password set on the zip file.
             </para>
            
             <para>
               The specification does not describe how to indicate the encoding used
               on a comment string. Many "compliant" zip tools and libraries use
               IBM437 as the code page for comments; DotNetZip, too, follows that
               practice.  On the other hand, there are situations where you want a
               Comment to be encoded with something else, for example using code page
               950 "Big-5 Chinese". To fill that need, DotNetZip will encode the
               comment following the same procedure it follows for encoding
               filenames: (a) if <see cref="P:Ionic.Zip.ZipOutputStream.AlternateEncodingUsage"/> is
               <c>Never</c>, it uses the default encoding (IBM437). (b) if <see
               cref="P:Ionic.Zip.ZipOutputStream.AlternateEncodingUsage"/> is <c>Always</c>, it always uses the
               alternate encoding (<see cref="P:Ionic.Zip.ZipOutputStream.AlternateEncoding"/>). (c) if <see
               cref="P:Ionic.Zip.ZipOutputStream.AlternateEncodingUsage"/> is <c>AsNecessary</c>, it uses the
               alternate encoding only if the default encoding is not sufficient for
               encoding the comment - in other words if decoding the result does not
               produce the original string.  This decision is taken at the time of
               the call to <c>ZipFile.Save()</c>.
             </para>
            
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.EnableZip64">
             <summary>
               Specify whether to use ZIP64 extensions when saving a zip archive.
             </summary>
            
             <remarks>
             <para>
               The default value for the property is <see
               cref="F:Ionic.Zip.Zip64Option.Never"/>. <see cref="F:Ionic.Zip.Zip64Option.AsNecessary"/> is
               safest, in the sense that you will not get an Exception if a
               pre-ZIP64 limit is exceeded.
             </para>
            
             <para>
               You must set this property before calling <c>Write()</c>.
             </para>
            
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.OutputUsedZip64">
             <summary>
               Indicates whether ZIP64 extensions were used when saving the zip archive.
             </summary>
            
             <remarks>
               The value is defined only after the <c>ZipOutputStream</c> has been closed.
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.IgnoreCase">
             <summary>
               Whether the ZipOutputStream should use case-insensitive comparisons when
               checking for uniqueness of zip entries.
             </summary>
            
             <remarks>
               <para>
               Though the zip specification doesn't prohibit zipfiles with duplicate
               entries, Sane zip files have no duplicates, and the DotNetZip library
               cannot create zip files with duplicate entries. If an application attempts
               to call <see cref="M:Ionic.Zip.ZipOutputStream.PutNextEntry(System.String)"/> with a name that duplicates one
               already used within the archive, the library will throw an Exception.
               </para>
               <para>
               This property allows the application to specify whether the
               ZipOutputStream instance considers ordinal case when checking for
               uniqueness of zip entries.
               </para>
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.UseUnicodeAsNecessary">
             <summary>
               Indicates whether to encode entry filenames and entry comments using
               Unicode (UTF-8).
             </summary>
            
             <remarks>
             <para>
               <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">The
               PKWare zip specification</see> provides for encoding file names and file
               comments in either the IBM437 code page, or in UTF-8.  This flag selects
               the encoding according to that specification.  By default, this flag is
               false, and filenames and comments are encoded into the zip file in the
               IBM437 codepage.  Setting this flag to true will specify that filenames
               and comments that cannot be encoded with IBM437 will be encoded with
               UTF-8.
             </para>
            
             <para>
               Zip files created with strict adherence to the PKWare specification with
               respect to UTF-8 encoding can contain entries with filenames containing
               any combination of Unicode characters, including the full range of
               characters from Chinese, Latin, Hebrew, Greek, Cyrillic, and many other
               alphabets.  However, because at this time, the UTF-8 portion of the PKWare
               specification is not broadly supported by other zip libraries and
               utilities, such zip files may not be readable by your favorite zip tool or
               archiver. In other words, interoperability will decrease if you set this
               flag to true.
             </para>
            
             <para>
               In particular, Zip files created with strict adherence to the PKWare
               specification with respect to UTF-8 encoding will not work well with
               Explorer in Windows XP or Windows Vista, because Windows compressed
               folders, as far as I know, do not support UTF-8 in zip files.  Vista can
               read the zip files, but shows the filenames incorrectly. Unpacking from
               Windows Vista Explorer will result in filenames that have rubbish
               characters in place of the high-order UTF-8 bytes.
             </para>
            
             <para>
               Also, zip files that use UTF-8 encoding will not work well with Java
               applications that use the java.util.zip classes, as of v5.0 of the Java
               runtime. The Java runtime does not correctly implement the PKWare
               specification in this regard.
             </para>
            
             <para>
               As a result, we have the unfortunate situation that "correct" behavior by
               the DotNetZip library with regard to Unicode encoding of filenames during
               zip creation will result in zip files that are readable by strictly
               compliant and current tools (for example the most recent release of the
               commercial WinZip tool); but these zip files will not be readable by
               various other tools or libraries, including Windows Explorer.
             </para>
            
             <para>
               The DotNetZip library can read and write zip files with UTF8-encoded
               entries, according to the PKware spec.  If you use DotNetZip for both
               creating and reading the zip file, and you use UTF-8, there will be no
               loss of information in the filenames. For example, using a self-extractor
               created by this library will allow you to unpack files correctly with no
               loss of information in the filenames.
             </para>
            
             <para>
               If you do not set this flag, it will remain false.  If this flag is false,
               the <c>ZipOutputStream</c> will encode all filenames and comments using
               the IBM437 codepage.  This can cause "loss of information" on some
               filenames, but the resulting zipfile will be more interoperable with other
               utilities. As an example of the loss of information, diacritics can be
               lost.  The o-tilde character will be down-coded to plain o.  The c with a
               cedilla (Unicode 0xE7) used in Portugese will be downcoded to a c.
               Likewise, the O-stroke character (Unicode 248), used in Danish and
               Norwegian, will be down-coded to plain o. Chinese characters cannot be
               represented in codepage IBM437; when using the default encoding, Chinese
               characters in filenames will be represented as ?. These are all examples
               of "information loss".
             </para>
            
             <para>
               The loss of information associated to the use of the IBM437 encoding is
               inconvenient, and can also lead to runtime errors. For example, using
               IBM437, any sequence of 4 Chinese characters will be encoded as ????.  If
               your application creates a <c>ZipOutputStream</c>, does not set the
               encoding, then adds two files, each with names of four Chinese characters
               each, this will result in a duplicate filename exception.  In the case
               where you add a single file with a name containing four Chinese
               characters, the zipfile will save properly, but extracting that file
               later, with any zip tool, will result in an error, because the question
               mark is not legal for use within filenames on Windows.  These are just a
               few examples of the problems associated to loss of information.
             </para>
            
             <para>
               This flag is independent of the encoding of the content within the entries
               in the zip file. Think of the zip file as a container - it supports an
               encoding.  Within the container are other "containers" - the file entries
               themselves.  The encoding within those entries is independent of the
               encoding of the zip archive container for those entries.
             </para>
            
             <para>
               Rather than specify the encoding in a binary fashion using this flag, an
               application can specify an arbitrary encoding via the <see
               cref="P:Ionic.Zip.ZipOutputStream.ProvisionalAlternateEncoding"/> property.  Setting the encoding
               explicitly when creating zip archives will result in non-compliant zip
               files that, curiously, are fairly interoperable.  The challenge is, the
               PKWare specification does not provide for a way to specify that an entry
               in a zip archive uses a code page that is neither IBM437 nor UTF-8.
               Therefore if you set the encoding explicitly when creating a zip archive,
               you must take care upon reading the zip archive to use the same code page.
               If you get it wrong, the behavior is undefined and may result in incorrect
               filenames, exceptions, stomach upset, hair loss, and acne.
             </para>
             </remarks>
             <seealso cref="P:Ionic.Zip.ZipOutputStream.ProvisionalAlternateEncoding"/>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.ProvisionalAlternateEncoding">
             <summary>
               The text encoding to use when emitting entries into the zip archive, for
               those entries whose filenames or comments cannot be encoded with the
               default (IBM437) encoding.
             </summary>
            
             <remarks>
             <para>
               In <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">its
               zip specification</see>, PKWare describes two options for encoding
               filenames and comments: using IBM437 or UTF-8.  But, some archiving tools
               or libraries do not follow the specification, and instead encode
               characters using the system default code page.  For example, WinRAR when
               run on a machine in Shanghai may encode filenames with the Big-5 Chinese
               (950) code page.  This behavior is contrary to the Zip specification, but
               it occurs anyway.
             </para>
            
             <para>
               When using DotNetZip to write zip archives that will be read by one of
               these other archivers, set this property to specify the code page to use
               when encoding the <see cref="P:Ionic.Zip.ZipEntry.FileName"/> and <see
               cref="P:Ionic.Zip.ZipEntry.Comment"/> for each <c>ZipEntry</c> in the zip file, for
               values that cannot be encoded with the default codepage for zip files,
               IBM437.  This is why this property is "provisional".  In all cases, IBM437
               is used where possible, in other words, where no loss of data would
               result. It is possible, therefore, to have a given entry with a
               <c>Comment</c> encoded in IBM437 and a <c>FileName</c> encoded with the
               specified "provisional" codepage.
             </para>
            
             <para>
               Be aware that a zip file created after you've explicitly set the
               <c>ProvisionalAlternateEncoding</c> property to a value other than
               IBM437 may not be compliant to the PKWare specification, and may not be
               readable by compliant archivers.  On the other hand, many (most?)
               archivers are non-compliant and can read zip files created in arbitrary
               code pages.  The trick is to use or specify the proper codepage when
               reading the zip.
             </para>
            
             <para>
               When creating a zip archive using this library, it is possible to change
               the value of <c>ProvisionalAlternateEncoding</c> between each entry you
               add, and between adding entries and the call to <c>Close()</c>. Don't do
               this. It will likely result in a zipfile that is not readable.  For best
               interoperability, either leave <c>ProvisionalAlternateEncoding</c>
               alone, or specify it only once, before adding any entries to the
               <c>ZipOutputStream</c> instance.  There is one exception to this
               recommendation, described later.
             </para>
            
             <para>
               When using an arbitrary, non-UTF8 code page for encoding, there is no
               standard way for the creator application - whether DotNetZip, WinZip,
               WinRar, or something else - to formally specify in the zip file which
               codepage has been used for the entries. As a result, readers of zip files
               are not able to inspect the zip file and determine the codepage that was
               used for the entries contained within it.  It is left to the application
               or user to determine the necessary codepage when reading zip files encoded
               this way.  If you use an incorrect codepage when reading a zipfile, you
               will get entries with filenames that are incorrect, and the incorrect
               filenames may even contain characters that are not legal for use within
               filenames in Windows. Extracting entries with illegal characters in the
               filenames will lead to exceptions. It's too bad, but this is just the way
               things are with code pages in zip files. Caveat Emptor.
             </para>
            
             <para>
               One possible approach for specifying the code page for a given zip file is
               to describe the code page in a human-readable form in the Zip comment. For
               example, the comment may read "Entries in this archive are encoded in the
               Big5 code page".  For maximum interoperability, the zip comment in this
               case should be encoded in the default, IBM437 code page.  In this case,
               the zip comment is encoded using a different page than the filenames.  To
               do this, Specify <c>ProvisionalAlternateEncoding</c> to your desired
               region-specific code page, once before adding any entries, and then set
               the <see cref="P:Ionic.Zip.ZipOutputStream.Comment"/> property and reset
               <c>ProvisionalAlternateEncoding</c> to IBM437 before calling <c>Close()</c>.
             </para>
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.AlternateEncoding">
            <summary>
              A Text Encoding to use when encoding the filenames and comments for
              all the ZipEntry items, during a ZipFile.Save() operation.
            </summary>
            <remarks>
              <para>
                Whether the encoding specified here is used during the save depends
                on <see cref="P:Ionic.Zip.ZipOutputStream.AlternateEncodingUsage"/>.
              </para>
            </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.AlternateEncodingUsage">
            <summary>
              A flag that tells if and when this instance should apply
              AlternateEncoding to encode the filenames and comments associated to
              of ZipEntry objects contained within this instance.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.DefaultEncoding">
            <summary>
            The default text encoding used in zip archives.  It is numeric 437, also
            known as IBM437.
            </summary>
            <seealso cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.ParallelDeflateThreshold">
             <summary>
               The size threshold for an entry, above which a parallel deflate is used.
             </summary>
            
             <remarks>
            
               <para>
                 DotNetZip will use multiple threads to compress any ZipEntry, when
                 the <c>CompressionMethod</c> is Deflate, and if the entry is
                 larger than the given size.  Zero means "always use parallel
                 deflate", while -1 means "never use parallel deflate".
               </para>
            
               <para>
                 If the entry size cannot be known before compression, as with any entry
                 added via a ZipOutputStream, then Parallel deflate will never be
                 performed, unless the value of this property is zero.
               </para>
            
               <para>
                 A parallel deflate operations will speed up the compression of
                 large files, on computers with multiple CPUs or multiple CPU
                 cores.  For files above 1mb, on a dual core or dual-cpu (2p)
                 machine, the time required to compress the file can be 70% of the
                 single-threaded deflate.  For very large files on 4p machines the
                 compression can be done in 30% of the normal time.  The downside
                 is that parallel deflate consumes extra memory during the deflate,
                 and the deflation is slightly less effective.
               </para>
            
               <para>
                 Parallel deflate tends to not be as effective as single-threaded deflate
                 because the original data stream is split into multiple independent
                 buffers, each of which is compressed in parallel.  But because they are
                 treated independently, there is no opportunity to share compression
                 dictionaries, and additional framing bytes must be added to the output
                 stream.  For that reason, a deflated stream may be slightly larger when
                 compressed using parallel deflate, as compared to a traditional
                 single-threaded deflate. For files of about 512k, the increase over the
                 normal deflate is as much as 5% of the total compressed size. For larger
                 files, the difference can be as small as 0.1%.
               </para>
            
               <para>
                 Multi-threaded compression does not give as much an advantage when using
                 Encryption. This is primarily because encryption tends to slow down
                 the entire pipeline. Also, multi-threaded compression gives less of an
                 advantage when using lower compression levels, for example <see
                 cref="F:Ionic.Zlib.CompressionLevel.BestSpeed"/>.  You may have to perform
                 some tests to determine the best approach for your situation.
               </para>
            
               <para>
                 The default value for this property is -1, which means parallel
                 compression will not be performed unless you set it to zero.
               </para>
            
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.ParallelDeflateMaxBufferPairs">
             <summary>
               The maximum number of buffer pairs to use when performing
               parallel compression.
             </summary>
            
             <remarks>
             <para>
               This property sets an upper limit on the number of memory
               buffer pairs to create when performing parallel
               compression.  The implementation of the parallel
               compression stream allocates multiple buffers to
               facilitate parallel compression.  As each buffer fills up,
               the stream uses <see
               cref="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)">
               ThreadPool.QueueUserWorkItem()</see> to compress those
               buffers in a background threadpool thread. After a buffer
               is compressed, it is re-ordered and written to the output
               stream.
             </para>
            
             <para>
               A higher number of buffer pairs enables a higher degree of
               parallelism, which tends to increase the speed of compression on
               multi-cpu computers.  On the other hand, a higher number of buffer
               pairs also implies a larger memory consumption, more active worker
               threads, and a higher cpu utilization for any compression. This
               property enables the application to limit its memory consumption and
               CPU utilization behavior depending on requirements.
             </para>
            
             <para>
               For each compression "task" that occurs in parallel, there are 2
               buffers allocated: one for input and one for output.  This property
               sets a limit for the number of pairs.  The total amount of storage
               space allocated for buffering will then be (N*S*2), where N is the
               number of buffer pairs, S is the size of each buffer (<see
               cref="P:Ionic.Zip.ZipOutputStream.CodecBufferSize"/>).  By default, DotNetZip allocates 4 buffer
               pairs per CPU core, so if your machine has 4 cores, and you retain
               the default buffer size of 128k, then the
               ParallelDeflateOutputStream will use 4 * 4 * 2 * 128kb of buffer
               memory in total, or 4mb, in blocks of 128kb.  If you then set this
               property to 8, then the number will be 8 * 2 * 128kb of buffer
               memory, or 2mb.
             </para>
            
             <para>
               CPU utilization will also go up with additional buffers, because a
               larger number of buffer pairs allows a larger number of background
               threads to compress in parallel. If you find that parallel
               compression is consuming too much memory or CPU, you can adjust this
               value downward.
             </para>
            
             <para>
               The default value is 16. Different values may deliver better or
               worse results, depending on your priorities and the dynamic
               performance characteristics of your storage and compute resources.
             </para>
            
             <para>
               This property is not the number of buffer pairs to use; it is an
               upper limit. An illustration: Suppose you have an application that
               uses the default value of this property (which is 16), and it runs
               on a machine with 2 CPU cores. In that case, DotNetZip will allocate
               4 buffer pairs per CPU core, for a total of 8 pairs.  The upper
               limit specified by this property has no effect.
             </para>
            
             <para>
               The application can set this value at any time, but it is
               effective only if set before calling
               <c>ZipOutputStream.Write()</c> for the first time.
             </para>
             </remarks>
            
             <seealso cref="P:Ionic.Zip.ZipOutputStream.ParallelDeflateThreshold"/>
            
        </member>
        <member name="M:Ionic.Zip.ZipOutputStream.ContainsEntry(System.String)">
             <summary>
               Returns true if an entry by the given name has already been written
               to the ZipOutputStream.
             </summary>
            
             <param name="name">
               The name of the entry to scan for.
             </param>
            
             <returns>
             true if an entry by the given name has already been written.
             </returns>
        </member>
        <member name="M:Ionic.Zip.ZipOutputStream.Write(System.Byte[],System.Int32,System.Int32)">
             <summary>
               Write the data from the buffer to the stream.
             </summary>
            
             <remarks>
               As the application writes data into this stream, the data may be
               compressed and encrypted before being written out to the underlying
               stream, depending on the settings of the <see cref="P:Ionic.Zip.ZipOutputStream.CompressionLevel"/>
               and the <see cref="P:Ionic.Zip.ZipOutputStream.Encryption"/> properties.
             </remarks>
            
             <param name="buffer">The buffer holding data to write to the stream.</param>
             <param name="offset">the offset within that data array to find the first byte to write.</param>
             <param name="count">the number of bytes to write.</param>
        </member>
        <member name="M:Ionic.Zip.ZipOutputStream.PutNextEntry(System.String)">
             <summary>
               Specify the name of the next entry that will be written to the zip file.
             </summary>
            
             <remarks>
             <para>
               Call this method just before calling <see cref="M:Ionic.Zip.ZipOutputStream.Write(System.Byte[],System.Int32,System.Int32)"/>, to
               specify the name of the entry that the next set of bytes written to
               the <c>ZipOutputStream</c> belongs to. All subsequent calls to <c>Write</c>,
               until the next call to <c>PutNextEntry</c>,
               will be inserted into the named entry in the zip file.
             </para>
            
             <para>
               If the <paramref name="entryName"/> used in <c>PutNextEntry()</c> ends in
               a slash, then the entry added is marked as a directory. Because directory
               entries do not contain data, a call to <c>Write()</c>, before an
               intervening additional call to <c>PutNextEntry()</c>, will throw an
               exception.
             </para>
            
             <para>
               If you don't call <c>Write()</c> between two calls to
               <c>PutNextEntry()</c>, the first entry is inserted into the zip file as a
               file of zero size.  This may be what you want.
             </para>
            
             <para>
               Because <c>PutNextEntry()</c> closes out the prior entry, if any, this
               method may throw if there is a problem with the prior entry.
             </para>
            
             <para>
               This method returns the <c>ZipEntry</c>.  You can modify public properties
               on the <c>ZipEntry</c>, such as <see cref="P:Ionic.Zip.ZipEntry.Encryption"/>, <see
               cref="P:Ionic.Zip.ZipEntry.Password"/>, and so on, until the first call to
               <c>ZipOutputStream.Write()</c>, or until the next call to
               <c>PutNextEntry()</c>.  If you modify the <c>ZipEntry</c> <em>after</em>
               having called <c>Write()</c>, you may get a runtime exception, or you may
               silently get an invalid zip archive.
             </para>
            
             </remarks>
            
             <example>
            
               This example shows how to create a zip file, using the
               <c>ZipOutputStream</c> class.
            
             <code>
             private void Zipup()
             {
                 using (FileStream fs raw = File.Open(_outputFileName, FileMode.Create, FileAccess.ReadWrite ))
                 {
                     using (var output= new ZipOutputStream(fs))
                     {
                         output.Password = "VerySecret!";
                         output.Encryption = EncryptionAlgorithm.WinZipAes256;
                         output.PutNextEntry("entry1.txt");
                         byte[] buffer= System.Text.Encoding.ASCII.GetBytes("This is the content for entry #1.");
                         output.Write(buffer,0,buffer.Length);
                         output.PutNextEntry("entry2.txt");  // this will be zero length
                         output.PutNextEntry("entry3.txt");
                         buffer= System.Text.Encoding.ASCII.GetBytes("This is the content for entry #3.");
                         output.Write(buffer,0,buffer.Length);
                     }
                 }
             }
             </code>
             </example>
            
             <param name="entryName">
               The name of the entry to be added, including any path to be used
               within the zip file.
             </param>
            
             <returns>
               The ZipEntry created.
             </returns>
            
        </member>
        <member name="M:Ionic.Zip.ZipOutputStream.Dispose(System.Boolean)">
             <summary>
             Dispose the stream
             </summary>
            
             <remarks>
             <para>
               This method writes the Zip Central directory, then closes the stream.  The
               application must call Dispose() (or Close) in order to produce a valid zip file.
             </para>
            
             <para>
               Typically the application will call <c>Dispose()</c> implicitly, via a <c>using</c>
               statement in C#, or a <c>Using</c> statement in VB.
             </para>
            
             </remarks>
            
             <param name="disposing">set this to true, always.</param>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.CanRead">
            <summary>
            Always returns false.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.CanSeek">
            <summary>
            Always returns false.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.CanWrite">
            <summary>
            Always returns true.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.Length">
            <summary>
            Always returns a NotSupportedException.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.Position">
            <summary>
            Setting this property always returns a NotSupportedException. Getting it
            returns the value of the Position on the underlying stream.
            </summary>
        </member>
        <member name="M:Ionic.Zip.ZipOutputStream.Flush">
            <summary>
            This is a no-op.
            </summary>
        </member>
        <member name="M:Ionic.Zip.ZipOutputStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            This method always throws a NotSupportedException.
            </summary>
            <param name="buffer">ignored</param>
            <param name="offset">ignored</param>
            <param name="count">ignored</param>
            <returns>nothing</returns>
        </member>
        <member name="M:Ionic.Zip.ZipOutputStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            This method always throws a NotSupportedException.
            </summary>
            <param name="offset">ignored</param>
            <param name="origin">ignored</param>
            <returns>nothing</returns>
        </member>
        <member name="M:Ionic.Zip.ZipOutputStream.SetLength(System.Int64)">
            <summary>
            This method always throws a NotSupportedException.
            </summary>
            <param name="value">ignored</param>
        </member>
        <member name="M:Ionic.Zip.ZipSegmentedStream.ForUpdate(System.String,System.UInt32)">
            <summary>
              Sort-of like a factory method, ForUpdate is used only when
              the application needs to update the zip entry metadata for
              a segmented zip file, when the starting segment is earlier
              than the ending segment, for a particular entry.
            </summary>
            <remarks>
              <para>
                The update is always contiguous, never rolls over.  As a
                result, this method doesn't need to return a ZSS; it can
                simply return a FileStream.  That's why it's "sort of"
                like a Factory method.
              </para>
              <para>
                Caller must Close/Dispose the stream object returned by
                this method.
              </para>
            </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipSegmentedStream.CurrentName">
            <summary>
              Name of the filesystem file corresponding to the current segment.
            </summary>
            <remarks>
              <para>
                The name is not always the name currently being used in the
                filesystem.  When rwMode is RwMode.Write, the filesystem file has a
                temporary name until the stream is closed or until the next segment is
                started.
              </para>
            </remarks>
        </member>
        <member name="M:Ionic.Zip.ZipSegmentedStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read from the stream
            </summary>
            <param name="buffer">the buffer to read</param>
            <param name="offset">the offset at which to start</param>
            <param name="count">the number of bytes to read</param>
            <returns>the number of bytes actually read</returns>
        </member>
        <member name="M:Ionic.Zip.ZipSegmentedStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Write to the stream.
            </summary>
            <param name="buffer">the buffer from which to write</param>
            <param name="offset">the offset at which to start writing</param>
            <param name="count">the number of bytes to write</param>
        </member>
    </members>
</doc>
